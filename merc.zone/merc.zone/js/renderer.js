/*! For license information please see renderer.js.LICENSE.txt */ ! function webpackUniversalModuleDefinition(e, t) {
    var n, i;
    if ("object" == typeof exports && "object" == typeof module) module.exports = t();
    else if ("function" == typeof define && define.amd) define([], t);
    else
        for (i in n = t())("object" == typeof exports ? exports : e)[i] = n[i]
}(this, (function() {
    return (() => {
        function __webpack_require__(e) {
            var i, r = n[e];
            return void 0 !== r ? r.exports : (i = n[e] = {
                id: e,
                loaded: !1,
                exports: {}
            }, t[e](i, i.exports, __webpack_require__), i.loaded = !0, i.exports)
        }
        var e, t = {
                6705: e => {
                    var t = 624,
                        n = 397,
                        i = 2147483648,
                        r = 2147483647,
                        a = function MersenneTwister(e) {
                            null == e && (e = (new Date).getTime()), this.mt = new Int32Array(t), this.mti = t + 1, e.constructor == Array ? this.init_by_array(e, e.length) : this.init_seed(e)
                        };
                    a.prototype.init_seed = function(e) {
                        var n = this.mt;
                        for (n[0] = e >>> 0, this.mti = 1; this.mti < t; this.mti++) e = n[this.mti - 1] ^ n[this.mti - 1] >>> 30, n[this.mti] = (1812433253 * ((4294901760 & e) >>> 16) << 16) + 1812433253 * (65535 & e) + this.mti, n[this.mti] >>>= 0
                    }, a.prototype.init_by_array = function(e, n) {
                        var i, r, a, o;
                        for (this.init_seed(19650218), i = 1, r = 0, a = t > n ? t : n; a; a--) o = this.mt[i - 1] ^ this.mt[i - 1] >>> 30, this.mt[i] = (this.mt[i] ^ (1664525 * ((4294901760 & o) >>> 16) << 16) + 1664525 * (65535 & o)) + e[r] + r, this.mt[i] >>>= 0, r++, ++i >= t && (this.mt[0] = this.mt[t - 1], i = 1), r >= n && (r = 0);
                        for (a = t - 1; a; a--) o = this.mt[i - 1] ^ this.mt[i - 1] >>> 30, this.mt[i] = (this.mt[i] ^ (1566083941 * ((4294901760 & o) >>> 16) << 16) + 1566083941 * (65535 & o)) - i, this.mt[i] >>>= 0, ++i >= t && (this.mt[0] = this.mt[t - 1], i = 1);
                        this.mt[0] = 2147483648
                    }, a.prototype.random_int = function() {
                        var e, a, o = this.mt;
                        if (this.mti >= t) {
                            for (this.mti == t + 1 && this.init_seed(5489), a = 0; a < t - n; a++) e = o[a] & i | o[a + 1] & r, o[a] = o[a + n] ^ e >>> 1;
                            for (; a < t - 1; a++) e = o[a] & i | o[a + 1] & r, o[a] = o[a + (n - t)] ^ e >>> 1;
                            e = o[t - 1] & i | o[0] & r, o[t - 1] = o[n - 1] ^ e >>> 1, this.mti = 0
                        }
                        return e = o[this.mti++], e ^= e >>> 11, e ^= e << 7 & 2636928640, e ^= e << 15 & 4022730752, (e ^= e >>> 18) >>> 0
                    }, a.prototype.random_int31 = function() {
                        return this.random_int() >>> 1
                    }, a.prototype.random_incl = function() {
                        return this.random_int() * (1 / 4294967295)
                    }, a.prototype.random = function() {
                        return this.random_int() * (1 / 4294967296)
                    }, a.prototype.random_excl = function() {
                        return (this.random_int() + .5) * (1 / 4294967296)
                    }, a.prototype.random_long = function() {
                        return (67108864 * (this.random_int() >>> 5) + (this.random_int() >>> 6)) * (1 / 9007199254740992)
                    }, e.exports = a
                },
                5590: (e, t, n) => {
                    var i = n(2601),
                        r = n(9051),
                        a = i(r, "DataView");
                    e.exports = a
                },
                3098: (e, t, n) => {
                    function Hash(e) {
                        var t, n = -1,
                            i = null == e ? 0 : e.length;
                        for (this.clear(); ++n < i;) t = e[n], this.set(t[0], t[1])
                    }
                    var i = n(4530),
                        r = n(7201),
                        a = n(9701),
                        o = n(6662),
                        s = n(5917);
                    Hash.prototype.clear = i, Hash.prototype.delete = r, Hash.prototype.get = a, Hash.prototype.has = o, Hash.prototype.set = s, e.exports = Hash
                },
                6187: (e, t, n) => {
                    function ListCache(e) {
                        var t, n = -1,
                            i = null == e ? 0 : e.length;
                        for (this.clear(); ++n < i;) t = e[n], this.set(t[0], t[1])
                    }
                    var i = n(3476),
                        r = n(8378),
                        a = n(3607),
                        o = n(3929),
                        s = n(6205);
                    ListCache.prototype.clear = i, ListCache.prototype.delete = r, ListCache.prototype.get = a, ListCache.prototype.has = o, ListCache.prototype.set = s, e.exports = ListCache
                },
                3146: (e, t, n) => {
                    var i = n(2601),
                        r = n(9051),
                        a = i(r, "Map");
                    e.exports = a
                },
                9772: (e, t, n) => {
                    function MapCache(e) {
                        var t, n = -1,
                            i = null == e ? 0 : e.length;
                        for (this.clear(); ++n < i;) t = e[n], this.set(t[0], t[1])
                    }
                    var i = n(7495),
                        r = n(6179),
                        a = n(2693),
                        o = n(9113),
                        s = n(6883);
                    MapCache.prototype.clear = i, MapCache.prototype.delete = r, MapCache.prototype.get = a, MapCache.prototype.has = o, MapCache.prototype.set = s, e.exports = MapCache
                },
                6877: (e, t, n) => {
                    var i = n(2601),
                        r = n(9051),
                        a = i(r, "Promise");
                    e.exports = a
                },
                5631: (e, t, n) => {
                    var i = n(2601),
                        r = n(9051),
                        a = i(r, "Set");
                    e.exports = a
                },
                3558: (e, t, n) => {
                    function Stack(e) {
                        var t = this.__data__ = new i(e);
                        this.size = t.size
                    }
                    var i = n(6187),
                        r = n(6359),
                        a = n(4409),
                        o = n(923),
                        s = n(4488),
                        l = n(9405);
                    Stack.prototype.clear = r, Stack.prototype.delete = a, Stack.prototype.get = o, Stack.prototype.has = s, Stack.prototype.set = l, e.exports = Stack
                },
                8021: (e, t, n) => {
                    var i = n(9051),
                        r = i.Symbol;
                    e.exports = r
                },
                4956: (e, t, n) => {
                    var i = n(9051),
                        r = i.Uint8Array;
                    e.exports = r
                },
                128: (e, t, n) => {
                    var i = n(2601),
                        r = n(9051),
                        a = i(r, "WeakMap");
                    e.exports = a
                },
                3068: e => {
                    e.exports = function apply(e, t, n) {
                        switch (n.length) {
                            case 0:
                                return e.call(t);
                            case 1:
                                return e.call(t, n[0]);
                            case 2:
                                return e.call(t, n[0], n[1]);
                            case 3:
                                return e.call(t, n[0], n[1], n[2])
                        }
                        return e.apply(t, n)
                    }
                },
                3980: e => {
                    e.exports = function arrayEach(e, t) {
                        for (var n = -1, i = null == e ? 0 : e.length; ++n < i && !1 !== t(e[n], n, e););
                        return e
                    }
                },
                4098: e => {
                    e.exports = function arrayFilter(e, t) {
                        for (var n, i = -1, r = null == e ? 0 : e.length, a = 0, o = []; ++i < r;) t(n = e[i], i, e) && (o[a++] = n);
                        return o
                    }
                },
                4985: (e, t, n) => {
                    var i = n(4854),
                        r = n(1431),
                        a = n(7253),
                        o = n(438),
                        s = n(6892),
                        l = n(8490),
                        c = Object.prototype,
                        u = c.hasOwnProperty;
                    e.exports = function arrayLikeKeys(e, t) {
                        var n, c = a(e),
                            h = !c && r(e),
                            d = !c && !h && o(e),
                            p = !c && !h && !d && l(e),
                            f = c || h || d || p,
                            m = f ? i(e.length, String) : [],
                            g = m.length;
                        for (n in e) !t && !u.call(e, n) || f && ("length" == n || d && ("offset" == n || "parent" == n) || p && ("buffer" == n || "byteLength" == n || "byteOffset" == n) || s(n, g)) || m.push(n);
                        return m
                    }
                },
                8812: e => {
                    e.exports = function arrayPush(e, t) {
                        for (var n = -1, i = t.length, r = e.length; ++n < i;) e[r + n] = t[n];
                        return e
                    }
                },
                9418: (e, t, n) => {
                    var i = n(695),
                        r = n(9367),
                        a = Object.prototype,
                        o = a.hasOwnProperty;
                    e.exports = function assignValue(e, t, n) {
                        var a = e[t];
                        o.call(e, t) && r(a, n) && (void 0 !== n || t in e) || i(e, t, n)
                    }
                },
                1354: (e, t, n) => {
                    var i = n(9367);
                    e.exports = function assocIndexOf(e, t) {
                        for (var n = e.length; n--;)
                            if (i(e[n][0], t)) return n;
                        return -1
                    }
                },
                1579: (e, t, n) => {
                    var i = n(864),
                        r = n(9986);
                    e.exports = function baseAssign(e, t) {
                        return e && i(t, r(t), e)
                    }
                },
                9616: (e, t, n) => {
                    var i = n(864),
                        r = n(8424);
                    e.exports = function baseAssignIn(e, t) {
                        return e && i(t, r(t), e)
                    }
                },
                695: (e, t, n) => {
                    var i = n(1985);
                    e.exports = function baseAssignValue(e, t, n) {
                        "__proto__" == t && i ? i(e, t, {
                            configurable: !0,
                            enumerable: !0,
                            value: n,
                            writable: !0
                        }) : e[t] = n
                    }
                },
                459: (e, t, n) => {
                    var i = n(3558),
                        r = n(3980),
                        a = n(9418),
                        o = n(1579),
                        s = n(9616),
                        l = n(3973),
                        c = n(4595),
                        u = n(2971),
                        h = n(7526),
                        d = n(5487),
                        p = n(1446),
                        f = n(629),
                        m = n(3960),
                        g = n(1355),
                        y = n(1439),
                        x = n(7253),
                        _ = n(438),
                        b = n(9122),
                        M = n(6679),
                        S = n(4262),
                        A = n(9986),
                        w = n(8424),
                        T = 1,
                        L = 2,
                        C = 4,
                        P = "[object Arguments]",
                        E = "[object Array]",
                        I = "[object Boolean]",
                        F = "[object Date]",
                        O = "[object Error]",
                        B = "[object Function]",
                        R = "[object GeneratorFunction]",
                        N = "[object Map]",
                        D = "[object Number]",
                        V = "[object Object]",
                        U = "[object RegExp]",
                        z = "[object Set]",
                        G = "[object String]",
                        k = "[object Symbol]",
                        j = "[object WeakMap]",
                        W = "[object ArrayBuffer]",
                        H = "[object DataView]",
                        X = "[object Float32Array]",
                        Y = "[object Float64Array]",
                        q = "[object Int8Array]",
                        Q = "[object Int16Array]",
                        J = "[object Int32Array]",
                        Z = "[object Uint8Array]",
                        K = "[object Uint8ClampedArray]",
                        $ = "[object Uint16Array]",
                        ee = "[object Uint32Array]",
                        te = {};
                    te[P] = te[E] = te[W] = te[H] = te[I] = te[F] = te[X] = te[Y] = te[q] = te[Q] = te[J] = te[N] = te[D] = te[V] = te[U] = te[z] = te[G] = te[k] = te[Z] = te[K] = te[$] = te[ee] = !0, te[O] = te[B] = te[j] = !1, e.exports = function baseClone(e, t, n, E, I, F) {
                        var O, N, D, U, z, G, k = t & T,
                            j = t & L,
                            W = t & C;
                        if (n && (O = I ? n(e, E, I, F) : n(e)), void 0 !== O) return O;
                        if (!M(e)) return e;
                        if (N = x(e)) {
                            if (O = m(e), !k) return c(e, O)
                        } else {
                            if (U = (D = f(e)) == B || D == R, _(e)) return l(e, k);
                            if (D == V || D == P || U && !I) {
                                if (O = j || U ? {} : y(e), !k) return j ? h(e, s(O, e)) : u(e, o(O, e))
                            } else {
                                if (!te[D]) return I ? e : {};
                                O = g(e, D, k)
                            }
                        }
                        return F || (F = new i), (z = F.get(e)) ? z : (F.set(e, O), S(e) ? e.forEach((function(i) {
                            O.add(baseClone(i, t, n, i, e, F))
                        })) : b(e) && e.forEach((function(i, r) {
                            O.set(r, baseClone(i, t, n, r, e, F))
                        })), G = N ? void 0 : (W ? j ? p : d : j ? w : A)(e), r(G || e, (function(i, r) {
                            G && (i = e[r = i]), a(O, r, baseClone(i, t, n, r, e, F))
                        })), O)
                    }
                },
                5509: (e, t, n) => {
                    var i = n(6679),
                        r = Object.create,
                        a = function() {
                            function object() {}
                            return function(e) {
                                if (!i(e)) return {};
                                if (r) return r(e);
                                object.prototype = e;
                                var t = new object;
                                return object.prototype = void 0, t
                            }
                        }();
                    e.exports = a
                },
                242: (e, t, n) => {
                    var i = n(8812),
                        r = n(7253);
                    e.exports = function baseGetAllKeys(e, t, n) {
                        var a = t(e);
                        return r(e) ? a : i(a, n(e))
                    }
                },
                8116: (e, t, n) => {
                    var i = n(8021),
                        r = n(693),
                        a = n(2351),
                        o = "[object Null]",
                        s = "[object Undefined]",
                        l = i ? i.toStringTag : void 0;
                    e.exports = function baseGetTag(e) {
                        return null == e ? void 0 === e ? s : o : l && l in Object(e) ? r(e) : a(e)
                    }
                },
                3237: (e, t, n) => {
                    var i = n(8116),
                        r = n(2287),
                        a = "[object Arguments]";
                    e.exports = function baseIsArguments(e) {
                        return r(e) && i(e) == a
                    }
                },
                559: (e, t, n) => {
                    var i = n(629),
                        r = n(2287),
                        a = "[object Map]";
                    e.exports = function baseIsMap(e) {
                        return r(e) && i(e) == a
                    }
                },
                7837: (e, t, n) => {
                    var i = n(5301),
                        r = n(7933),
                        a = n(6679),
                        o = n(1204),
                        s = /[\\^$.*+?()[\]{}|]/g,
                        l = /^\[object .+?Constructor\]$/,
                        c = Function.prototype,
                        u = Object.prototype,
                        h = c.toString,
                        d = u.hasOwnProperty,
                        p = RegExp("^" + h.call(d).replace(s, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
                    e.exports = function baseIsNative(e) {
                        return !(!a(e) || r(e)) && (i(e) ? p : l).test(o(e))
                    }
                },
                7887: (e, t, n) => {
                    var i = n(629),
                        r = n(2287),
                        a = "[object Set]";
                    e.exports = function baseIsSet(e) {
                        return r(e) && i(e) == a
                    }
                },
                2358: (e, t, n) => {
                    var i = n(8116),
                        r = n(2196),
                        a = n(2287),
                        o = "[object Arguments]",
                        s = "[object Array]",
                        l = "[object Boolean]",
                        c = "[object Date]",
                        u = "[object Error]",
                        h = "[object Function]",
                        d = "[object Map]",
                        p = "[object Number]",
                        f = "[object Object]",
                        m = "[object RegExp]",
                        g = "[object Set]",
                        y = "[object String]",
                        x = "[object WeakMap]",
                        _ = "[object ArrayBuffer]",
                        b = "[object DataView]",
                        M = "[object Float32Array]",
                        S = "[object Float64Array]",
                        A = "[object Int8Array]",
                        w = "[object Int16Array]",
                        T = "[object Int32Array]",
                        L = "[object Uint8Array]",
                        C = "[object Uint8ClampedArray]",
                        P = "[object Uint16Array]",
                        E = "[object Uint32Array]",
                        I = {};
                    I[M] = I[S] = I[A] = I[w] = I[T] = I[L] = I[C] = I[P] = I[E] = !0, I[o] = I[s] = I[_] = I[l] = I[b] = I[c] = I[u] = I[h] = I[d] = I[p] = I[f] = I[m] = I[g] = I[y] = I[x] = !1, e.exports = function baseIsTypedArray(e) {
                        return a(e) && r(e.length) && !!I[i(e)]
                    }
                },
                4733: (e, t, n) => {
                    var i = n(9134),
                        r = n(8057),
                        a = Object.prototype,
                        o = a.hasOwnProperty;
                    e.exports = function baseKeys(e) {
                        var t, n;
                        if (!i(e)) return r(e);
                        for (n in t = [], Object(e)) o.call(e, n) && "constructor" != n && t.push(n);
                        return t
                    }
                },
                6614: (e, t, n) => {
                    var i = n(6679),
                        r = n(9134),
                        a = n(2431),
                        o = Object.prototype,
                        s = o.hasOwnProperty;
                    e.exports = function baseKeysIn(e) {
                        var t, n, o;
                        if (!i(e)) return a(e);
                        for (o in t = r(e), n = [], e)("constructor" != o || !t && s.call(e, o)) && n.push(o);
                        return n
                    }
                },
                3344: (e, t, n) => {
                    var i = n(2647),
                        r = n(7093),
                        a = n(2950);
                    e.exports = function baseRest(e, t) {
                        return a(r(e, t, i), e + "")
                    }
                },
                9564: (e, t, n) => {
                    var i = n(5439),
                        r = n(1985),
                        a = n(2647),
                        o = r ? function(e, t) {
                            return r(e, "toString", {
                                configurable: !0,
                                enumerable: !1,
                                value: i(t),
                                writable: !0
                            })
                        } : a;
                    e.exports = o
                },
                4854: e => {
                    e.exports = function baseTimes(e, t) {
                        for (var n = -1, i = Array(e); ++n < e;) i[n] = t(n);
                        return i
                    }
                },
                6997: e => {
                    e.exports = function baseUnary(e) {
                        return function(t) {
                            return e(t)
                        }
                    }
                },
                145: (e, t, n) => {
                    var i = n(4956);
                    e.exports = function cloneArrayBuffer(e) {
                        var t = new e.constructor(e.byteLength);
                        return new i(t).set(new i(e)), t
                    }
                },
                3973: (e, t, n) => {
                    var i, r, a, o, s;
                    e = n.nmd(e), i = n(9051), o = (a = (r = t && !t.nodeType && t) && e && !e.nodeType && e) && a.exports === r ? i.Buffer : void 0, s = o ? o.allocUnsafe : void 0, e.exports = function cloneBuffer(e, t) {
                        if (t) return e.slice();
                        var n = e.length,
                            i = s ? s(n) : new e.constructor(n);
                        return e.copy(i), i
                    }
                },
                4788: (e, t, n) => {
                    var i = n(145);
                    e.exports = function cloneDataView(e, t) {
                        var n = t ? i(e.buffer) : e.buffer;
                        return new e.constructor(n, e.byteOffset, e.byteLength)
                    }
                },
                1112: e => {
                    var t = /\w*$/;
                    e.exports = function cloneRegExp(e) {
                        var n = new e.constructor(e.source, t.exec(e));
                        return n.lastIndex = e.lastIndex, n
                    }
                },
                4928: (e, t, n) => {
                    var i = n(8021),
                        r = i ? i.prototype : void 0,
                        a = r ? r.valueOf : void 0;
                    e.exports = function cloneSymbol(e) {
                        return a ? Object(a.call(e)) : {}
                    }
                },
                5304: (e, t, n) => {
                    var i = n(145);
                    e.exports = function cloneTypedArray(e, t) {
                        var n = t ? i(e.buffer) : e.buffer;
                        return new e.constructor(n, e.byteOffset, e.length)
                    }
                },
                4595: e => {
                    e.exports = function copyArray(e, t) {
                        var n = -1,
                            i = e.length;
                        for (t || (t = Array(i)); ++n < i;) t[n] = e[n];
                        return t
                    }
                },
                864: (e, t, n) => {
                    var i = n(9418),
                        r = n(695);
                    e.exports = function copyObject(e, t, n, a) {
                        var o, s, l, c, u = !n;
                        for (n || (n = {}), o = -1, s = t.length; ++o < s;) l = t[o], void 0 === (c = a ? a(n[l], e[l], l, n, e) : void 0) && (c = e[l]), u ? r(n, l, c) : i(n, l, c);
                        return n
                    }
                },
                2971: (e, t, n) => {
                    var i = n(864),
                        r = n(5392);
                    e.exports = function copySymbols(e, t) {
                        return i(e, r(e), t)
                    }
                },
                7526: (e, t, n) => {
                    var i = n(864),
                        r = n(7685);
                    e.exports = function copySymbolsIn(e, t) {
                        return i(e, r(e), t)
                    }
                },
                1595: (e, t, n) => {
                    var i = n(9051),
                        r = i["__core-js_shared__"];
                    e.exports = r
                },
                1985: (e, t, n) => {
                    var i = n(2601),
                        r = function() {
                            try {
                                var e = i(Object, "defineProperty");
                                return e({}, "", {}), e
                            } catch (e) {}
                        }();
                    e.exports = r
                },
                9013: (e, t, n) => {
                    var i = "object" == typeof n.g && n.g && n.g.Object === Object && n.g;
                    e.exports = i
                },
                5487: (e, t, n) => {
                    var i = n(242),
                        r = n(5392),
                        a = n(9986);
                    e.exports = function getAllKeys(e) {
                        return i(e, a, r)
                    }
                },
                1446: (e, t, n) => {
                    var i = n(242),
                        r = n(7685),
                        a = n(8424);
                    e.exports = function getAllKeysIn(e) {
                        return i(e, a, r)
                    }
                },
                3149: (e, t, n) => {
                    var i = n(2779);
                    e.exports = function getMapData(e, t) {
                        var n = e.__data__;
                        return i(t) ? n["string" == typeof t ? "string" : "hash"] : n.map
                    }
                },
                2601: (e, t, n) => {
                    var i = n(7837),
                        r = n(5266);
                    e.exports = function getNative(e, t) {
                        var n = r(e, t);
                        return i(n) ? n : void 0
                    }
                },
                3991: (e, t, n) => {
                    var i = n(3892),
                        r = i(Object.getPrototypeOf, Object);
                    e.exports = r
                },
                693: (e, t, n) => {
                    var i = n(8021),
                        r = Object.prototype,
                        a = r.hasOwnProperty,
                        o = r.toString,
                        s = i ? i.toStringTag : void 0;
                    e.exports = function getRawTag(e) {
                        var t, n, i = a.call(e, s),
                            r = e[s];
                        try {
                            e[s] = void 0, t = !0
                        } catch (e) {}
                        return n = o.call(e), t && (i ? e[s] = r : delete e[s]), n
                    }
                },
                5392: (e, t, n) => {
                    var i = n(4098),
                        r = n(9783),
                        a = Object.prototype,
                        o = a.propertyIsEnumerable,
                        s = Object.getOwnPropertySymbols,
                        l = s ? function(e) {
                            return null == e ? [] : i(s(e = Object(e)), (function(t) {
                                return o.call(e, t)
                            }))
                        } : r;
                    e.exports = l
                },
                7685: (e, t, n) => {
                    var i = n(8812),
                        r = n(3991),
                        a = n(5392),
                        o = n(9783),
                        s = Object.getOwnPropertySymbols,
                        l = s ? function(e) {
                            for (var t = []; e;) i(t, a(e)), e = r(e);
                            return t
                        } : o;
                    e.exports = l
                },
                629: (e, t, n) => {
                    var i = n(5590),
                        r = n(3146),
                        a = n(6877),
                        o = n(5631),
                        s = n(128),
                        l = n(8116),
                        c = n(1204),
                        u = "[object Map]",
                        h = "[object Object]",
                        d = "[object Promise]",
                        p = "[object Set]",
                        f = "[object WeakMap]",
                        m = "[object DataView]",
                        g = c(i),
                        y = c(r),
                        x = c(a),
                        _ = c(o),
                        b = c(s),
                        M = l;
                    (i && M(new i(new ArrayBuffer(1))) != m || r && M(new r) != u || a && M(a.resolve()) != d || o && M(new o) != p || s && M(new s) != f) && (M = function(e) {
                        var t = l(e),
                            n = t == h ? e.constructor : void 0,
                            i = n ? c(n) : "";
                        if (i) switch (i) {
                            case g:
                                return m;
                            case y:
                                return u;
                            case x:
                                return d;
                            case _:
                                return p;
                            case b:
                                return f
                        }
                        return t
                    }), e.exports = M
                },
                5266: e => {
                    e.exports = function getValue(e, t) {
                        return null == e ? void 0 : e[t]
                    }
                },
                4530: (e, t, n) => {
                    var i = n(4080);
                    e.exports = function hashClear() {
                        this.__data__ = i ? i(null) : {}, this.size = 0
                    }
                },
                7201: e => {
                    e.exports = function hashDelete(e) {
                        var t = this.has(e) && delete this.__data__[e];
                        return this.size -= t ? 1 : 0, t
                    }
                },
                9701: (e, t, n) => {
                    var i = n(4080),
                        r = "__lodash_hash_undefined__",
                        a = Object.prototype,
                        o = a.hasOwnProperty;
                    e.exports = function hashGet(e) {
                        var t, n = this.__data__;
                        return i ? (t = n[e]) === r ? void 0 : t : o.call(n, e) ? n[e] : void 0
                    }
                },
                6662: (e, t, n) => {
                    var i = n(4080),
                        r = Object.prototype,
                        a = r.hasOwnProperty;
                    e.exports = function hashHas(e) {
                        var t = this.__data__;
                        return i ? void 0 !== t[e] : a.call(t, e)
                    }
                },
                5917: (e, t, n) => {
                    var i = n(4080),
                        r = "__lodash_hash_undefined__";
                    e.exports = function hashSet(e, t) {
                        var n = this.__data__;
                        return this.size += this.has(e) ? 0 : 1, n[e] = i && void 0 === t ? r : t, this
                    }
                },
                3960: e => {
                    var t = Object.prototype,
                        n = t.hasOwnProperty;
                    e.exports = function initCloneArray(e) {
                        var t = e.length,
                            i = new e.constructor(t);
                        return t && "string" == typeof e[0] && n.call(e, "index") && (i.index = e.index, i.input = e.input), i
                    }
                },
                1355: (e, t, n) => {
                    var i = n(145),
                        r = n(4788),
                        a = n(1112),
                        o = n(4928),
                        s = n(5304),
                        l = "[object Boolean]",
                        c = "[object Date]",
                        u = "[object Map]",
                        h = "[object Number]",
                        d = "[object RegExp]",
                        p = "[object Set]",
                        f = "[object String]",
                        m = "[object Symbol]",
                        g = "[object ArrayBuffer]",
                        y = "[object DataView]",
                        x = "[object Float32Array]",
                        _ = "[object Float64Array]",
                        b = "[object Int8Array]",
                        M = "[object Int16Array]",
                        S = "[object Int32Array]",
                        A = "[object Uint8Array]",
                        w = "[object Uint8ClampedArray]",
                        T = "[object Uint16Array]",
                        L = "[object Uint32Array]";
                    e.exports = function initCloneByTag(e, t, n) {
                        var C = e.constructor;
                        switch (t) {
                            case g:
                                return i(e);
                            case l:
                            case c:
                                return new C(+e);
                            case y:
                                return r(e, n);
                            case x:
                            case _:
                            case b:
                            case M:
                            case S:
                            case A:
                            case w:
                            case T:
                            case L:
                                return s(e, n);
                            case u:
                                return new C;
                            case h:
                            case f:
                                return new C(e);
                            case d:
                                return a(e);
                            case p:
                                return new C;
                            case m:
                                return o(e)
                        }
                    }
                },
                1439: (e, t, n) => {
                    var i = n(5509),
                        r = n(3991),
                        a = n(9134);
                    e.exports = function initCloneObject(e) {
                        return "function" != typeof e.constructor || a(e) ? {} : i(r(e))
                    }
                },
                6892: e => {
                    var t = 9007199254740991,
                        n = /^(?:0|[1-9]\d*)$/;
                    e.exports = function isIndex(e, i) {
                        var r = typeof e;
                        return !!(i = null == i ? t : i) && ("number" == r || "symbol" != r && n.test(e)) && e > -1 && e % 1 == 0 && e < i
                    }
                },
                6280: (e, t, n) => {
                    var i = n(9367),
                        r = n(23),
                        a = n(6892),
                        o = n(6679);
                    e.exports = function isIterateeCall(e, t, n) {
                        if (!o(n)) return !1;
                        var s = typeof t;
                        return !!("number" == s ? r(n) && a(t, n.length) : "string" == s && t in n) && i(n[t], e)
                    }
                },
                2779: e => {
                    e.exports = function isKeyable(e) {
                        var t = typeof e;
                        return "string" == t || "number" == t || "symbol" == t || "boolean" == t ? "__proto__" !== e : null === e
                    }
                },
                7933: (e, t, n) => {
                    var i, r = n(1595),
                        a = (i = /[^.]+$/.exec(r && r.keys && r.keys.IE_PROTO || "")) ? "Symbol(src)_1." + i : "";
                    e.exports = function isMasked(e) {
                        return !!a && a in e
                    }
                },
                9134: e => {
                    var t = Object.prototype;
                    e.exports = function isPrototype(e) {
                        var n = e && e.constructor;
                        return e === ("function" == typeof n && n.prototype || t)
                    }
                },
                3476: e => {
                    e.exports = function listCacheClear() {
                        this.__data__ = [], this.size = 0
                    }
                },
                8378: (e, t, n) => {
                    var i = n(1354),
                        r = Array.prototype,
                        a = r.splice;
                    e.exports = function listCacheDelete(e) {
                        var t = this.__data__,
                            n = i(t, e);
                        return !(n < 0) && (n == t.length - 1 ? t.pop() : a.call(t, n, 1), --this.size, !0)
                    }
                },
                3607: (e, t, n) => {
                    var i = n(1354);
                    e.exports = function listCacheGet(e) {
                        var t = this.__data__,
                            n = i(t, e);
                        return n < 0 ? void 0 : t[n][1]
                    }
                },
                3929: (e, t, n) => {
                    var i = n(1354);
                    e.exports = function listCacheHas(e) {
                        return i(this.__data__, e) > -1
                    }
                },
                6205: (e, t, n) => {
                    var i = n(1354);
                    e.exports = function listCacheSet(e, t) {
                        var n = this.__data__,
                            r = i(n, e);
                        return r < 0 ? (++this.size, n.push([e, t])) : n[r][1] = t, this
                    }
                },
                7495: (e, t, n) => {
                    var i = n(3098),
                        r = n(6187),
                        a = n(3146);
                    e.exports = function mapCacheClear() {
                        this.size = 0, this.__data__ = {
                            hash: new i,
                            map: new(a || r),
                            string: new i
                        }
                    }
                },
                6179: (e, t, n) => {
                    var i = n(3149);
                    e.exports = function mapCacheDelete(e) {
                        var t = i(this, e).delete(e);
                        return this.size -= t ? 1 : 0, t
                    }
                },
                2693: (e, t, n) => {
                    var i = n(3149);
                    e.exports = function mapCacheGet(e) {
                        return i(this, e).get(e)
                    }
                },
                9113: (e, t, n) => {
                    var i = n(3149);
                    e.exports = function mapCacheHas(e) {
                        return i(this, e).has(e)
                    }
                },
                6883: (e, t, n) => {
                    var i = n(3149);
                    e.exports = function mapCacheSet(e, t) {
                        var n = i(this, e),
                            r = n.size;
                        return n.set(e, t), this.size += n.size == r ? 0 : 1, this
                    }
                },
                4080: (e, t, n) => {
                    var i = n(2601),
                        r = i(Object, "create");
                    e.exports = r
                },
                8057: (e, t, n) => {
                    var i = n(3892),
                        r = i(Object.keys, Object);
                    e.exports = r
                },
                2431: e => {
                    e.exports = function nativeKeysIn(e) {
                        var t, n = [];
                        if (null != e)
                            for (t in Object(e)) n.push(t);
                        return n
                    }
                },
                2377: (e, t, n) => {
                    var i, r, a, o, s, l;
                    e = n.nmd(e), i = n(9013), r = t && !t.nodeType && t, o = (a = r && e && !e.nodeType && e) && a.exports === r, s = o && i.process, l = function() {
                        try {
                            var e = a && a.require && a.require("util").types;
                            return e || s && s.binding && s.binding("util")
                        } catch (e) {}
                    }(), e.exports = l
                },
                2351: e => {
                    var t = Object.prototype,
                        n = t.toString;
                    e.exports = function objectToString(e) {
                        return n.call(e)
                    }
                },
                3892: e => {
                    e.exports = function overArg(e, t) {
                        return function(n) {
                            return e(t(n))
                        }
                    }
                },
                7093: (e, t, n) => {
                    var i = n(3068),
                        r = Math.max;
                    e.exports = function overRest(e, t, n) {
                        return t = r(void 0 === t ? e.length - 1 : t, 0),
                            function() {
                                for (var a, o = arguments, s = -1, l = r(o.length - t, 0), c = Array(l); ++s < l;) c[s] = o[t + s];
                                for (s = -1, a = Array(t + 1); ++s < t;) a[s] = o[s];
                                return a[t] = n(c), i(e, this, a)
                            }
                    }
                },
                9051: (e, t, n) => {
                    var i = n(9013),
                        r = "object" == typeof self && self && self.Object === Object && self,
                        a = i || r || Function("return this")();
                    e.exports = a
                },
                2950: (e, t, n) => {
                    var i = n(9564),
                        r = n(4614),
                        a = r(i);
                    e.exports = a
                },
                4614: e => {
                    var t = 800,
                        n = 16,
                        i = Date.now;
                    e.exports = function shortOut(e) {
                        var r = 0,
                            a = 0;
                        return function() {
                            var o = i(),
                                s = n - (o - a);
                            if (a = o, s > 0) {
                                if (++r >= t) return arguments[0]
                            } else r = 0;
                            return e.apply(void 0, arguments)
                        }
                    }
                },
                6359: (e, t, n) => {
                    var i = n(6187);
                    e.exports = function stackClear() {
                        this.__data__ = new i, this.size = 0
                    }
                },
                4409: e => {
                    e.exports = function stackDelete(e) {
                        var t = this.__data__,
                            n = t.delete(e);
                        return this.size = t.size, n
                    }
                },
                923: e => {
                    e.exports = function stackGet(e) {
                        return this.__data__.get(e)
                    }
                },
                4488: e => {
                    e.exports = function stackHas(e) {
                        return this.__data__.has(e)
                    }
                },
                9405: (e, t, n) => {
                    var i = n(6187),
                        r = n(3146),
                        a = n(9772),
                        o = 200;
                    e.exports = function stackSet(e, t) {
                        var n, s = this.__data__;
                        if (s instanceof i) {
                            if (n = s.__data__, !r || n.length < o - 1) return n.push([e, t]), this.size = ++s.size, this;
                            s = this.__data__ = new a(n)
                        }
                        return s.set(e, t), this.size = s.size, this
                    }
                },
                1204: e => {
                    var t = Function.prototype,
                        n = t.toString;
                    e.exports = function toSource(e) {
                        if (null != e) {
                            try {
                                return n.call(e)
                            } catch (e) {}
                            try {
                                return e + ""
                            } catch (e) {}
                        }
                        return ""
                    }
                },
                2753: (e, t, n) => {
                    var i = n(459),
                        r = 4;
                    e.exports = function clone(e) {
                        return i(e, r)
                    }
                },
                7120: (e, t, n) => {
                    var i = n(459),
                        r = 1,
                        a = 4;
                    e.exports = function cloneDeep(e) {
                        return i(e, r | a)
                    }
                },
                5439: e => {
                    e.exports = function constant(e) {
                        return function() {
                            return e
                        }
                    }
                },
                6445: (e, t, n) => {
                    var i = n(3344),
                        r = n(9367),
                        a = n(6280),
                        o = n(8424),
                        s = Object.prototype,
                        l = s.hasOwnProperty,
                        c = i((function(e, t) {
                            var n, i, c, u, h, d, p, f, m;
                            for (e = Object(e), n = -1, (c = (i = t.length) > 2 ? t[2] : void 0) && a(t[0], t[1], c) && (i = 1); ++n < i;)
                                for (u = t[n], d = -1, p = (h = o(u)).length; ++d < p;)(void 0 === (m = e[f = h[d]]) || r(m, s[f]) && !l.call(e, f)) && (e[f] = u[f]);
                            return e
                        }));
                    e.exports = c
                },
                9367: e => {
                    e.exports = function eq(e, t) {
                        return e === t || e != e && t != t
                    }
                },
                2647: e => {
                    e.exports = function identity(e) {
                        return e
                    }
                },
                1431: (e, t, n) => {
                    var i = n(3237),
                        r = n(2287),
                        a = Object.prototype,
                        o = a.hasOwnProperty,
                        s = a.propertyIsEnumerable,
                        l = i(function() {
                            return arguments
                        }()) ? i : function(e) {
                            return r(e) && o.call(e, "callee") && !s.call(e, "callee")
                        };
                    e.exports = l
                },
                7253: e => {
                    var t = Array.isArray;
                    e.exports = t
                },
                23: (e, t, n) => {
                    var i = n(5301),
                        r = n(2196);
                    e.exports = function isArrayLike(e) {
                        return null != e && r(e.length) && !i(e)
                    }
                },
                438: (e, t, n) => {
                    var i, r, a, o, s, l;
                    e = n.nmd(e), i = n(9051), r = n(2230), l = ((s = (o = (a = t && !t.nodeType && t) && e && !e.nodeType && e) && o.exports === a ? i.Buffer : void 0) ? s.isBuffer : void 0) || r, e.exports = l
                },
                5301: (e, t, n) => {
                    var i = n(8116),
                        r = n(6679),
                        a = "[object AsyncFunction]",
                        o = "[object Function]",
                        s = "[object GeneratorFunction]",
                        l = "[object Proxy]";
                    e.exports = function isFunction(e) {
                        if (!r(e)) return !1;
                        var t = i(e);
                        return t == o || t == s || t == a || t == l
                    }
                },
                2196: e => {
                    e.exports = function isLength(e) {
                        return "number" == typeof e && e > -1 && e % 1 == 0 && e <= 9007199254740991
                    }
                },
                9122: (e, t, n) => {
                    var i = n(559),
                        r = n(6997),
                        a = n(2377),
                        o = a && a.isMap,
                        s = o ? r(o) : i;
                    e.exports = s
                },
                6679: e => {
                    e.exports = function isObject(e) {
                        var t = typeof e;
                        return null != e && ("object" == t || "function" == t)
                    }
                },
                2287: e => {
                    e.exports = function isObjectLike(e) {
                        return null != e && "object" == typeof e
                    }
                },
                4262: (e, t, n) => {
                    var i = n(7887),
                        r = n(6997),
                        a = n(2377),
                        o = a && a.isSet,
                        s = o ? r(o) : i;
                    e.exports = s
                },
                8490: (e, t, n) => {
                    var i = n(2358),
                        r = n(6997),
                        a = n(2377),
                        o = a && a.isTypedArray,
                        s = o ? r(o) : i;
                    e.exports = s
                },
                9986: (e, t, n) => {
                    var i = n(4985),
                        r = n(4733),
                        a = n(23);
                    e.exports = function keys(e) {
                        return a(e) ? i(e) : r(e)
                    }
                },
                8424: (e, t, n) => {
                    var i = n(4985),
                        r = n(6614),
                        a = n(23);
                    e.exports = function keysIn(e) {
                        return a(e) ? i(e, !0) : r(e)
                    }
                },
                9783: e => {
                    e.exports = function stubArray() {
                        return []
                    }
                },
                2230: e => {
                    e.exports = function stubFalse() {
                        return !1
                    }
                }
            },
            n = {};
        return __webpack_require__.n = e => {
            var t = e && e.__esModule ? () => e.default : () => e;
            return __webpack_require__.d(t, {
                a: t
            }), t
        }, __webpack_require__.d = (e, t) => {
            for (var n in t) __webpack_require__.o(t, n) && !__webpack_require__.o(e, n) && Object.defineProperty(e, n, {
                enumerable: !0,
                get: t[n]
            })
        }, __webpack_require__.g = function() {
            if ("object" == typeof globalThis) return globalThis;
            try {
                return this || Function("return this")()
            } catch (e) {
                if ("object" == typeof window) return window
            }
        }(), __webpack_require__.o = (e, t) => Object.prototype.hasOwnProperty.call(e, t), __webpack_require__.r = e => {
            "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
                value: "Module"
            }), Object.defineProperty(e, "__esModule", {
                value: !0
            })
        }, __webpack_require__.nmd = e => (e.paths = [], e.children || (e.children = []), e), e = {}, (() => {
            "use strict";

            function _typeof(e) {
                return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                    return typeof e
                } : function(e) {
                    return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
                }, _typeof(e)
            }

            function _setPrototypeOf(e, t) {
                return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(e, t) {
                    return e.__proto__ = t, e
                }, _setPrototypeOf(e, t)
            }

            function _inherits(e, t) {
                if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
                e.prototype = Object.create(t && t.prototype, {
                    constructor: {
                        value: e,
                        writable: !0,
                        configurable: !0
                    }
                }), Object.defineProperty(e, "prototype", {
                    writable: !1
                }), t && _setPrototypeOf(e, t)
            }

            function _assertThisInitialized(e) {
                if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                return e
            }

            function _possibleConstructorReturn(e, t) {
                if (t && ("object" === _typeof(t) || "function" == typeof t)) return t;
                if (void 0 !== t) throw new TypeError("Derived constructors may only return object or undefined");
                return _assertThisInitialized(e)
            }

            function _getPrototypeOf(e) {
                return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(e) {
                    return e.__proto__ || Object.getPrototypeOf(e)
                }, _getPrototypeOf(e)
            }

            function classCallCheck_classCallCheck(e, t) {
                if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
            }

            function _defineProperties(e, t) {
                var n, i;
                for (n = 0; n < t.length; n++)(i = t[n]).enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
            }

            function createClass_createClass(e, t, n) {
                return t && _defineProperties(e.prototype, t), n && _defineProperties(e, n), Object.defineProperty(e, "prototype", {
                    writable: !1
                }), e
            }

            function _defineProperty(e, t, n) {
                return t in e ? Object.defineProperty(e, t, {
                    value: n,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0
                }) : e[t] = n, e
            }

            function EventDispatcher() {}

            function Texture(e = Texture.DEFAULT_IMAGE, t = Texture.DEFAULT_MAPPING, n = si, i = si, r = fi, a = vi, o = Oi, s = xi, l = 1, c = Hr) {
                Object.defineProperty(this, "id", {
                    value: Ra++
                }), this.uuid = Fa.generateUUID(), this.name = "", this.image = e, this.mipmaps = [], this.mapping = t, this.wrapS = n, this.wrapT = i, this.magFilter = r, this.minFilter = a, this.anisotropy = l, this.format = o, this.internalFormat = null, this.type = s, this.offset = new Vector2(0, 0), this.repeat = new Vector2(1, 1), this.center = new Vector2(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new Matrix3, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = c, this.version = 0, this.onUpdate = null
            }

            function serializeImage(e) {
                return "undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap ? Ba.getDataURL(e) : e.data ? {
                    data: Array.prototype.slice.call(e.data),
                    width: e.width,
                    height: e.height,
                    type: e.data.constructor.name
                } : {}
            }

            function WebGLRenderTarget(e, t, n) {
                this.width = e, this.height = t, this.scissor = new Vector4(0, 0, e, t), this.scissorTest = !1, this.viewport = new Vector4(0, 0, e, t), n = n || {}, this.texture = new Texture(void 0, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.encoding), this.texture.image = {}, this.texture.image.width = e, this.texture.image.height = t, this.texture.generateMipmaps = void 0 !== n.generateMipmaps && n.generateMipmaps, this.texture.minFilter = void 0 !== n.minFilter ? n.minFilter : fi, this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer, this.stencilBuffer = void 0 !== n.stencilBuffer && n.stencilBuffer, this.depthTexture = void 0 !== n.depthTexture ? n.depthTexture : null
            }

            function WebGLMultisampleRenderTarget(e, t, n) {
                WebGLRenderTarget.call(this, e, t, n), this.samples = 4
            }

            function satForAxes(e, t, n, i, r) {
                for (let a = 0, o = e.length - 3; a <= o; a += 3) {
                    Ja.fromArray(e, a);
                    const o = r.x * Math.abs(Ja.x) + r.y * Math.abs(Ja.y) + r.z * Math.abs(Ja.z),
                        s = t.dot(Ja),
                        l = n.dot(Ja),
                        c = i.dot(Ja);
                    if (Math.max(-Math.max(s, l, c), Math.min(s, l, c)) > o) return !1
                }
                return !0
            }

            function Object3D() {
                Object.defineProperty(this, "id", {
                    value: mo++
                }), this.uuid = Fa.generateUUID(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = Object3D.DefaultUp.clone();
                const e = new Vector3,
                    t = new Euler,
                    n = new Quaternion,
                    i = new Vector3(1, 1, 1);
                t._onChange((function onRotationChange() {
                    n.setFromEuler(t, !1)
                })), n._onChange((function onQuaternionChange() {
                    t.setFromQuaternion(n, void 0, !1)
                })), Object.defineProperties(this, {
                    position: {
                        configurable: !0,
                        enumerable: !0,
                        value: e
                    },
                    rotation: {
                        configurable: !0,
                        enumerable: !0,
                        value: t
                    },
                    quaternion: {
                        configurable: !0,
                        enumerable: !0,
                        value: n
                    },
                    scale: {
                        configurable: !0,
                        enumerable: !0,
                        value: i
                    },
                    modelViewMatrix: {
                        value: new Matrix4
                    },
                    normalMatrix: {
                        value: new Matrix3
                    }
                }), this.matrix = new Matrix4, this.matrixWorld = new Matrix4, this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new Layers, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {}
            }

            function hue2rgb(e, t, n) {
                return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? e + 6 * (t - e) * n : n < .5 ? t : n < 2 / 3 ? e + 6 * (t - e) * (2 / 3 - n) : e
            }

            function SRGBToLinear(e) {
                return e < .04045 ? .0773993808 * e : Math.pow(.9478672986 * e + .0521327014, 2.4)
            }

            function LinearToSRGB(e) {
                return e < .0031308 ? 12.92 * e : 1.055 * Math.pow(e, .41666) - .055
            }

            function Material() {
                Object.defineProperty(this, "id", {
                    value: Wo++
                }), this.uuid = Fa.generateUUID(), this.name = "", this.type = "Material", this.fog = !0, this.blending = mn, this.side = cn, this.flatShading = !1, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.blendSrc = Pn, this.blendDst = En, this.blendEquation = _n, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = Un, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = ya, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = ra, this.stencilZFail = ra, this.stencilZPass = ra, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaTest = 0, this.premultipliedAlpha = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0
            }

            function MeshBasicMaterial(e) {
                Material.call(this), this.type = "MeshBasicMaterial", this.color = new Color(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = Wn, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.setValues(e)
            }

            function BufferAttribute(e, t, n) {
                if (Array.isArray(e)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
                this.name = "", this.array = e, this.itemSize = t, this.count = void 0 !== e ? e.length / t : 0, this.normalized = !0 === n, this.usage = xa, this.updateRange = {
                    offset: 0,
                    count: -1
                }, this.version = 0
            }

            function Int8BufferAttribute(e, t, n) {
                BufferAttribute.call(this, new Int8Array(e), t, n)
            }

            function Uint8BufferAttribute(e, t, n) {
                BufferAttribute.call(this, new Uint8Array(e), t, n)
            }

            function Uint8ClampedBufferAttribute(e, t, n) {
                BufferAttribute.call(this, new Uint8ClampedArray(e), t, n)
            }

            function Int16BufferAttribute(e, t, n) {
                BufferAttribute.call(this, new Int16Array(e), t, n)
            }

            function Uint16BufferAttribute(e, t, n) {
                BufferAttribute.call(this, new Uint16Array(e), t, n)
            }

            function Int32BufferAttribute(e, t, n) {
                BufferAttribute.call(this, new Int32Array(e), t, n)
            }

            function Uint32BufferAttribute(e, t, n) {
                BufferAttribute.call(this, new Uint32Array(e), t, n)
            }

            function Float16BufferAttribute(e, t, n) {
                BufferAttribute.call(this, new Uint16Array(e), t, n)
            }

            function Float32BufferAttribute(e, t, n) {
                BufferAttribute.call(this, new Float32Array(e), t, n)
            }

            function Float64BufferAttribute(e, t, n) {
                BufferAttribute.call(this, new Float64Array(e), t, n)
            }

            function arrayMax(e) {
                if (0 === e.length) return -1 / 0;
                let t = e[0];
                for (let n = 1, i = e.length; n < i; ++n) e[n] > t && (t = e[n]);
                return t
            }

            function getTypedArray(e, t) {
                return new Yo[e](t)
            }

            function BufferGeometry() {
                Object.defineProperty(this, "id", {
                    value: qo += 2
                }), this.uuid = Fa.generateUUID(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
                    start: 0,
                    count: 1 / 0
                }, this.userData = {}
            }

            function Mesh(e = new BufferGeometry, t = new MeshBasicMaterial) {
                Object3D.call(this), this.type = "Mesh", this.geometry = e, this.material = t, this.updateMorphTargets()
            }

            function checkIntersection(e, t, n, i, r, a, o, s) {
                let l;
                if (l = t.side === un ? i.intersectTriangle(o, a, r, !0, s) : i.intersectTriangle(r, a, o, t.side !== hn, s), null === l) return null;
                vs.copy(s), vs.applyMatrix4(e.matrixWorld);
                const c = n.ray.origin.distanceTo(vs);
                return c < n.near || c > n.far ? null : {
                    distance: c,
                    point: vs.clone(),
                    object: e
                }
            }

            function checkBufferGeometryIntersection(e, t, n, i, r, a, o, s, l, c, u, h) {
                rs.fromBufferAttribute(r, c), as.fromBufferAttribute(r, u), os.fromBufferAttribute(r, h);
                const d = e.morphTargetInfluences;
                if (t.morphTargets && a && d) {
                    us.set(0, 0, 0), hs.set(0, 0, 0), ds.set(0, 0, 0);
                    for (let e = 0, t = a.length; e < t; e++) {
                        const t = d[e],
                            n = a[e];
                        0 !== t && (ss.fromBufferAttribute(n, c), ls.fromBufferAttribute(n, u), cs.fromBufferAttribute(n, h), o ? (us.addScaledVector(ss, t), hs.addScaledVector(ls, t), ds.addScaledVector(cs, t)) : (us.addScaledVector(ss.sub(rs), t), hs.addScaledVector(ls.sub(as), t), ds.addScaledVector(cs.sub(os), t)))
                    }
                    rs.add(us), as.add(hs), os.add(ds)
                }
                e.isSkinnedMesh && (e.boneTransform(c, rs), e.boneTransform(u, as), e.boneTransform(h, os));
                const p = checkIntersection(e, t, n, i, rs, as, os, gs);
                if (p) {
                    s && (ps.fromBufferAttribute(s, c), fs.fromBufferAttribute(s, u), ms.fromBufferAttribute(s, h), p.uv = Triangle.getUV(gs, rs, as, os, ps, fs, ms, new Vector2)), l && (ps.fromBufferAttribute(l, c), fs.fromBufferAttribute(l, u), ms.fromBufferAttribute(l, h), p.uv2 = Triangle.getUV(gs, rs, as, os, ps, fs, ms, new Vector2));
                    const e = new Face3(c, u, h);
                    Triangle.getNormal(rs, as, os, e.normal), p.face = e
                }
                return p
            }

            function cloneUniforms(e) {
                const t = {};
                for (const n in e) {
                    t[n] = {};
                    for (const i in e[n]) {
                        const r = e[n][i];
                        r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture) ? t[n][i] = r.clone() : t[n][i] = Array.isArray(r) ? r.slice() : r
                    }
                }
                return t
            }

            function mergeUniforms(e) {
                const t = {};
                for (let n = 0; n < e.length; n++) {
                    const i = cloneUniforms(e[n]);
                    for (const e in i) t[e] = i[e]
                }
                return t
            }

            function ShaderMaterial(e) {
                Material.call(this), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = n, this.fragmentShader = i, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.extensions = {
                    derivatives: !1,
                    fragDepth: !1,
                    drawBuffers: !1,
                    shaderTextureLOD: !1
                }, this.defaultAttributeValues = {
                    color: [1, 1, 1],
                    uv: [0, 0],
                    uv2: [0, 0]
                }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, void 0 !== e && (e.attributes, this.setValues(e))
            }

            function Camera() {
                Object3D.call(this), this.type = "Camera", this.matrixWorldInverse = new Matrix4, this.projectionMatrix = new Matrix4, this.projectionMatrixInverse = new Matrix4
            }

            function PerspectiveCamera(e = 50, t = 1, n = .1, i = 2e3) {
                Camera.call(this), this.type = "PerspectiveCamera", this.fov = e, this.zoom = 1, this.near = n, this.far = i, this.focus = 10, this.aspect = t, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix()
            }

            function CubeCamera(e, t, n) {
                if (Object3D.call(this), this.type = "CubeCamera", !0 !== n.isWebGLCubeRenderTarget) return;
                this.renderTarget = n;
                const i = new PerspectiveCamera(xs, 1, e, t);
                i.layers = this.layers, i.up.set(0, -1, 0), i.lookAt(new Vector3(1, 0, 0)), this.add(i);
                const r = new PerspectiveCamera(xs, 1, e, t);
                r.layers = this.layers, r.up.set(0, -1, 0), r.lookAt(new Vector3(-1, 0, 0)), this.add(r);
                const a = new PerspectiveCamera(xs, 1, e, t);
                a.layers = this.layers, a.up.set(0, 0, 1), a.lookAt(new Vector3(0, 1, 0)), this.add(a);
                const o = new PerspectiveCamera(xs, 1, e, t);
                o.layers = this.layers, o.up.set(0, 0, -1), o.lookAt(new Vector3(0, -1, 0)), this.add(o);
                const s = new PerspectiveCamera(xs, 1, e, t);
                s.layers = this.layers, s.up.set(0, -1, 0), s.lookAt(new Vector3(0, 0, 1)), this.add(s);
                const l = new PerspectiveCamera(xs, 1, e, t);
                l.layers = this.layers, l.up.set(0, -1, 0), l.lookAt(new Vector3(0, 0, -1)), this.add(l), this.update = function(e, t) {
                    null === this.parent && this.updateMatrixWorld();
                    const c = e.xr.enabled,
                        u = e.getRenderTarget();
                    e.xr.enabled = !1;
                    const h = n.texture.generateMipmaps;
                    n.texture.generateMipmaps = !1, e.setRenderTarget(n, 0), e.render(t, i), e.setRenderTarget(n, 1), e.render(t, r), e.setRenderTarget(n, 2), e.render(t, a), e.setRenderTarget(n, 3), e.render(t, o), e.setRenderTarget(n, 4), e.render(t, s), n.texture.generateMipmaps = h, e.setRenderTarget(n, 5), e.render(t, l), e.setRenderTarget(u), e.xr.enabled = c
                }
            }

            function CubeTexture(e, t, n, i, r, a, o, s, l, c) {
                e = void 0 !== e ? e : [], t = void 0 !== t ? t : ei, o = void 0 !== o ? o : Fi, Texture.call(this, e, t, n, i, r, a, o, s, l, c), this.flipY = !1, this._needsFlipEnvMap = !0
            }

            function WebGLCubeRenderTarget(e, t, n) {
                Number.isInteger(t) && (t = n), WebGLRenderTarget.call(this, e, e, t), t = t || {}, this.texture = new CubeTexture(void 0, t.mapping, t.wrapS, t.wrapT, t.magFilter, t.minFilter, t.format, t.type, t.anisotropy, t.encoding), this.texture._needsFlipEnvMap = !1
            }

            function DataTexture(e, t, n, i, r, a, o, s, l, c, u, h) {
                Texture.call(this, null, a, o, s, l, c, i, r, u, h), this.image = {
                    data: e || null,
                    width: t || 1,
                    height: n || 1
                }, this.magFilter = void 0 !== l ? l : ci, this.minFilter = void 0 !== c ? c : ci, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.needsUpdate = !0
            }

            function WebGLAnimation() {
                function onAnimationFrame(t, r) {
                    n(t, r), i = e.requestAnimationFrame(onAnimationFrame)
                }
                let e = null,
                    t = !1,
                    n = null,
                    i = null;
                return {
                    start: function() {
                        !0 !== t && null !== n && (i = e.requestAnimationFrame(onAnimationFrame), t = !0)
                    },
                    stop: function() {
                        e.cancelAnimationFrame(i), t = !1
                    },
                    setAnimationLoop: function(e) {
                        n = e
                    },
                    setContext: function(t) {
                        e = t
                    }
                }
            }

            function WebGLAttributes(e, t) {
                const n = t.isWebGL2,
                    i = new WeakMap;
                return {
                    get: function get(e) {
                        return e.isInterleavedBufferAttribute && (e = e.data), i.get(e)
                    },
                    remove: function remove(t) {
                        t.isInterleavedBufferAttribute && (t = t.data);
                        const n = i.get(t);
                        n && (e.deleteBuffer(n.buffer), i.delete(t))
                    },
                    update: function update(t, r) {
                        if (t.isGLBufferAttribute) {
                            const e = i.get(t);
                            return void((!e || e.version < t.version) && i.set(t, {
                                buffer: t.buffer,
                                type: t.type,
                                bytesPerElement: t.elementSize,
                                version: t.version
                            }))
                        }
                        t.isInterleavedBufferAttribute && (t = t.data);
                        const a = i.get(t);
                        void 0 === a ? i.set(t, function createBuffer(t, i) {
                            const r = t.array,
                                a = t.usage,
                                o = e.createBuffer();
                            e.bindBuffer(i, o), e.bufferData(i, r, a), t.onUploadCallback();
                            let s = 5126;
                            return r instanceof Float32Array ? s = 5126 : r instanceof Float64Array || (r instanceof Uint16Array ? t.isFloat16BufferAttribute ? n && (s = 5131) : s = 5123 : r instanceof Int16Array ? s = 5122 : r instanceof Uint32Array ? s = 5125 : r instanceof Int32Array ? s = 5124 : r instanceof Int8Array ? s = 5120 : r instanceof Uint8Array && (s = 5121)), {
                                buffer: o,
                                type: s,
                                bytesPerElement: r.BYTES_PER_ELEMENT,
                                version: t.version
                            }
                        }(t, r)) : a.version < t.version && (! function updateBuffer(t, i, r) {
                            const a = i.array,
                                o = i.updateRange;
                            e.bindBuffer(r, t), -1 === o.count ? e.bufferSubData(r, 0, a) : (n ? e.bufferSubData(r, o.offset * a.BYTES_PER_ELEMENT, a, o.offset, o.count) : e.bufferSubData(r, o.offset * a.BYTES_PER_ELEMENT, a.subarray(o.offset, o.offset + o.count)), o.count = -1)
                        }(a.buffer, t, r), a.version = t.version)
                    }
                }
            }

            function WebGLBackground(e, t, n, i, r) {
                function setClear(e, t) {
                    n.buffers.color.setClear(e.r, e.g, e.b, t, r)
                }
                const a = new Color(0);
                let o, s, l = 0,
                    c = null,
                    u = 0,
                    h = null;
                return {
                    getClearColor: function() {
                        return a
                    },
                    setClearColor: function(e, t = 1) {
                        a.set(e), l = t, setClear(a, l)
                    },
                    getClearAlpha: function() {
                        return l
                    },
                    setClearAlpha: function(e) {
                        l = e, setClear(a, l)
                    },
                    render: function render(n, r, d, p) {
                        let f = !0 === r.isScene ? r.background : null;
                        f && f.isTexture && (f = t.get(f));
                        const m = e.xr,
                            g = m.getSession && m.getSession();
                        g && "additive" === g.environmentBlendMode && (f = null), null === f ? setClear(a, l) : f && f.isColor && (setClear(f, 1), p = !0), (e.autoClear || p) && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), f && (f.isCubeTexture || f.isWebGLCubeRenderTarget || f.mapping === ri) ? (void 0 === s && (s = new Mesh(new BoxBufferGeometry(1, 1, 1), new ShaderMaterial({
                            name: "BackgroundCubeMaterial",
                            uniforms: cloneUniforms(As.cube.uniforms),
                            vertexShader: As.cube.vertexShader,
                            fragmentShader: As.cube.fragmentShader,
                            side: un,
                            depthTest: !1,
                            depthWrite: !1,
                            fog: !1
                        })), s.geometry.deleteAttribute("normal"), s.geometry.deleteAttribute("uv"), s.onBeforeRender = function(e, t, n) {
                            this.matrixWorld.copyPosition(n.matrixWorld)
                        }, Object.defineProperty(s.material, "envMap", {
                            get: function() {
                                return this.uniforms.envMap.value
                            }
                        }), i.update(s)), f.isWebGLCubeRenderTarget && (f = f.texture), s.material.uniforms.envMap.value = f, s.material.uniforms.flipEnvMap.value = f.isCubeTexture && f._needsFlipEnvMap ? -1 : 1, c === f && u === f.version && h === e.toneMapping || (s.material.needsUpdate = !0, c = f, u = f.version, h = e.toneMapping), n.unshift(s, s.geometry, s.material, 0, 0, null)) : f && f.isTexture && (void 0 === o && (o = new Mesh(new PlaneBufferGeometry(2, 2), new ShaderMaterial({
                            name: "BackgroundMaterial",
                            uniforms: cloneUniforms(As.background.uniforms),
                            vertexShader: As.background.vertexShader,
                            fragmentShader: As.background.fragmentShader,
                            side: cn,
                            depthTest: !1,
                            depthWrite: !1,
                            fog: !1
                        })), o.geometry.deleteAttribute("normal"), Object.defineProperty(o.material, "map", {
                            get: function() {
                                return this.uniforms.t2D.value
                            }
                        }), i.update(o)), o.material.uniforms.t2D.value = f, !0 === f.matrixAutoUpdate && f.updateMatrix(), o.material.uniforms.uvTransform.value.copy(f.matrix), c === f && u === f.version && h === e.toneMapping || (o.material.needsUpdate = !0, c = f, u = f.version, h = e.toneMapping), n.unshift(o, o.geometry, o.material, 0, 0, null))
                    }
                }
            }

            function WebGLBindingStates(e, t, n, i) {
                function bindVertexArrayObject(t) {
                    return i.isWebGL2 ? e.bindVertexArray(t) : a.bindVertexArrayOES(t)
                }

                function deleteVertexArrayObject(t) {
                    return i.isWebGL2 ? e.deleteVertexArray(t) : a.deleteVertexArrayOES(t)
                }

                function createBindingState(e) {
                    const t = [],
                        n = [],
                        i = [];
                    for (let e = 0; e < r; e++) t[e] = 0, n[e] = 0, i[e] = 0;
                    return {
                        geometry: null,
                        program: null,
                        wireframe: !1,
                        newAttributes: t,
                        enabledAttributes: n,
                        attributeDivisors: i,
                        object: e,
                        attributes: {},
                        index: null
                    }
                }

                function initAttributes() {
                    const e = c.newAttributes;
                    for (let t = 0, n = e.length; t < n; t++) e[t] = 0
                }

                function enableAttribute(e) {
                    enableAttributeAndDivisor(e, 0)
                }

                function enableAttributeAndDivisor(n, r) {
                    const a = c.newAttributes,
                        o = c.enabledAttributes,
                        s = c.attributeDivisors;
                    if (a[n] = 1, 0 === o[n] && (e.enableVertexAttribArray(n), o[n] = 1), s[n] !== r) {
                        (i.isWebGL2 ? e : t.get("ANGLE_instanced_arrays"))[i.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](n, r), s[n] = r
                    }
                }

                function disableUnusedAttributes() {
                    const t = c.newAttributes,
                        n = c.enabledAttributes;
                    for (let i = 0, r = n.length; i < r; i++) n[i] !== t[i] && (e.disableVertexAttribArray(i), n[i] = 0)
                }

                function vertexAttribPointer(t, n, r, a, o, s) {
                    !0 !== i.isWebGL2 || 5124 !== r && 5125 !== r ? e.vertexAttribPointer(t, n, r, a, o, s) : e.vertexAttribIPointer(t, n, r, o, s)
                }

                function reset() {
                    resetDefaultState(), c !== l && (c = l, bindVertexArrayObject(c.object))
                }

                function resetDefaultState() {
                    l.geometry = null, l.program = null, l.wireframe = !1
                }
                const r = e.getParameter(34921),
                    a = i.isWebGL2 ? null : t.get("OES_vertex_array_object"),
                    o = i.isWebGL2 || null !== a,
                    s = {},
                    l = createBindingState(null);
                let c = l;
                return {
                    setup: function setup(r, l, u, h, d) {
                        let p = !1;
                        if (o) {
                            const t = function getBindingState(t, n, r) {
                                const o = !0 === r.wireframe;
                                let l = s[t.id];
                                void 0 === l && (l = {}, s[t.id] = l);
                                let c = l[n.id];
                                void 0 === c && (c = {}, l[n.id] = c);
                                let u = c[o];
                                void 0 === u && (u = createBindingState(function createVertexArrayObject() {
                                    return i.isWebGL2 ? e.createVertexArray() : a.createVertexArrayOES()
                                }()), c[o] = u);
                                return u
                            }(h, u, l);
                            c !== t && (c = t, bindVertexArrayObject(c.object)), p = function needsUpdate(e, t) {
                                const n = c.attributes,
                                    i = e.attributes;
                                let r = 0;
                                for (const e in i) {
                                    const t = n[e],
                                        a = i[e];
                                    if (void 0 === t) return !0;
                                    if (t.attribute !== a) return !0;
                                    if (t.data !== a.data) return !0;
                                    r++
                                }
                                return c.attributesNum !== r || c.index !== t
                            }(h, d), p && function saveCache(e, t) {
                                const n = {},
                                    i = e.attributes;
                                let r = 0;
                                for (const e in i) {
                                    const t = i[e],
                                        a = {};
                                    a.attribute = t, t.data && (a.data = t.data), n[e] = a, r++
                                }
                                c.attributes = n, c.attributesNum = r, c.index = t
                            }(h, d)
                        } else {
                            const e = !0 === l.wireframe;
                            c.geometry === h.id && c.program === u.id && c.wireframe === e || (c.geometry = h.id, c.program = u.id, c.wireframe = e, p = !0)
                        }!0 === r.isInstancedMesh && (p = !0), null !== d && n.update(d, 34963), p && (! function setupVertexAttributes(r, a, o, s) {
                            if (!1 === i.isWebGL2 && (r.isInstancedMesh || s.isInstancedBufferGeometry) && null === t.get("ANGLE_instanced_arrays")) return;
                            initAttributes();
                            const l = s.attributes,
                                c = o.getAttributes(),
                                u = a.defaultAttributeValues;
                            for (const t in c) {
                                const i = c[t];
                                if (i >= 0) {
                                    const a = l[t];
                                    if (void 0 !== a) {
                                        const t = a.normalized,
                                            r = a.itemSize,
                                            o = n.get(a);
                                        if (void 0 === o) continue;
                                        const l = o.buffer,
                                            c = o.type,
                                            u = o.bytesPerElement;
                                        if (a.isInterleavedBufferAttribute) {
                                            const n = a.data,
                                                o = n.stride,
                                                h = a.offset;
                                            n && n.isInstancedInterleavedBuffer ? (enableAttributeAndDivisor(i, n.meshPerAttribute), void 0 === s._maxInstanceCount && (s._maxInstanceCount = n.meshPerAttribute * n.count)) : enableAttribute(i), e.bindBuffer(34962, l), vertexAttribPointer(i, r, c, t, o * u, h * u)
                                        } else a.isInstancedBufferAttribute ? (enableAttributeAndDivisor(i, a.meshPerAttribute), void 0 === s._maxInstanceCount && (s._maxInstanceCount = a.meshPerAttribute * a.count)) : enableAttribute(i), e.bindBuffer(34962, l), vertexAttribPointer(i, r, c, t, 0, 0)
                                    } else if ("instanceMatrix" === t) {
                                        const t = n.get(r.instanceMatrix);
                                        if (void 0 === t) continue;
                                        const a = t.buffer,
                                            o = t.type;
                                        enableAttributeAndDivisor(i + 0, 1), enableAttributeAndDivisor(i + 1, 1), enableAttributeAndDivisor(i + 2, 1), enableAttributeAndDivisor(i + 3, 1), e.bindBuffer(34962, a), e.vertexAttribPointer(i + 0, 4, o, !1, 64, 0), e.vertexAttribPointer(i + 1, 4, o, !1, 64, 16), e.vertexAttribPointer(i + 2, 4, o, !1, 64, 32), e.vertexAttribPointer(i + 3, 4, o, !1, 64, 48)
                                    } else if ("instanceColor" === t) {
                                        const t = n.get(r.instanceColor);
                                        if (void 0 === t) continue;
                                        const a = t.buffer,
                                            o = t.type;
                                        enableAttributeAndDivisor(i, 1), e.bindBuffer(34962, a), e.vertexAttribPointer(i, 3, o, !1, 12, 0)
                                    } else if (void 0 !== u) {
                                        const n = u[t];
                                        if (void 0 !== n) switch (n.length) {
                                            case 2:
                                                e.vertexAttrib2fv(i, n);
                                                break;
                                            case 3:
                                                e.vertexAttrib3fv(i, n);
                                                break;
                                            case 4:
                                                e.vertexAttrib4fv(i, n);
                                                break;
                                            default:
                                                e.vertexAttrib1fv(i, n)
                                        }
                                    }
                                }
                            }
                            disableUnusedAttributes()
                        }(r, l, u, h), null !== d && e.bindBuffer(34963, n.get(d).buffer))
                    },
                    reset,
                    resetDefaultState,
                    dispose: function dispose() {
                        reset();
                        for (const e in s) {
                            const t = s[e];
                            for (const e in t) {
                                const n = t[e];
                                for (const e in n) deleteVertexArrayObject(n[e].object), delete n[e];
                                delete t[e]
                            }
                            delete s[e]
                        }
                    },
                    releaseStatesOfGeometry: function releaseStatesOfGeometry(e) {
                        if (void 0 === s[e.id]) return;
                        const t = s[e.id];
                        for (const e in t) {
                            const n = t[e];
                            for (const e in n) deleteVertexArrayObject(n[e].object), delete n[e];
                            delete t[e]
                        }
                        delete s[e.id]
                    },
                    releaseStatesOfProgram: function releaseStatesOfProgram(e) {
                        for (const t in s) {
                            const n = s[t];
                            if (void 0 === n[e.id]) continue;
                            const i = n[e.id];
                            for (const e in i) deleteVertexArrayObject(i[e].object), delete i[e];
                            delete n[e.id]
                        }
                    },
                    initAttributes,
                    enableAttribute,
                    disableUnusedAttributes
                }
            }

            function WebGLBufferRenderer(e, t, n, i) {
                const r = i.isWebGL2;
                let a;
                this.setMode = function setMode(e) {
                    a = e
                }, this.render = function render(t, i) {
                    e.drawArrays(a, t, i), n.update(i, a, 1)
                }, this.renderInstances = function renderInstances(i, o, s) {
                    if (0 === s) return;
                    let l, c;
                    if (r) l = e, c = "drawArraysInstanced";
                    else if (l = t.get("ANGLE_instanced_arrays"), c = "drawArraysInstancedANGLE", null === l) return;
                    l[c](a, i, o, s), n.update(o, a, s)
                }
            }

            function WebGLCapabilities(e, t, n) {
                function getMaxPrecision(t) {
                    if ("highp" === t) {
                        if (e.getShaderPrecisionFormat(35633, 36338).precision > 0 && e.getShaderPrecisionFormat(35632, 36338).precision > 0) return "highp";
                        t = "mediump"
                    }
                    return "mediump" === t && e.getShaderPrecisionFormat(35633, 36337).precision > 0 && e.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp"
                }
                let i;
                const r = "undefined" != typeof WebGL2RenderingContext && e instanceof WebGL2RenderingContext || "undefined" != typeof WebGL2ComputeRenderingContext && e instanceof WebGL2ComputeRenderingContext;
                let a = void 0 !== n.precision ? n.precision : "highp";
                const o = getMaxPrecision(a);
                o !== a && (a = o);
                const s = !0 === n.logarithmicDepthBuffer,
                    l = e.getParameter(34930),
                    c = e.getParameter(35660),
                    u = e.getParameter(3379),
                    h = e.getParameter(34076),
                    d = e.getParameter(34921),
                    p = e.getParameter(36347),
                    f = e.getParameter(36348),
                    m = e.getParameter(36349),
                    g = c > 0,
                    y = r || !!t.get("OES_texture_float");
                return {
                    isWebGL2: r,
                    getMaxAnisotropy: function getMaxAnisotropy() {
                        if (void 0 !== i) return i;
                        const n = t.get("EXT_texture_filter_anisotropic");
                        return i = null !== n ? e.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0, i
                    },
                    getMaxPrecision,
                    precision: a,
                    logarithmicDepthBuffer: s,
                    maxTextures: l,
                    maxVertexTextures: c,
                    maxTextureSize: u,
                    maxCubemapSize: h,
                    maxAttributes: d,
                    maxVertexUniforms: p,
                    maxVaryings: f,
                    maxFragmentUniforms: m,
                    vertexTextures: g,
                    floatFragmentTextures: y,
                    floatVertexTextures: g && y,
                    maxSamples: r ? e.getParameter(36183) : 0
                }
            }

            function WebGLClipping(e) {
                function resetGlobalState() {
                    l.value !== n && (l.value = n, l.needsUpdate = i > 0), t.numPlanes = i, t.numIntersection = 0
                }

                function projectPlanes(e, n, i, r) {
                    const a = null !== e ? e.length : 0;
                    let c = null;
                    if (0 !== a) {
                        if (c = l.value, !0 !== r || null === c) {
                            const t = i + 4 * a,
                                r = n.matrixWorldInverse;
                            s.getNormalMatrix(r), (null === c || c.length < t) && (c = new Float32Array(t));
                            for (let t = 0, n = i; t !== a; ++t, n += 4) o.copy(e[t]).applyMatrix4(r, s), o.normal.toArray(c, n), c[n + 3] = o.constant
                        }
                        l.value = c, l.needsUpdate = !0
                    }
                    return t.numPlanes = a, t.numIntersection = 0, c
                }
                const t = this;
                let n = null,
                    i = 0,
                    r = !1,
                    a = !1;
                const o = new Plane,
                    s = new Matrix3,
                    l = {
                        value: null,
                        needsUpdate: !1
                    };
                this.uniform = l, this.numPlanes = 0, this.numIntersection = 0, this.init = function(e, t, a) {
                    const o = 0 !== e.length || t || 0 !== i || r;
                    return r = t, n = projectPlanes(e, a, 0), i = e.length, o
                }, this.beginShadows = function() {
                    a = !0, projectPlanes(null)
                }, this.endShadows = function() {
                    a = !1, resetGlobalState()
                }, this.setState = function(t, o, s) {
                    const c = t.clippingPlanes,
                        u = t.clipIntersection,
                        h = t.clipShadows,
                        d = e.get(t);
                    if (!r || null === c || 0 === c.length || a && !h) a ? projectPlanes(null) : resetGlobalState();
                    else {
                        const e = a ? 0 : i,
                            t = 4 * e;
                        let r = d.clippingState || null;
                        l.value = r, r = projectPlanes(c, o, t, s);
                        for (let e = 0; e !== t; ++e) r[e] = n[e];
                        d.clippingState = r, this.numIntersection = u ? this.numPlanes : 0, this.numPlanes += e
                    }
                }
            }

            function WebGLCubeMaps(e) {
                function mapTextureMapping(e, t) {
                    return t === ni ? e.mapping = ei : t === ii && (e.mapping = ti), e
                }

                function onTextureDispose(e) {
                    const n = e.target;
                    n.removeEventListener("dispose", onTextureDispose);
                    const i = t.get(n);
                    void 0 !== i && (t.delete(n), i.dispose())
                }
                let t = new WeakMap;
                return {
                    get: function get(n) {
                        if (n && n.isTexture) {
                            const i = n.mapping;
                            if (i === ni || i === ii) {
                                if (t.has(n)) {
                                    return mapTextureMapping(t.get(n).texture, n.mapping)
                                } {
                                    const i = n.image;
                                    if (i && i.height > 0) {
                                        const r = e.getRenderList(),
                                            a = e.getRenderTarget(),
                                            o = new WebGLCubeRenderTarget(i.height / 2);
                                        return o.fromEquirectangularTexture(e, n), t.set(n, o), e.setRenderTarget(a), e.setRenderList(r), n.addEventListener("dispose", onTextureDispose), mapTextureMapping(o.texture, n.mapping)
                                    }
                                    return null
                                }
                            }
                        }
                        return n
                    },
                    dispose: function dispose() {
                        t = new WeakMap
                    }
                }
            }

            function WebGLExtensions(e) {
                const t = {};
                return {
                    has: function(n) {
                        if (void 0 !== t[n]) return null !== t[n];
                        let i;
                        switch (n) {
                            case "WEBGL_depth_texture":
                                i = e.getExtension("WEBGL_depth_texture") || e.getExtension("MOZ_WEBGL_depth_texture") || e.getExtension("WEBKIT_WEBGL_depth_texture");
                                break;
                            case "EXT_texture_filter_anisotropic":
                                i = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                                break;
                            case "WEBGL_compressed_texture_s3tc":
                                i = e.getExtension("WEBGL_compressed_texture_s3tc") || e.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                                break;
                            case "WEBGL_compressed_texture_pvrtc":
                                i = e.getExtension("WEBGL_compressed_texture_pvrtc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                                break;
                            default:
                                i = e.getExtension(n)
                        }
                        return t[n] = i, null !== i
                    },
                    get: function(e) {
                        return this.has(e), t[e]
                    }
                }
            }

            function WebGLGeometries(e, t, n, i) {
                function onGeometryDispose(e) {
                    const o = e.target,
                        s = r.get(o);
                    null !== s.index && t.remove(s.index);
                    for (const e in s.attributes) t.remove(s.attributes[e]);
                    o.removeEventListener("dispose", onGeometryDispose), r.delete(o);
                    const l = a.get(s);
                    l && (t.remove(l), a.delete(s)), i.releaseStatesOfGeometry(s), !0 === o.isInstancedBufferGeometry && delete o._maxInstanceCount, n.memory.geometries--
                }

                function updateWireframeAttribute(e) {
                    const n = [],
                        i = e.index,
                        r = e.attributes.position;
                    let o = 0;
                    if (null !== i) {
                        const e = i.array;
                        o = i.version;
                        for (let t = 0, i = e.length; t < i; t += 3) {
                            const i = e[t + 0],
                                r = e[t + 1],
                                a = e[t + 2];
                            n.push(i, r, r, a, a, i)
                        }
                    } else {
                        const e = r.array;
                        o = r.version;
                        for (let t = 0, i = e.length / 3 - 1; t < i; t += 3) {
                            const e = t + 0,
                                i = t + 1,
                                r = t + 2;
                            n.push(e, i, i, r, r, e)
                        }
                    }
                    const s = new(arrayMax(n) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(n, 1);
                    s.version = o;
                    const l = a.get(e);
                    l && t.remove(l), a.set(e, s)
                }
                const r = new WeakMap,
                    a = new WeakMap;
                return {
                    get: function get(e, t) {
                        let i = r.get(t);
                        return i || (t.addEventListener("dispose", onGeometryDispose), t.isBufferGeometry ? i = t : t.isGeometry && (void 0 === t._bufferGeometry && (t._bufferGeometry = (new BufferGeometry).setFromObject(e)), i = t._bufferGeometry), r.set(t, i), n.memory.geometries++, i)
                    },
                    update: function update(e) {
                        const n = e.attributes;
                        for (const e in n) t.update(n[e], 34962);
                        const i = e.morphAttributes;
                        for (const e in i) {
                            const n = i[e];
                            for (let e = 0, i = n.length; e < i; e++) t.update(n[e], 34962)
                        }
                    },
                    getWireframeAttribute: function getWireframeAttribute(e) {
                        const t = a.get(e);
                        if (t) {
                            const n = e.index;
                            null !== n && t.version < n.version && updateWireframeAttribute(e)
                        } else updateWireframeAttribute(e);
                        return a.get(e)
                    }
                }
            }

            function WebGLIndexedBufferRenderer(e, t, n, i) {
                const r = i.isWebGL2;
                let a, o, s;
                this.setMode = function setMode(e) {
                    a = e
                }, this.setIndex = function setIndex(e) {
                    o = e.type, s = e.bytesPerElement
                }, this.render = function render(t, i) {
                    e.drawElements(a, i, o, t * s), n.update(i, a, 1)
                }, this.renderInstances = function renderInstances(i, l, c) {
                    if (0 === c) return;
                    let u, h;
                    if (r) u = e, h = "drawElementsInstanced";
                    else if (u = t.get("ANGLE_instanced_arrays"), h = "drawElementsInstancedANGLE", null === u) return;
                    u[h](a, l, o, i * s, c), n.update(l, a, c)
                }
            }

            function WebGLInfo(e) {
                const t = {
                    frame: 0,
                    calls: 0,
                    triangles: 0,
                    points: 0,
                    lines: 0
                };
                return {
                    memory: {
                        geometries: 0,
                        textures: 0
                    },
                    render: t,
                    programs: null,
                    autoReset: !0,
                    reset: function reset() {
                        t.frame++, t.calls = 0, t.triangles = 0, t.points = 0, t.lines = 0
                    },
                    update: function update(e, n, i) {
                        switch (t.calls++, n) {
                            case 4:
                                t.triangles += i * (e / 3);
                                break;
                            case 1:
                                t.lines += i * (e / 2);
                                break;
                            case 3:
                                t.lines += i * (e - 1);
                                break;
                            case 2:
                                t.lines += i * e;
                                break;
                            case 0:
                                t.points += i * e
                        }
                    }
                }
            }

            function numericalSort(e, t) {
                return e[0] - t[0]
            }

            function absNumericalSort(e, t) {
                return Math.abs(t[1]) - Math.abs(e[1])
            }

            function WebGLMorphtargets(e) {
                const t = {},
                    n = new Float32Array(8),
                    i = [];
                for (let e = 0; e < 8; e++) i[e] = [e, 0];
                return {
                    update: function update(r, a, o, s) {
                        const l = r.morphTargetInfluences,
                            c = void 0 === l ? 0 : l.length;
                        let u = t[a.id];
                        if (void 0 === u) {
                            u = [];
                            for (let e = 0; e < c; e++) u[e] = [e, 0];
                            t[a.id] = u
                        }
                        for (let e = 0; e < c; e++) {
                            const t = u[e];
                            t[0] = e, t[1] = l[e]
                        }
                        u.sort(absNumericalSort);
                        for (let e = 0; e < 8; e++) e < c && u[e][1] ? (i[e][0] = u[e][0], i[e][1] = u[e][1]) : (i[e][0] = Number.MAX_SAFE_INTEGER, i[e][1] = 0);
                        i.sort(numericalSort);
                        const h = o.morphTargets && a.morphAttributes.position,
                            d = o.morphNormals && a.morphAttributes.normal;
                        let p = 0;
                        for (let e = 0; e < 8; e++) {
                            const t = i[e],
                                r = t[0],
                                o = t[1];
                            r !== Number.MAX_SAFE_INTEGER && o ? (h && a.getAttribute("morphTarget" + e) !== h[r] && a.setAttribute("morphTarget" + e, h[r]), d && a.getAttribute("morphNormal" + e) !== d[r] && a.setAttribute("morphNormal" + e, d[r]), n[e] = o, p += o) : (h && !0 === a.hasAttribute("morphTarget" + e) && a.deleteAttribute("morphTarget" + e), d && !0 === a.hasAttribute("morphNormal" + e) && a.deleteAttribute("morphNormal" + e), n[e] = 0)
                        }
                        const f = a.morphTargetsRelative ? 1 : 1 - p;
                        s.getUniforms().setValue(e, "morphTargetBaseInfluence", f), s.getUniforms().setValue(e, "morphTargetInfluences", n)
                    }
                }
            }

            function WebGLObjects(e, t, n, i) {
                function onInstancedMeshDispose(e) {
                    const t = e.target;
                    t.removeEventListener("dispose", onInstancedMeshDispose), n.remove(t.instanceMatrix), null !== t.instanceColor && n.remove(t.instanceColor)
                }
                let r = new WeakMap;
                return {
                    update: function update(e) {
                        const a = i.render.frame,
                            o = e.geometry,
                            s = t.get(e, o);
                        return r.get(s) !== a && (o.isGeometry && s.updateFromObject(e), t.update(s), r.set(s, a)), e.isInstancedMesh && (!1 === e.hasEventListener("dispose", onInstancedMeshDispose) && e.addEventListener("dispose", onInstancedMeshDispose), n.update(e.instanceMatrix, 34962), null !== e.instanceColor && n.update(e.instanceColor, 34962)), s
                    },
                    dispose: function dispose() {
                        r = new WeakMap
                    }
                }
            }

            function DataTexture2DArray(e = null, t = 1, n = 1, i = 1) {
                Texture.call(this, null), this.image = {
                    data: e,
                    width: t,
                    height: n,
                    depth: i
                }, this.magFilter = ci, this.minFilter = ci, this.wrapR = si, this.generateMipmaps = !1, this.flipY = !1, this.needsUpdate = !0
            }

            function DataTexture3D(e = null, t = 1, n = 1, i = 1) {
                Texture.call(this, null), this.image = {
                    data: e,
                    width: t,
                    height: n,
                    depth: i
                }, this.magFilter = ci, this.minFilter = ci, this.wrapR = si, this.generateMipmaps = !1, this.flipY = !1, this.needsUpdate = !0
            }

            function flatten(e, t, n) {
                const i = e[0];
                if (i <= 0 || i > 0) return e;
                const r = t * n;
                let a = Ps[r];
                if (void 0 === a && (a = new Float32Array(r), Ps[r] = a), 0 !== t) {
                    i.toArray(a, 0);
                    for (let i = 1, r = 0; i !== t; ++i) r += n, e[i].toArray(a, r)
                }
                return a
            }

            function arraysEqual(e, t) {
                if (e.length !== t.length) return !1;
                for (let n = 0, i = e.length; n < i; n++)
                    if (e[n] !== t[n]) return !1;
                return !0
            }

            function copyArray(e, t) {
                for (let n = 0, i = t.length; n < i; n++) e[n] = t[n]
            }

            function allocTexUnits(e, t) {
                let n = Es[t];
                void 0 === n && (n = new Int32Array(t), Es[t] = n);
                for (let i = 0; i !== t; ++i) n[i] = e.allocateTextureUnit();
                return n
            }

            function setValueV1f(e, t) {
                const n = this.cache;
                n[0] !== t && (e.uniform1f(this.addr, t), n[0] = t)
            }

            function setValueV2f(e, t) {
                const n = this.cache;
                if (void 0 !== t.x) n[0] === t.x && n[1] === t.y || (e.uniform2f(this.addr, t.x, t.y), n[0] = t.x, n[1] = t.y);
                else {
                    if (arraysEqual(n, t)) return;
                    e.uniform2fv(this.addr, t), copyArray(n, t)
                }
            }

            function setValueV3f(e, t) {
                const n = this.cache;
                if (void 0 !== t.x) n[0] === t.x && n[1] === t.y && n[2] === t.z || (e.uniform3f(this.addr, t.x, t.y, t.z), n[0] = t.x, n[1] = t.y, n[2] = t.z);
                else if (void 0 !== t.r) n[0] === t.r && n[1] === t.g && n[2] === t.b || (e.uniform3f(this.addr, t.r, t.g, t.b), n[0] = t.r, n[1] = t.g, n[2] = t.b);
                else {
                    if (arraysEqual(n, t)) return;
                    e.uniform3fv(this.addr, t), copyArray(n, t)
                }
            }

            function setValueV4f(e, t) {
                const n = this.cache;
                if (void 0 !== t.x) n[0] === t.x && n[1] === t.y && n[2] === t.z && n[3] === t.w || (e.uniform4f(this.addr, t.x, t.y, t.z, t.w), n[0] = t.x, n[1] = t.y, n[2] = t.z, n[3] = t.w);
                else {
                    if (arraysEqual(n, t)) return;
                    e.uniform4fv(this.addr, t), copyArray(n, t)
                }
            }

            function setValueM2(e, t) {
                const n = this.cache,
                    i = t.elements;
                if (void 0 === i) {
                    if (arraysEqual(n, t)) return;
                    e.uniformMatrix2fv(this.addr, !1, t), copyArray(n, t)
                } else {
                    if (arraysEqual(n, i)) return;
                    Os.set(i), e.uniformMatrix2fv(this.addr, !1, Os), copyArray(n, i)
                }
            }

            function setValueM3(e, t) {
                const n = this.cache,
                    i = t.elements;
                if (void 0 === i) {
                    if (arraysEqual(n, t)) return;
                    e.uniformMatrix3fv(this.addr, !1, t), copyArray(n, t)
                } else {
                    if (arraysEqual(n, i)) return;
                    Fs.set(i), e.uniformMatrix3fv(this.addr, !1, Fs), copyArray(n, i)
                }
            }

            function setValueM4(e, t) {
                const n = this.cache,
                    i = t.elements;
                if (void 0 === i) {
                    if (arraysEqual(n, t)) return;
                    e.uniformMatrix4fv(this.addr, !1, t), copyArray(n, t)
                } else {
                    if (arraysEqual(n, i)) return;
                    Is.set(i), e.uniformMatrix4fv(this.addr, !1, Is), copyArray(n, i)
                }
            }

            function setValueT1(e, t, n) {
                const i = this.cache,
                    r = n.allocateTextureUnit();
                i[0] !== r && (e.uniform1i(this.addr, r), i[0] = r), n.safeSetTexture2D(t || ws, r)
            }

            function setValueT2DArray1(e, t, n) {
                const i = this.cache,
                    r = n.allocateTextureUnit();
                i[0] !== r && (e.uniform1i(this.addr, r), i[0] = r), n.setTexture2DArray(t || Ts, r)
            }

            function setValueT3D1(e, t, n) {
                const i = this.cache,
                    r = n.allocateTextureUnit();
                i[0] !== r && (e.uniform1i(this.addr, r), i[0] = r), n.setTexture3D(t || Ls, r)
            }

            function setValueT6(e, t, n) {
                const i = this.cache,
                    r = n.allocateTextureUnit();
                i[0] !== r && (e.uniform1i(this.addr, r), i[0] = r), n.safeSetTextureCube(t || Cs, r)
            }

            function setValueV1i(e, t) {
                const n = this.cache;
                n[0] !== t && (e.uniform1i(this.addr, t), n[0] = t)
            }

            function setValueV2i(e, t) {
                const n = this.cache;
                arraysEqual(n, t) || (e.uniform2iv(this.addr, t), copyArray(n, t))
            }

            function setValueV3i(e, t) {
                const n = this.cache;
                arraysEqual(n, t) || (e.uniform3iv(this.addr, t), copyArray(n, t))
            }

            function setValueV4i(e, t) {
                const n = this.cache;
                arraysEqual(n, t) || (e.uniform4iv(this.addr, t), copyArray(n, t))
            }

            function setValueV1ui(e, t) {
                const n = this.cache;
                n[0] !== t && (e.uniform1ui(this.addr, t), n[0] = t)
            }

            function setValueV1fArray(e, t) {
                e.uniform1fv(this.addr, t)
            }

            function setValueV1iArray(e, t) {
                e.uniform1iv(this.addr, t)
            }

            function setValueV2iArray(e, t) {
                e.uniform2iv(this.addr, t)
            }

            function setValueV3iArray(e, t) {
                e.uniform3iv(this.addr, t)
            }

            function setValueV4iArray(e, t) {
                e.uniform4iv(this.addr, t)
            }

            function setValueV2fArray(e, t) {
                const n = flatten(t, this.size, 2);
                e.uniform2fv(this.addr, n)
            }

            function setValueV3fArray(e, t) {
                const n = flatten(t, this.size, 3);
                e.uniform3fv(this.addr, n)
            }

            function setValueV4fArray(e, t) {
                const n = flatten(t, this.size, 4);
                e.uniform4fv(this.addr, n)
            }

            function setValueM2Array(e, t) {
                const n = flatten(t, this.size, 4);
                e.uniformMatrix2fv(this.addr, !1, n)
            }

            function setValueM3Array(e, t) {
                const n = flatten(t, this.size, 9);
                e.uniformMatrix3fv(this.addr, !1, n)
            }

            function setValueM4Array(e, t) {
                const n = flatten(t, this.size, 16);
                e.uniformMatrix4fv(this.addr, !1, n)
            }

            function setValueT1Array(e, t, n) {
                const i = t.length,
                    r = allocTexUnits(n, i);
                e.uniform1iv(this.addr, r);
                for (let e = 0; e !== i; ++e) n.safeSetTexture2D(t[e] || ws, r[e])
            }

            function setValueT6Array(e, t, n) {
                const i = t.length,
                    r = allocTexUnits(n, i);
                e.uniform1iv(this.addr, r);
                for (let e = 0; e !== i; ++e) n.safeSetTextureCube(t[e] || Cs, r[e])
            }

            function SingleUniform(e, t, n) {
                this.id = e, this.addr = n, this.cache = [], this.setValue = function getSingularSetter(e) {
                    switch (e) {
                        case 5126:
                            return setValueV1f;
                        case 35664:
                            return setValueV2f;
                        case 35665:
                            return setValueV3f;
                        case 35666:
                            return setValueV4f;
                        case 35674:
                            return setValueM2;
                        case 35675:
                            return setValueM3;
                        case 35676:
                            return setValueM4;
                        case 5124:
                        case 35670:
                            return setValueV1i;
                        case 35667:
                        case 35671:
                            return setValueV2i;
                        case 35668:
                        case 35672:
                            return setValueV3i;
                        case 35669:
                        case 35673:
                            return setValueV4i;
                        case 5125:
                            return setValueV1ui;
                        case 35678:
                        case 36198:
                        case 36298:
                        case 36306:
                        case 35682:
                            return setValueT1;
                        case 35679:
                        case 36299:
                        case 36307:
                            return setValueT3D1;
                        case 35680:
                        case 36300:
                        case 36308:
                        case 36293:
                            return setValueT6;
                        case 36289:
                        case 36303:
                        case 36311:
                        case 36292:
                            return setValueT2DArray1
                    }
                }(t.type)
            }

            function PureArrayUniform(e, t, n) {
                this.id = e, this.addr = n, this.cache = [], this.size = t.size, this.setValue = function getPureArraySetter(e) {
                    switch (e) {
                        case 5126:
                            return setValueV1fArray;
                        case 35664:
                            return setValueV2fArray;
                        case 35665:
                            return setValueV3fArray;
                        case 35666:
                            return setValueV4fArray;
                        case 35674:
                            return setValueM2Array;
                        case 35675:
                            return setValueM3Array;
                        case 35676:
                            return setValueM4Array;
                        case 5124:
                        case 35670:
                            return setValueV1iArray;
                        case 35667:
                        case 35671:
                            return setValueV2iArray;
                        case 35668:
                        case 35672:
                            return setValueV3iArray;
                        case 35669:
                        case 35673:
                            return setValueV4iArray;
                        case 35678:
                        case 36198:
                        case 36298:
                        case 36306:
                        case 35682:
                            return setValueT1Array;
                        case 35680:
                        case 36300:
                        case 36308:
                        case 36293:
                            return setValueT6Array
                    }
                }(t.type)
            }

            function StructuredUniform(e) {
                this.id = e, this.seq = [], this.map = {}
            }

            function addUniform(e, t) {
                e.seq.push(t), e.map[t.id] = t
            }

            function parseUniform(e, t, n) {
                const i = e.name,
                    r = i.length;
                for (Bs.lastIndex = 0;;) {
                    const a = Bs.exec(i),
                        o = Bs.lastIndex;
                    let s = a[1];
                    const l = "]" === a[2],
                        c = a[3];
                    if (l && (s |= 0), void 0 === c || "[" === c && o + 2 === r) {
                        addUniform(n, void 0 === c ? new SingleUniform(s, e, t) : new PureArrayUniform(s, e, t));
                        break
                    } {
                        let e = n.map[s];
                        void 0 === e && (e = new StructuredUniform(s), addUniform(n, e)), n = e
                    }
                }
            }

            function WebGLUniforms(e, t) {
                this.seq = [], this.map = {};
                const n = e.getProgramParameter(t, 35718);
                for (let i = 0; i < n; ++i) {
                    const n = e.getActiveUniform(t, i);
                    parseUniform(n, e.getUniformLocation(t, n.name), this)
                }
            }

            function WebGLShader(e, t, n) {
                const i = e.createShader(t);
                return e.shaderSource(i, n), e.compileShader(i), i
            }

            function getEncodingComponents(e) {
                switch (e) {
                    case Hr:
                        return ["Linear", "( value )"];
                    case Xr:
                        return ["sRGB", "( value )"];
                    case qr:
                        return ["RGBE", "( value )"];
                    case Jr:
                        return ["RGBM", "( value, 7.0 )"];
                    case Zr:
                        return ["RGBM", "( value, 16.0 )"];
                    case Kr:
                        return ["RGBD", "( value, 256.0 )"];
                    case Yr:
                        return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
                    case Qr:
                        return ["LogLuv", "( value )"];
                    default:
                        return ["Linear", "( value )"]
                }
            }

            function getShaderErrors(e, t, n) {
                const i = e.getShaderParameter(t, 35713),
                    r = e.getShaderInfoLog(t).trim();
                if (i && "" === r) return "";
                return "THREE.WebGLShader: gl.getShaderInfoLog() " + n + "\n" + r + function addLineNumbers(e) {
                    const t = e.split("\n");
                    for (let e = 0; e < t.length; e++) t[e] = e + 1 + ": " + t[e];
                    return t.join("\n")
                }(e.getShaderSource(t))
            }

            function getTexelDecodingFunction(e, t) {
                const n = getEncodingComponents(t);
                return "vec4 " + e + "( vec4 value ) { return " + n[0] + "ToLinear" + n[1] + "; }"
            }

            function getTexelEncodingFunction(e, t) {
                const n = getEncodingComponents(t);
                return "vec4 " + e + "( vec4 value ) { return LinearTo" + n[0] + n[1] + "; }"
            }

            function getToneMappingFunction(e, t) {
                let n;
                switch (t) {
                    case qn:
                        n = "Linear";
                        break;
                    case Qn:
                        n = "Reinhard";
                        break;
                    case Jn:
                        n = "OptimizedCineon";
                        break;
                    case Zn:
                        n = "ACESFilmic";
                        break;
                    case Kn:
                        n = "Custom";
                        break;
                    default:
                        n = "Linear"
                }
                return "vec3 " + e + "( vec3 color ) { return " + n + "ToneMapping( color ); }"
            }

            function filterEmptyLine(e) {
                return "" !== e
            }

            function replaceLightNums(e, t) {
                return e.replace(/NUM_DIR_LIGHTS/g, t.numDirLights).replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, t.numPointLights).replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, t.numPointLightShadows)
            }

            function replaceClippingPlaneNums(e, t) {
                return e.replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, t.numClippingPlanes - t.numClipIntersection)
            }

            function resolveIncludes(e) {
                return e.replace(Ns, includeReplacer)
            }

            function includeReplacer(e, t) {
                const n = Ms[t];
                if (void 0 === n) throw Error("Can not resolve #include <" + t + ">");
                return resolveIncludes(n)
            }

            function unrollLoops(e) {
                return e.replace(Vs, loopReplacer).replace(Ds, deprecatedLoopReplacer)
            }

            function deprecatedLoopReplacer(e, t, n, i) {
                return loopReplacer(e, t, n, i)
            }

            function loopReplacer(e, t, n, i) {
                let r = "";
                for (let e = parseInt(t); e < parseInt(n); e++) r += i.replace(/\[\s*i\s*\]/g, "[ " + e + " ]").replace(/UNROLLED_LOOP_INDEX/g, e);
                return r
            }

            function generatePrecision(e) {
                let t = "precision " + e.precision + " float;\nprecision " + e.precision + " int;";
                return "highp" === e.precision ? t += "\n#define HIGH_PRECISION" : "mediump" === e.precision ? t += "\n#define MEDIUM_PRECISION" : "lowp" === e.precision && (t += "\n#define LOW_PRECISION"), t
            }

            function WebGLProgram(e, t, n, i) {
                const r = e.getContext(),
                    a = n.defines;
                let o = n.vertexShader,
                    s = n.fragmentShader;
                const l = function generateShadowMapTypeDefine(e) {
                        let t = "SHADOWMAP_TYPE_BASIC";
                        return e.shadowMapType === on ? t = "SHADOWMAP_TYPE_PCF" : e.shadowMapType === sn ? t = "SHADOWMAP_TYPE_PCF_SOFT" : e.shadowMapType === ln && (t = "SHADOWMAP_TYPE_VSM"), t
                    }(n),
                    c = function generateEnvMapTypeDefine(e) {
                        let t = "ENVMAP_TYPE_CUBE";
                        if (e.envMap) switch (e.envMapMode) {
                            case ei:
                            case ti:
                                t = "ENVMAP_TYPE_CUBE";
                                break;
                            case ri:
                            case ai:
                                t = "ENVMAP_TYPE_CUBE_UV"
                        }
                        return t
                    }(n),
                    u = function generateEnvMapModeDefine(e) {
                        let t = "ENVMAP_MODE_REFLECTION";
                        if (e.envMap) switch (e.envMapMode) {
                            case ti:
                            case ai:
                                t = "ENVMAP_MODE_REFRACTION"
                        }
                        return t
                    }(n),
                    h = function generateEnvMapBlendingDefine(e) {
                        let t = "ENVMAP_BLENDING_NONE";
                        if (e.envMap) switch (e.combine) {
                            case Wn:
                                t = "ENVMAP_BLENDING_MULTIPLY";
                                break;
                            case Hn:
                                t = "ENVMAP_BLENDING_MIX";
                                break;
                            case Xn:
                                t = "ENVMAP_BLENDING_ADD"
                        }
                        return t
                    }(n),
                    d = e.gammaFactor > 0 ? e.gammaFactor : 1,
                    p = n.isWebGL2 ? "" : function generateExtensions(e) {
                        return [e.extensionDerivatives || e.envMapCubeUV || e.bumpMap || e.tangentSpaceNormalMap || e.clearcoatNormalMap || e.flatShading || "physical" === e.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (e.extensionFragDepth || e.logarithmicDepthBuffer) && e.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", e.extensionDrawBuffers && e.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (e.extensionShaderTextureLOD || e.envMap) && e.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(filterEmptyLine).join("\n")
                    }(n),
                    f = function generateDefines(e) {
                        const t = [];
                        for (const n in e) {
                            const i = e[n];
                            !1 !== i && t.push("#define " + n + " " + i)
                        }
                        return t.join("\n")
                    }(a),
                    m = r.createProgram();
                let g, y, x = n.glslVersion ? "#version " + n.glslVersion + "\n" : "";
                n.isRawShaderMaterial ? (g = [f].filter(filterEmptyLine).join("\n"), g.length > 0 && (g += "\n"), y = [p, f].filter(filterEmptyLine).join("\n"), y.length > 0 && (y += "\n")) : (g = [generatePrecision(n), "#define SHADER_NAME " + n.shaderName, f, n.instancing ? "#define USE_INSTANCING" : "", n.instancingColor ? "#define USE_INSTANCING_COLOR" : "", n.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + d, "#define MAX_BONES " + n.maxBones, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + u : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.displacementMap && n.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.skinning ? "#define USE_SKINNING" : "", n.useVertexTexture ? "#define BONE_TEXTURE" : "", n.morphTargets ? "#define USE_MORPHTARGETS" : "", n.morphNormals && !1 === n.flatShading ? "#define USE_MORPHNORMALS" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + l : "", n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "\tattribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "\tattribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#ifdef USE_COLOR", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(filterEmptyLine).join("\n"), y = [p, generatePrecision(n), "#define SHADER_NAME " + n.shaderName, f, n.alphaTest ? "#define ALPHATEST " + n.alphaTest + (n.alphaTest % 1 ? "" : ".0") : "", "#define GAMMA_FACTOR " + d, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.matcap ? "#define USE_MATCAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + c : "", n.envMap ? "#define " + u : "", n.envMap ? "#define " + h : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.sheen ? "#define USE_SHEEN" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors || n.instancingColor ? "#define USE_COLOR" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.gradientMap ? "#define USE_GRADIENTMAP" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + l : "", n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", n.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", (n.extensionShaderTextureLOD || n.envMap) && n.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", n.toneMapping !== Yn ? "#define TONE_MAPPING" : "", n.toneMapping !== Yn ? Ms.tonemapping_pars_fragment : "", n.toneMapping !== Yn ? getToneMappingFunction("toneMapping", n.toneMapping) : "", n.dithering ? "#define DITHERING" : "", Ms.encodings_pars_fragment, n.map ? getTexelDecodingFunction("mapTexelToLinear", n.mapEncoding) : "", n.matcap ? getTexelDecodingFunction("matcapTexelToLinear", n.matcapEncoding) : "", n.envMap ? getTexelDecodingFunction("envMapTexelToLinear", n.envMapEncoding) : "", n.emissiveMap ? getTexelDecodingFunction("emissiveMapTexelToLinear", n.emissiveMapEncoding) : "", n.lightMap ? getTexelDecodingFunction("lightMapTexelToLinear", n.lightMapEncoding) : "", getTexelEncodingFunction("linearToOutputTexel", n.outputEncoding), n.depthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n"].filter(filterEmptyLine).join("\n")), o = resolveIncludes(o), o = replaceLightNums(o, n), o = replaceClippingPlaneNums(o, n), s = resolveIncludes(s), s = replaceLightNums(s, n), s = replaceClippingPlaneNums(s, n), o = unrollLoops(o), s = unrollLoops(s), n.isWebGL2 && !0 !== n.isRawShaderMaterial && (x = "#version 300 es\n", g = "#define attribute in\n#define varying out\n#define texture2D texture\n" + g, y = ["#define varying in", n.glslVersion === Pa ? "" : "out highp vec4 pc_fragColor;", n.glslVersion === Pa ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth\n#define texture2D texture\n#define textureCube texture\n#define texture2DProj textureProj\n#define texture2DLodEXT textureLod\n#define texture2DProjLodEXT textureProjLod\n#define textureCubeLodEXT textureLod\n#define texture2DGradEXT textureGrad\n#define texture2DProjGradEXT textureProjGrad\n#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + y);
                const _ = x + y + s,
                    b = WebGLShader(r, 35633, x + g + o),
                    M = WebGLShader(r, 35632, _);
                if (r.attachShader(m, b), r.attachShader(m, M), void 0 !== n.index0AttributeName ? r.bindAttribLocation(m, 0, n.index0AttributeName) : !0 === n.morphTargets && r.bindAttribLocation(m, 0, "position"), r.linkProgram(m), e.debug.checkShaderErrors) {
                    const e = r.getProgramInfoLog(m).trim(),
                        t = r.getShaderInfoLog(b).trim(),
                        n = r.getShaderInfoLog(M).trim();
                    let i = !0,
                        a = !0;
                    if (!1 === r.getProgramParameter(m, 35714)) {
                        i = !1;
                        getShaderErrors(r, b, "vertex"), getShaderErrors(r, M, "fragment")
                    } else "" !== e || "" !== t && "" !== n || (a = !1);
                    a && (this.diagnostics = {
                        runnable: i,
                        programLog: e,
                        vertexShader: {
                            log: t,
                            prefix: g
                        },
                        fragmentShader: {
                            log: n,
                            prefix: y
                        }
                    })
                }
                let S, A;
                return r.deleteShader(b), r.deleteShader(M), this.getUniforms = function() {
                    return void 0 === S && (S = new WebGLUniforms(r, m)), S
                }, this.getAttributes = function() {
                    return void 0 === A && (A = function fetchAttributeLocations(e, t) {
                        const n = {},
                            i = e.getProgramParameter(t, 35721);
                        for (let r = 0; r < i; r++) {
                            const i = e.getActiveAttrib(t, r).name;
                            n[i] = e.getAttribLocation(t, i)
                        }
                        return n
                    }(r, m)), A
                }, this.destroy = function() {
                    i.releaseStatesOfProgram(this), r.deleteProgram(m), this.program = void 0
                }, this.name = n.shaderName, this.id = Rs++, this.cacheKey = t, this.usedTimes = 1, this.program = m, this.vertexShader = b, this.fragmentShader = M, this
            }

            function WebGLPrograms(e, t, n, i, r, a) {
                function getTextureEncodingFromMap(e) {
                    let t;
                    return t = e && e.isTexture ? e.encoding : e && e.isWebGLRenderTarget ? e.texture.encoding : Hr, t
                }
                const o = [],
                    s = i.isWebGL2,
                    l = i.logarithmicDepthBuffer,
                    c = i.floatVertexTextures,
                    u = i.maxVertexUniforms,
                    h = i.vertexTextures;
                let d = i.precision;
                const p = {
                        MeshDepthMaterial: "depth",
                        MeshDistanceMaterial: "distanceRGBA",
                        MeshNormalMaterial: "normal",
                        MeshBasicMaterial: "basic",
                        MeshLambertMaterial: "lambert",
                        MeshPhongMaterial: "phong",
                        MeshToonMaterial: "toon",
                        MeshStandardMaterial: "physical",
                        MeshPhysicalMaterial: "physical",
                        MeshMatcapMaterial: "matcap",
                        LineBasicMaterial: "basic",
                        LineDashedMaterial: "dashed",
                        PointsMaterial: "points",
                        ShadowMaterial: "shadow",
                        SpriteMaterial: "sprite"
                    },
                    f = ["precision", "isWebGL2", "supportsVertexTextures", "outputEncoding", "instancing", "instancingColor", "map", "mapEncoding", "matcap", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding", "envMapCubeUV", "lightMap", "lightMapEncoding", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "tangentSpaceNormalMap", "clearcoatMap", "clearcoatRoughnessMap", "clearcoatNormalMap", "displacementMap", "specularMap", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "combine", "vertexColors", "vertexTangents", "vertexUvs", "uvsVertexOnly", "fog", "useFog", "fogExp2", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "maxMorphTargets", "maxMorphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "numDirLightShadows", "numPointLightShadows", "numSpotLightShadows", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering", "sheen", "transmissionMap"];
                return {
                    getParameters: function getParameters(r, o, f, m, g) {
                        const y = m.fog,
                            x = r.isMeshStandardMaterial ? m.environment : null,
                            _ = t.get(r.envMap || x),
                            b = p[r.type],
                            M = g.isSkinnedMesh ? function getMaxBones(e) {
                                const t = e.skeleton.bones;
                                if (c) return 1024; {
                                    const e = Math.min(Math.floor((u - 20) / 4), t.length);
                                    return e < t.length ? 0 : e
                                }
                            }(g) : 0;
                        let S, A;
                        if (null !== r.precision && (d = i.getMaxPrecision(r.precision), r.precision), b) {
                            const e = As[b];
                            S = e.vertexShader, A = e.fragmentShader
                        } else S = r.vertexShader, A = r.fragmentShader;
                        const w = e.getRenderTarget();
                        return {
                            isWebGL2: s,
                            shaderID: b,
                            shaderName: r.type,
                            vertexShader: S,
                            fragmentShader: A,
                            defines: r.defines,
                            isRawShaderMaterial: !0 === r.isRawShaderMaterial,
                            glslVersion: r.glslVersion,
                            precision: d,
                            instancing: !0 === g.isInstancedMesh,
                            instancingColor: !0 === g.isInstancedMesh && null !== g.instanceColor,
                            supportsVertexTextures: h,
                            outputEncoding: null !== w ? getTextureEncodingFromMap(w.texture) : e.outputEncoding,
                            map: !!r.map,
                            mapEncoding: getTextureEncodingFromMap(r.map),
                            matcap: !!r.matcap,
                            matcapEncoding: getTextureEncodingFromMap(r.matcap),
                            envMap: !!_,
                            envMapMode: _ && _.mapping,
                            envMapEncoding: getTextureEncodingFromMap(_),
                            envMapCubeUV: !!_ && (_.mapping === ri || _.mapping === ai),
                            lightMap: !!r.lightMap,
                            lightMapEncoding: getTextureEncodingFromMap(r.lightMap),
                            aoMap: !!r.aoMap,
                            emissiveMap: !!r.emissiveMap,
                            emissiveMapEncoding: getTextureEncodingFromMap(r.emissiveMap),
                            bumpMap: !!r.bumpMap,
                            normalMap: !!r.normalMap,
                            objectSpaceNormalMap: r.normalMapType === na,
                            tangentSpaceNormalMap: r.normalMapType === ta,
                            clearcoatMap: !!r.clearcoatMap,
                            clearcoatRoughnessMap: !!r.clearcoatRoughnessMap,
                            clearcoatNormalMap: !!r.clearcoatNormalMap,
                            displacementMap: !!r.displacementMap,
                            roughnessMap: !!r.roughnessMap,
                            metalnessMap: !!r.metalnessMap,
                            specularMap: !!r.specularMap,
                            alphaMap: !!r.alphaMap,
                            gradientMap: !!r.gradientMap,
                            sheen: !!r.sheen,
                            transmissionMap: !!r.transmissionMap,
                            combine: r.combine,
                            vertexTangents: r.normalMap && r.vertexTangents,
                            vertexColors: r.vertexColors,
                            vertexUvs: !!(r.map || r.bumpMap || r.normalMap || r.specularMap || r.alphaMap || r.emissiveMap || r.roughnessMap || r.metalnessMap || r.clearcoatMap || r.clearcoatRoughnessMap || r.clearcoatNormalMap || r.displacementMap || r.transmissionMap),
                            uvsVertexOnly: !(r.map || r.bumpMap || r.normalMap || r.specularMap || r.alphaMap || r.emissiveMap || r.roughnessMap || r.metalnessMap || r.clearcoatNormalMap || r.transmissionMap || !r.displacementMap),
                            fog: !!y,
                            useFog: r.fog,
                            fogExp2: y && y.isFogExp2,
                            flatShading: r.flatShading,
                            sizeAttenuation: r.sizeAttenuation,
                            logarithmicDepthBuffer: l,
                            skinning: r.skinning && M > 0,
                            maxBones: M,
                            useVertexTexture: c,
                            morphTargets: r.morphTargets,
                            morphNormals: r.morphNormals,
                            maxMorphTargets: e.maxMorphTargets,
                            maxMorphNormals: e.maxMorphNormals,
                            numDirLights: o.directional.length,
                            numPointLights: o.point.length,
                            numSpotLights: o.spot.length,
                            numRectAreaLights: o.rectArea.length,
                            numHemiLights: o.hemi.length,
                            numDirLightShadows: o.directionalShadowMap.length,
                            numPointLightShadows: o.pointShadowMap.length,
                            numSpotLightShadows: o.spotShadowMap.length,
                            numClippingPlanes: a.numPlanes,
                            numClipIntersection: a.numIntersection,
                            dithering: r.dithering,
                            shadowMapEnabled: e.shadowMap.enabled && f.length > 0,
                            shadowMapType: e.shadowMap.type,
                            toneMapping: r.toneMapped ? e.toneMapping : Yn,
                            physicallyCorrectLights: e.physicallyCorrectLights,
                            premultipliedAlpha: r.premultipliedAlpha,
                            alphaTest: r.alphaTest,
                            doubleSided: r.side === hn,
                            flipSided: r.side === un,
                            depthPacking: void 0 !== r.depthPacking && r.depthPacking,
                            index0AttributeName: r.index0AttributeName,
                            extensionDerivatives: r.extensions && r.extensions.derivatives,
                            extensionFragDepth: r.extensions && r.extensions.fragDepth,
                            extensionDrawBuffers: r.extensions && r.extensions.drawBuffers,
                            extensionShaderTextureLOD: r.extensions && r.extensions.shaderTextureLOD,
                            rendererExtensionFragDepth: s || n.has("EXT_frag_depth"),
                            rendererExtensionDrawBuffers: s || n.has("WEBGL_draw_buffers"),
                            rendererExtensionShaderTextureLod: s || n.has("EXT_shader_texture_lod"),
                            customProgramCacheKey: r.customProgramCacheKey()
                        }
                    },
                    getProgramCacheKey: function getProgramCacheKey(t) {
                        const n = [];
                        if (t.shaderID ? n.push(t.shaderID) : (n.push(t.fragmentShader), n.push(t.vertexShader)), void 0 !== t.defines)
                            for (const e in t.defines) n.push(e), n.push(t.defines[e]);
                        if (!1 === t.isRawShaderMaterial) {
                            for (let e = 0; e < 72; e++) n.push(t[f[e]]);
                            n.push(e.outputEncoding), n.push(e.gammaFactor)
                        }
                        return n.push(t.customProgramCacheKey), n.join()
                    },
                    getUniforms: function getUniforms(e) {
                        const t = p[e.type];
                        let n;
                        if (t) {
                            const e = As[t];
                            n = ys.clone(e.uniforms)
                        } else n = e.uniforms;
                        return n
                    },
                    acquireProgram: function acquireProgram(t, n) {
                        let i;
                        for (let e = 0, t = o.length; e < t; e++) {
                            const t = o[e];
                            if (t.cacheKey === n) {
                                i = t, ++i.usedTimes;
                                break
                            }
                        }
                        return void 0 === i && (i = new WebGLProgram(e, n, t, r), o.push(i)), i
                    },
                    releaseProgram: function releaseProgram(e) {
                        if (0 == --e.usedTimes) {
                            const t = o.indexOf(e);
                            o[t] = o[o.length - 1], o.pop(), e.destroy()
                        }
                    },
                    programs: o
                }
            }

            function WebGLProperties() {
                let e = new WeakMap;
                return {
                    get: function get(t) {
                        let n = e.get(t);
                        return void 0 === n && (n = {}, e.set(t, n)), n
                    },
                    remove: function remove(t) {
                        e.delete(t)
                    },
                    update: function update(t, n, i) {
                        e.get(t)[n] = i
                    },
                    dispose: function dispose() {
                        e = new WeakMap
                    }
                }
            }

            function painterSortStable(e, t) {
                return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.program !== t.program ? e.program.id - t.program.id : e.material.id !== t.material.id ? e.material.id - t.material.id : e.z !== t.z ? e.z - t.z : e.id - t.id
            }

            function reversePainterSortStable(e, t) {
                return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.z !== t.z ? t.z - e.z : e.id - t.id
            }

            function WebGLRenderList(e) {
                function getNextRenderItem(i, r, o, s, l, c) {
                    let u = t[n];
                    const h = e.get(o);
                    return void 0 === u ? (u = {
                        id: i.id,
                        object: i,
                        geometry: r,
                        material: o,
                        program: h.program || a,
                        groupOrder: s,
                        renderOrder: i.renderOrder,
                        z: l,
                        group: c
                    }, t[n] = u) : (u.id = i.id, u.object = i, u.geometry = r, u.material = o, u.program = h.program || a, u.groupOrder = s, u.renderOrder = i.renderOrder, u.z = l, u.group = c), n++, u
                }
                const t = [];
                let n = 0;
                const i = [],
                    r = [],
                    a = {
                        id: -1
                    };
                return {
                    opaque: i,
                    transparent: r,
                    init: function init() {
                        n = 0, i.length = 0, r.length = 0
                    },
                    push: function push(e, t, n, a, o, s) {
                        const l = getNextRenderItem(e, t, n, a, o, s);
                        (!0 === n.transparent ? r : i).push(l)
                    },
                    unshift: function unshift(e, t, n, a, o, s) {
                        const l = getNextRenderItem(e, t, n, a, o, s);
                        (!0 === n.transparent ? r : i).unshift(l)
                    },
                    finish: function finish() {
                        for (let e = n, i = t.length; e < i; e++) {
                            const n = t[e];
                            if (null === n.id) break;
                            n.id = null, n.object = null, n.geometry = null, n.material = null, n.program = null, n.group = null
                        }
                    },
                    sort: function sort(e, t) {
                        i.length > 1 && i.sort(e || painterSortStable), r.length > 1 && r.sort(t || reversePainterSortStable)
                    }
                }
            }

            function WebGLRenderLists(e) {
                let t = new WeakMap;
                return {
                    get: function get(n, i) {
                        const r = t.get(n);
                        let a;
                        return void 0 === r ? (a = new WebGLRenderList(e), t.set(n, new WeakMap), t.get(n).set(i, a)) : (a = r.get(i), void 0 === a && (a = new WebGLRenderList(e), r.set(i, a))), a
                    },
                    dispose: function dispose() {
                        t = new WeakMap
                    }
                }
            }

            function UniformsCache() {
                const e = {};
                return {
                    get: function(t) {
                        if (void 0 !== e[t.id]) return e[t.id];
                        let n;
                        switch (t.type) {
                            case "DirectionalLight":
                                n = {
                                    direction: new Vector3,
                                    color: new Color
                                };
                                break;
                            case "SpotLight":
                                n = {
                                    position: new Vector3,
                                    direction: new Vector3,
                                    color: new Color,
                                    distance: 0,
                                    coneCos: 0,
                                    penumbraCos: 0,
                                    decay: 0
                                };
                                break;
                            case "PointLight":
                                n = {
                                    position: new Vector3,
                                    color: new Color,
                                    distance: 0,
                                    decay: 0
                                };
                                break;
                            case "HemisphereLight":
                                n = {
                                    direction: new Vector3,
                                    skyColor: new Color,
                                    groundColor: new Color
                                };
                                break;
                            case "RectAreaLight":
                                n = {
                                    color: new Color,
                                    position: new Vector3,
                                    halfWidth: new Vector3,
                                    halfHeight: new Vector3
                                }
                        }
                        return e[t.id] = n, n
                    }
                }
            }

            function shadowCastingLightsFirst(e, t) {
                return (t.castShadow ? 1 : 0) - (e.castShadow ? 1 : 0)
            }

            function WebGLLights(e, t) {
                const n = new UniformsCache,
                    i = function ShadowUniformsCache() {
                        const e = {};
                        return {
                            get: function(t) {
                                if (void 0 !== e[t.id]) return e[t.id];
                                let n;
                                switch (t.type) {
                                    case "DirectionalLight":
                                    case "SpotLight":
                                        n = {
                                            shadowBias: 0,
                                            shadowNormalBias: 0,
                                            shadowRadius: 1,
                                            shadowMapSize: new Vector2
                                        };
                                        break;
                                    case "PointLight":
                                        n = {
                                            shadowBias: 0,
                                            shadowNormalBias: 0,
                                            shadowRadius: 1,
                                            shadowMapSize: new Vector2,
                                            shadowCameraNear: 1,
                                            shadowCameraFar: 1e3
                                        }
                                }
                                return e[t.id] = n, n
                            }
                        }
                    }(),
                    r = {
                        version: 0,
                        hash: {
                            directionalLength: -1,
                            pointLength: -1,
                            spotLength: -1,
                            rectAreaLength: -1,
                            hemiLength: -1,
                            numDirectionalShadows: -1,
                            numPointShadows: -1,
                            numSpotShadows: -1
                        },
                        ambient: [0, 0, 0],
                        probe: [],
                        directional: [],
                        directionalShadow: [],
                        directionalShadowMap: [],
                        directionalShadowMatrix: [],
                        spot: [],
                        spotShadow: [],
                        spotShadowMap: [],
                        spotShadowMatrix: [],
                        rectArea: [],
                        rectAreaLTC1: null,
                        rectAreaLTC2: null,
                        point: [],
                        pointShadow: [],
                        pointShadowMap: [],
                        pointShadowMatrix: [],
                        hemi: []
                    };
                for (let e = 0; e < 9; e++) r.probe.push(new Vector3);
                const a = new Vector3,
                    o = new Matrix4,
                    s = new Matrix4;
                return {
                    setup: function setup(a) {
                        let o = 0,
                            s = 0,
                            l = 0;
                        for (let e = 0; e < 9; e++) r.probe[e].set(0, 0, 0);
                        let c = 0,
                            u = 0,
                            h = 0,
                            d = 0,
                            p = 0,
                            f = 0,
                            m = 0,
                            g = 0;
                        a.sort(shadowCastingLightsFirst);
                        for (let e = 0, t = a.length; e < t; e++) {
                            const t = a[e],
                                y = t.color,
                                x = t.intensity,
                                _ = t.distance,
                                b = t.shadow && t.shadow.map ? t.shadow.map.texture : null;
                            if (t.isAmbientLight) o += y.r * x, s += y.g * x, l += y.b * x;
                            else if (t.isLightProbe)
                                for (let e = 0; e < 9; e++) r.probe[e].addScaledVector(t.sh.coefficients[e], x);
                            else if (t.isDirectionalLight) {
                                const e = n.get(t);
                                if (e.color.copy(t.color).multiplyScalar(t.intensity), t.castShadow) {
                                    const e = t.shadow,
                                        n = i.get(t);
                                    n.shadowBias = e.bias, n.shadowNormalBias = e.normalBias, n.shadowRadius = e.radius, n.shadowMapSize = e.mapSize, r.directionalShadow[c] = n, r.directionalShadowMap[c] = b, r.directionalShadowMatrix[c] = t.shadow.matrix, f++
                                }
                                r.directional[c] = e, c++
                            } else if (t.isSpotLight) {
                                const e = n.get(t);
                                if (e.position.setFromMatrixPosition(t.matrixWorld), e.color.copy(y).multiplyScalar(x), e.distance = _, e.coneCos = Math.cos(t.angle), e.penumbraCos = Math.cos(t.angle * (1 - t.penumbra)), e.decay = t.decay, t.castShadow) {
                                    const e = t.shadow,
                                        n = i.get(t);
                                    n.shadowBias = e.bias, n.shadowNormalBias = e.normalBias, n.shadowRadius = e.radius, n.shadowMapSize = e.mapSize, r.spotShadow[h] = n, r.spotShadowMap[h] = b, r.spotShadowMatrix[h] = t.shadow.matrix, g++
                                }
                                r.spot[h] = e, h++
                            } else if (t.isRectAreaLight) {
                                const e = n.get(t);
                                e.color.copy(y).multiplyScalar(x), e.halfWidth.set(.5 * t.width, 0, 0), e.halfHeight.set(0, .5 * t.height, 0), r.rectArea[d] = e, d++
                            } else if (t.isPointLight) {
                                const e = n.get(t);
                                if (e.color.copy(t.color).multiplyScalar(t.intensity), e.distance = t.distance, e.decay = t.decay, t.castShadow) {
                                    const e = t.shadow,
                                        n = i.get(t);
                                    n.shadowBias = e.bias, n.shadowNormalBias = e.normalBias, n.shadowRadius = e.radius, n.shadowMapSize = e.mapSize, n.shadowCameraNear = e.camera.near, n.shadowCameraFar = e.camera.far, r.pointShadow[u] = n, r.pointShadowMap[u] = b, r.pointShadowMatrix[u] = t.shadow.matrix, m++
                                }
                                r.point[u] = e, u++
                            } else if (t.isHemisphereLight) {
                                const e = n.get(t);
                                e.skyColor.copy(t.color).multiplyScalar(x), e.groundColor.copy(t.groundColor).multiplyScalar(x), r.hemi[p] = e, p++
                            }
                        }
                        d > 0 && (t.isWebGL2 || !0 === e.has("OES_texture_float_linear") ? (r.rectAreaLTC1 = Ss.LTC_FLOAT_1, r.rectAreaLTC2 = Ss.LTC_FLOAT_2) : !0 === e.has("OES_texture_half_float_linear") && (r.rectAreaLTC1 = Ss.LTC_HALF_1, r.rectAreaLTC2 = Ss.LTC_HALF_2)), r.ambient[0] = o, r.ambient[1] = s, r.ambient[2] = l;
                        const y = r.hash;
                        y.directionalLength === c && y.pointLength === u && y.spotLength === h && y.rectAreaLength === d && y.hemiLength === p && y.numDirectionalShadows === f && y.numPointShadows === m && y.numSpotShadows === g || (r.directional.length = c, r.spot.length = h, r.rectArea.length = d, r.point.length = u, r.hemi.length = p, r.directionalShadow.length = f, r.directionalShadowMap.length = f, r.pointShadow.length = m, r.pointShadowMap.length = m, r.spotShadow.length = g, r.spotShadowMap.length = g, r.directionalShadowMatrix.length = f, r.pointShadowMatrix.length = m, r.spotShadowMatrix.length = g, y.directionalLength = c, y.pointLength = u, y.spotLength = h, y.rectAreaLength = d, y.hemiLength = p, y.numDirectionalShadows = f, y.numPointShadows = m, y.numSpotShadows = g, r.version = Us++)
                    },
                    setupView: function setupView(e, t) {
                        let n = 0,
                            i = 0,
                            l = 0,
                            c = 0,
                            u = 0;
                        const h = t.matrixWorldInverse;
                        for (let t = 0, d = e.length; t < d; t++) {
                            const d = e[t];
                            if (d.isDirectionalLight) {
                                const e = r.directional[n];
                                e.direction.setFromMatrixPosition(d.matrixWorld), a.setFromMatrixPosition(d.target.matrixWorld), e.direction.sub(a), e.direction.transformDirection(h), n++
                            } else if (d.isSpotLight) {
                                const e = r.spot[l];
                                e.position.setFromMatrixPosition(d.matrixWorld), e.position.applyMatrix4(h), e.direction.setFromMatrixPosition(d.matrixWorld), a.setFromMatrixPosition(d.target.matrixWorld), e.direction.sub(a), e.direction.transformDirection(h), l++
                            } else if (d.isRectAreaLight) {
                                const e = r.rectArea[c];
                                e.position.setFromMatrixPosition(d.matrixWorld), e.position.applyMatrix4(h), s.identity(), o.copy(d.matrixWorld), o.premultiply(h), s.extractRotation(o), e.halfWidth.set(.5 * d.width, 0, 0), e.halfHeight.set(0, .5 * d.height, 0), e.halfWidth.applyMatrix4(s), e.halfHeight.applyMatrix4(s), c++
                            } else if (d.isPointLight) {
                                const e = r.point[i];
                                e.position.setFromMatrixPosition(d.matrixWorld), e.position.applyMatrix4(h), i++
                            } else if (d.isHemisphereLight) {
                                const e = r.hemi[u];
                                e.direction.setFromMatrixPosition(d.matrixWorld), e.direction.transformDirection(h), e.direction.normalize(), u++
                            }
                        }
                    },
                    state: r
                }
            }

            function WebGLRenderState(e, t) {
                const n = new WebGLLights(e, t),
                    i = [],
                    r = [];
                return {
                    init: function init() {
                        i.length = 0, r.length = 0
                    },
                    state: {
                        lightsArray: i,
                        shadowsArray: r,
                        lights: n
                    },
                    setupLights: function setupLights() {
                        n.setup(i)
                    },
                    setupLightsView: function setupLightsView(e) {
                        n.setupView(i, e)
                    },
                    pushLight: function pushLight(e) {
                        i.push(e)
                    },
                    pushShadow: function pushShadow(e) {
                        r.push(e)
                    }
                }
            }

            function WebGLRenderStates(e, t) {
                let n = new WeakMap;
                return {
                    get: function get(i, r = 0) {
                        let a;
                        return !1 === n.has(i) ? (a = new WebGLRenderState(e, t), n.set(i, []), n.get(i).push(a)) : r >= n.get(i).length ? (a = new WebGLRenderState(e, t), n.get(i).push(a)) : a = n.get(i)[r], a
                    },
                    dispose: function dispose() {
                        n = new WeakMap
                    }
                }
            }

            function MeshDepthMaterial(e) {
                Material.call(this), this.type = "MeshDepthMaterial", this.depthPacking = $r, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.setValues(e)
            }

            function MeshDistanceMaterial(e) {
                Material.call(this), this.type = "MeshDistanceMaterial", this.referencePosition = new Vector3, this.nearDistance = 1, this.farDistance = 1e3, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.fog = !1, this.setValues(e)
            }

            function WebGLShadowMap(e, t, n) {
                function VSMPass(n, i) {
                    const r = t.update(g);
                    p.uniforms.shadow_pass.value = n.map.texture, p.uniforms.resolution.value = n.mapSize, p.uniforms.radius.value = n.radius, e.setRenderTarget(n.mapPass), e.clear(), e.renderBufferDirect(i, null, r, p, g, null), f.uniforms.shadow_pass.value = n.mapPass.texture, f.uniforms.resolution.value = n.mapSize, f.uniforms.radius.value = n.radius, e.setRenderTarget(n.map), e.clear(), e.renderBufferDirect(i, null, r, f, g, null)
                }

                function getDepthMaterialVariant(e, t, n) {
                    const i = e << 0 | t << 1 | n << 2;
                    let r = c[i];
                    return void 0 === r && (r = new MeshDepthMaterial({
                        depthPacking: ea,
                        morphTargets: e,
                        skinning: t
                    }), c[i] = r), r
                }

                function getDistanceMaterialVariant(e, t, n) {
                    const i = e << 0 | t << 1 | n << 2;
                    let r = u[i];
                    return void 0 === r && (r = new MeshDistanceMaterial({
                        morphTargets: e,
                        skinning: t
                    }), u[i] = r), r
                }

                function getDepthMaterial(t, n, i, r, a, o, s) {
                    let l = null,
                        c = getDepthMaterialVariant,
                        u = t.customDepthMaterial;
                    if (!0 === r.isPointLight && (c = getDistanceMaterialVariant, u = t.customDistanceMaterial), void 0 === u) {
                        let e = !1;
                        !0 === i.morphTargets && (e = n.morphAttributes && n.morphAttributes.position && n.morphAttributes.position.length > 0);
                        let r = !1;
                        !0 === t.isSkinnedMesh && !0 === i.skinning && (r = !0);
                        l = c(e, r, !0 === t.isInstancedMesh)
                    } else l = u;
                    if (e.localClippingEnabled && !0 === i.clipShadows && 0 !== i.clippingPlanes.length) {
                        const e = l.uuid,
                            t = i.uuid;
                        let n = h[e];
                        void 0 === n && (n = {}, h[e] = n);
                        let r = n[t];
                        void 0 === r && (r = l.clone(), n[t] = r), l = r
                    }
                    return l.visible = i.visible, l.wireframe = i.wireframe, l.side = s === ln ? null !== i.shadowSide ? i.shadowSide : i.side : null !== i.shadowSide ? i.shadowSide : d[i.side], l.clipShadows = i.clipShadows, l.clippingPlanes = i.clippingPlanes, l.clipIntersection = i.clipIntersection, l.wireframeLinewidth = i.wireframeLinewidth, l.linewidth = i.linewidth, !0 === r.isPointLight && !0 === l.isMeshDistanceMaterial && (l.referencePosition.setFromMatrixPosition(r.matrixWorld), l.nearDistance = a, l.farDistance = o), l
                }

                function renderObject(n, r, a, o, s) {
                    if (!1 === n.visible) return;
                    if (n.layers.test(r.layers) && (n.isMesh || n.isLine || n.isPoints) && (n.castShadow || n.receiveShadow && s === ln) && (!n.frustumCulled || i.intersectsObject(n))) {
                        n.modelViewMatrix.multiplyMatrices(a.matrixWorldInverse, n.matrixWorld);
                        const i = t.update(n),
                            r = n.material;
                        if (Array.isArray(r)) {
                            const t = i.groups;
                            for (let l = 0, c = t.length; l < c; l++) {
                                const c = t[l],
                                    u = r[c.materialIndex];
                                if (u && u.visible) {
                                    const t = getDepthMaterial(n, i, u, o, a.near, a.far, s);
                                    e.renderBufferDirect(a, null, i, t, n, c)
                                }
                            }
                        } else if (r.visible) {
                            const t = getDepthMaterial(n, i, r, o, a.near, a.far, s);
                            e.renderBufferDirect(a, null, i, t, n, null)
                        }
                    }
                    const l = n.children;
                    for (let e = 0, t = l.length; e < t; e++) renderObject(l[e], r, a, o, s)
                }
                let i = new Frustum;
                const o = new Vector2,
                    s = new Vector2,
                    l = new Vector4,
                    c = [],
                    u = [],
                    h = {},
                    d = {
                        0: un,
                        1: cn,
                        2: hn
                    },
                    p = new ShaderMaterial({
                        defines: {
                            SAMPLE_RATE: 2 / 8,
                            HALF_SAMPLE_RATE: 1 / 8
                        },
                        uniforms: {
                            shadow_pass: {
                                value: null
                            },
                            resolution: {
                                value: new Vector2
                            },
                            radius: {
                                value: 4
                            }
                        },
                        vertexShader: a,
                        fragmentShader: r
                    }),
                    f = p.clone();
                f.defines.HORIZONTAL_PASS = 1;
                const m = new BufferGeometry;
                m.setAttribute("position", new BufferAttribute(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3));
                const g = new Mesh(m, p),
                    y = this;
                this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = on, this.render = function(t, r, a) {
                    if (!1 === y.enabled) return;
                    if (!1 === y.autoUpdate && !1 === y.needsUpdate) return;
                    if (0 === t.length) return;
                    const c = e.getRenderTarget(),
                        u = e.getActiveCubeFace(),
                        h = e.getActiveMipmapLevel(),
                        d = e.state;
                    d.setBlending(fn), d.buffers.color.setClear(1, 1, 1, 1), d.buffers.depth.setTest(!0), d.setScissorTest(!1);
                    for (let c = 0, u = t.length; c < u; c++) {
                        const u = t[c],
                            h = u.shadow;
                        if (void 0 === h) continue;
                        if (!1 === h.autoUpdate && !1 === h.needsUpdate) continue;
                        o.copy(h.mapSize);
                        const p = h.getFrameExtents();
                        if (o.multiply(p), s.copy(h.mapSize), (o.x > n || o.y > n) && (o.x > n && (s.x = Math.floor(n / p.x), o.x = s.x * p.x, h.mapSize.x = s.x), o.y > n && (s.y = Math.floor(n / p.y), o.y = s.y * p.y, h.mapSize.y = s.y)), null === h.map && !h.isPointLightShadow && this.type === ln) {
                            const e = {
                                minFilter: fi,
                                magFilter: fi,
                                format: Oi
                            };
                            h.map = new WebGLRenderTarget(o.x, o.y, e), h.map.texture.name = u.name + ".shadowMap", h.mapPass = new WebGLRenderTarget(o.x, o.y, e), h.camera.updateProjectionMatrix()
                        }
                        if (null === h.map) {
                            const e = {
                                minFilter: ci,
                                magFilter: ci,
                                format: Oi
                            };
                            h.map = new WebGLRenderTarget(o.x, o.y, e), h.map.texture.name = u.name + ".shadowMap", h.camera.updateProjectionMatrix()
                        }
                        e.setRenderTarget(h.map), e.clear();
                        const f = h.getViewportCount();
                        for (let e = 0; e < f; e++) {
                            const t = h.getViewport(e);
                            l.set(s.x * t.x, s.y * t.y, s.x * t.z, s.y * t.w), d.viewport(l), h.updateMatrices(u, e), i = h.getFrustum(), renderObject(r, a, h.camera, u, this.type)
                        }
                        h.isPointLightShadow || this.type !== ln || VSMPass(h, a), h.needsUpdate = !1
                    }
                    y.needsUpdate = !1, e.setRenderTarget(c, u, h)
                }
            }

            function WebGLState(e, t, n) {
                function createTexture(t, n, i) {
                    const r = new Uint8Array(4),
                        a = e.createTexture();
                    e.bindTexture(t, a), e.texParameteri(t, 10241, 9728), e.texParameteri(t, 10240, 9728);
                    for (let t = 0; t < i; t++) e.texImage2D(n + t, 0, 6408, 1, 1, 0, 6408, 5121, r);
                    return a
                }

                function enable(t) {
                    !0 !== s[t] && (e.enable(t), s[t] = !0)
                }

                function disable(t) {
                    !1 !== s[t] && (e.disable(t), s[t] = !1)
                }

                function setBlending(t, n, i, r, a, o, s, l) {
                    if (t !== fn) {
                        if (c || (enable(3042), c = !0), t === xn) a = a || n, o = o || i, s = s || r, n === h && a === f || (e.blendEquationSeparate(O[n], O[a]), h = n, f = a), i === d && r === p && o === m && s === g || (e.blendFuncSeparate(B[i], B[r], B[o], B[s]), d = i, p = r, m = o, g = s), u = t, y = null;
                        else if (t !== u || l !== y) {
                            if (h === _n && f === _n || (e.blendEquation(32774), h = _n, f = _n), l) switch (t) {
                                case mn:
                                    e.blendFuncSeparate(1, 771, 1, 771);
                                    break;
                                case gn:
                                    e.blendFunc(1, 1);
                                    break;
                                case vn:
                                    e.blendFuncSeparate(0, 0, 769, 771);
                                    break;
                                case yn:
                                    e.blendFuncSeparate(0, 768, 0, 770)
                            } else switch (t) {
                                case mn:
                                    e.blendFuncSeparate(770, 771, 1, 771);
                                    break;
                                case gn:
                                    e.blendFunc(770, 1);
                                    break;
                                case vn:
                                    e.blendFunc(0, 769);
                                    break;
                                case yn:
                                    e.blendFunc(0, 768)
                            }
                            d = null, p = null, m = null, g = null, u = t, y = l
                        }
                    } else c && (disable(3042), c = !1)
                }

                function setFlipSided(t) {
                    x !== t && (t ? e.frontFace(2304) : e.frontFace(2305), x = t)
                }

                function setCullFace(t) {
                    t !== en ? (enable(2884), t !== _ && (t === tn ? e.cullFace(1029) : t === nn ? e.cullFace(1028) : e.cullFace(1032))) : disable(2884), _ = t
                }

                function setPolygonOffset(t, n, i) {
                    t ? (enable(32823), M === n && S === i || (e.polygonOffset(n, i), M = n, S = i)) : disable(32823)
                }

                function activeTexture(t) {
                    void 0 === t && (t = 33984 + A - 1), C !== t && (e.activeTexture(t), C = t)
                }
                const i = n.isWebGL2,
                    r = new function ColorBuffer() {
                        let t = !1;
                        const n = new Vector4;
                        let i = null;
                        const r = new Vector4(0, 0, 0, 0);
                        return {
                            setMask: function(n) {
                                i === n || t || (e.colorMask(n, n, n, n), i = n)
                            },
                            setLocked: function(e) {
                                t = e
                            },
                            setClear: function(t, i, a, o, s) {
                                !0 === s && (t *= o, i *= o, a *= o), n.set(t, i, a, o), !1 === r.equals(n) && (e.clearColor(t, i, a, o), r.copy(n))
                            },
                            reset: function() {
                                t = !1, i = null, r.set(-1, 0, 0, 0)
                            }
                        }
                    },
                    a = new function DepthBuffer() {
                        let t = !1,
                            n = null,
                            i = null,
                            r = null;
                        return {
                            setTest: function(e) {
                                e ? enable(2929) : disable(2929)
                            },
                            setMask: function(i) {
                                n === i || t || (e.depthMask(i), n = i)
                            },
                            setFunc: function(t) {
                                if (i !== t) {
                                    if (t) switch (t) {
                                        case Nn:
                                            e.depthFunc(512);
                                            break;
                                        case Dn:
                                            e.depthFunc(519);
                                            break;
                                        case Vn:
                                            e.depthFunc(513);
                                            break;
                                        case Un:
                                            e.depthFunc(515);
                                            break;
                                        case zn:
                                            e.depthFunc(514);
                                            break;
                                        case Gn:
                                            e.depthFunc(518);
                                            break;
                                        case kn:
                                            e.depthFunc(516);
                                            break;
                                        case jn:
                                            e.depthFunc(517);
                                            break;
                                        default:
                                            e.depthFunc(515)
                                    } else e.depthFunc(515);
                                    i = t
                                }
                            },
                            setLocked: function(e) {
                                t = e
                            },
                            setClear: function(t) {
                                r !== t && (e.clearDepth(t), r = t)
                            },
                            reset: function() {
                                t = !1, n = null, i = null, r = null
                            }
                        }
                    },
                    o = new function StencilBuffer() {
                        let t = !1,
                            n = null,
                            i = null,
                            r = null,
                            a = null,
                            o = null,
                            s = null,
                            l = null,
                            c = null;
                        return {
                            setTest: function(e) {
                                t || (e ? enable(2960) : disable(2960))
                            },
                            setMask: function(i) {
                                n === i || t || (e.stencilMask(i), n = i)
                            },
                            setFunc: function(t, n, o) {
                                i === t && r === n && a === o || (e.stencilFunc(t, n, o), i = t, r = n, a = o)
                            },
                            setOp: function(t, n, i) {
                                o === t && s === n && l === i || (e.stencilOp(t, n, i), o = t, s = n, l = i)
                            },
                            setLocked: function(e) {
                                t = e
                            },
                            setClear: function(t) {
                                c !== t && (e.clearStencil(t), c = t)
                            },
                            reset: function() {
                                t = !1, n = null, i = null, r = null, a = null, o = null, s = null, l = null, c = null
                            }
                        }
                    };
                let s = {},
                    l = null,
                    c = null,
                    u = null,
                    h = null,
                    d = null,
                    p = null,
                    f = null,
                    m = null,
                    g = null,
                    y = !1,
                    x = null,
                    _ = null,
                    b = null,
                    M = null,
                    S = null;
                const A = e.getParameter(35661);
                let w = !1,
                    T = 0;
                const L = e.getParameter(7938); - 1 !== L.indexOf("WebGL") ? (T = parseFloat(/^WebGL (\d)/.exec(L)[1]), w = T >= 1) : -1 !== L.indexOf("OpenGL ES") && (T = parseFloat(/^OpenGL ES (\d)/.exec(L)[1]), w = T >= 2);
                let C = null,
                    P = {};
                const E = new Vector4,
                    I = new Vector4,
                    F = {};
                F[3553] = createTexture(3553, 3553, 1), F[34067] = createTexture(34067, 34069, 6), r.setClear(0, 0, 0, 1), a.setClear(1), o.setClear(0), enable(2929), a.setFunc(Un), setFlipSided(!1), setCullFace(tn), enable(2884), setBlending(fn);
                const O = {
                    [_n]: 32774,
                    [bn]: 32778,
                    [Mn]: 32779
                };
                if (i) O[Sn] = 32775, O[An] = 32776;
                else {
                    const e = t.get("EXT_blend_minmax");
                    null !== e && (O[Sn] = e.MIN_EXT, O[An] = e.MAX_EXT)
                }
                const B = {
                    [wn]: 0,
                    [Tn]: 1,
                    [Ln]: 768,
                    [Pn]: 770,
                    [Rn]: 776,
                    [On]: 774,
                    [In]: 772,
                    [Cn]: 769,
                    [En]: 771,
                    [Bn]: 775,
                    [Fn]: 773
                };
                return {
                    buffers: {
                        color: r,
                        depth: a,
                        stencil: o
                    },
                    enable,
                    disable,
                    useProgram: function useProgram(t) {
                        return l !== t && (e.useProgram(t), l = t, !0)
                    },
                    setBlending,
                    setMaterial: function setMaterial(e, t) {
                        e.side === hn ? disable(2884) : enable(2884);
                        let n = e.side === un;
                        t && (n = !n), setFlipSided(n), e.blending === mn && !1 === e.transparent ? setBlending(fn) : setBlending(e.blending, e.blendEquation, e.blendSrc, e.blendDst, e.blendEquationAlpha, e.blendSrcAlpha, e.blendDstAlpha, e.premultipliedAlpha), a.setFunc(e.depthFunc), a.setTest(e.depthTest), a.setMask(e.depthWrite), r.setMask(e.colorWrite);
                        const i = e.stencilWrite;
                        o.setTest(i), i && (o.setMask(e.stencilWriteMask), o.setFunc(e.stencilFunc, e.stencilRef, e.stencilFuncMask), o.setOp(e.stencilFail, e.stencilZFail, e.stencilZPass)), setPolygonOffset(e.polygonOffset, e.polygonOffsetFactor, e.polygonOffsetUnits)
                    },
                    setFlipSided,
                    setCullFace,
                    setLineWidth: function setLineWidth(t) {
                        t !== b && (w && e.lineWidth(t), b = t)
                    },
                    setPolygonOffset,
                    setScissorTest: function setScissorTest(e) {
                        e ? enable(3089) : disable(3089)
                    },
                    activeTexture,
                    bindTexture: function bindTexture(t, n) {
                        null === C && activeTexture();
                        let i = P[C];
                        void 0 === i && (i = {
                            type: void 0,
                            texture: void 0
                        }, P[C] = i), i.type === t && i.texture === n || (e.bindTexture(t, n || F[t]), i.type = t, i.texture = n)
                    },
                    unbindTexture: function unbindTexture() {
                        const t = P[C];
                        void 0 !== t && void 0 !== t.type && (e.bindTexture(t.type, null), t.type = void 0, t.texture = void 0)
                    },
                    compressedTexImage2D: function compressedTexImage2D() {
                        try {
                            e.compressedTexImage2D.apply(e, arguments)
                        } catch (e) {}
                    },
                    texImage2D: function texImage2D() {
                        try {
                            e.texImage2D.apply(e, arguments)
                        } catch (e) {}
                    },
                    texImage3D: function texImage3D() {
                        try {
                            e.texImage3D.apply(e, arguments)
                        } catch (e) {}
                    },
                    scissor: function scissor(t) {
                        !1 === E.equals(t) && (e.scissor(t.x, t.y, t.z, t.w), E.copy(t))
                    },
                    viewport: function viewport(t) {
                        !1 === I.equals(t) && (e.viewport(t.x, t.y, t.z, t.w), I.copy(t))
                    },
                    reset: function reset() {
                        s = {}, C = null, P = {}, l = null, c = null, u = null, h = null, d = null, p = null, f = null, m = null, g = null, y = !1, x = null, _ = null, b = null, M = null, S = null, r.reset(), a.reset(), o.reset()
                    }
                }
            }

            function WebGLTextures(e, t, n, i, r, a, o) {
                function createCanvas(e, t) {
                    return p ? new OffscreenCanvas(e, t) : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")
                }

                function resizeImage(e, t, n, i) {
                    let r = 1;
                    if ((e.width > i || e.height > i) && (r = i / Math.max(e.width, e.height)), r < 1 || !0 === t) {
                        if ("undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap) {
                            const i = t ? Fa.floorPowerOfTwo : Math.floor,
                                a = i(r * e.width),
                                o = i(r * e.height);
                            void 0 === d && (d = createCanvas(a, o));
                            const s = n ? createCanvas(a, o) : d;
                            s.width = a, s.height = o;
                            return s.getContext("2d").drawImage(e, 0, 0, a, o), s
                        }
                        return e
                    }
                    return e
                }

                function isPowerOfTwo(e) {
                    return Fa.isPowerOfTwo(e.width) && Fa.isPowerOfTwo(e.height)
                }

                function textureNeedsGenerateMipmaps(e, t) {
                    return e.generateMipmaps && t && e.minFilter !== ci && e.minFilter !== fi
                }

                function generateMipmap(t, n, r, a) {
                    e.generateMipmap(t);
                    i.get(n).__maxMipLevel = Math.log(Math.max(r, a)) * Math.LOG2E
                }

                function getInternalFormat(n, i, r) {
                    if (!1 === s) return i;
                    if (null !== n && void 0 !== e[n]) return e[n];
                    let a = i;
                    return 6403 === i && (5126 === r && (a = 33326), 5131 === r && (a = 33325), 5121 === r && (a = 33321)), 6407 === i && (5126 === r && (a = 34837), 5131 === r && (a = 34843), 5121 === r && (a = 32849)), 6408 === i && (5126 === r && (a = 34836), 5131 === r && (a = 34842), 5121 === r && (a = 32856)), 33325 !== a && 33326 !== a && 34842 !== a && 34836 !== a || t.get("EXT_color_buffer_float"), a
                }

                function filterFallback(e) {
                    return e === ci || e === ui || e === di ? 9728 : 9729
                }

                function onTextureDispose(t) {
                    const n = t.target;
                    n.removeEventListener("dispose", onTextureDispose),
                        function deallocateTexture(t) {
                            const n = i.get(t);
                            if (void 0 === n.__webglInit) return;
                            e.deleteTexture(n.__webglTexture), i.remove(t)
                        }(n), n.isVideoTexture && h.delete(n), o.memory.textures--
                }

                function onRenderTargetDispose(t) {
                    const n = t.target;
                    n.removeEventListener("dispose", onRenderTargetDispose),
                        function deallocateRenderTarget(t) {
                            const n = i.get(t),
                                r = i.get(t.texture);
                            if (!t) return;
                            void 0 !== r.__webglTexture && e.deleteTexture(r.__webglTexture);
                            t.depthTexture && t.depthTexture.dispose();
                            if (t.isWebGLCubeRenderTarget)
                                for (let t = 0; t < 6; t++) e.deleteFramebuffer(n.__webglFramebuffer[t]), n.__webglDepthbuffer && e.deleteRenderbuffer(n.__webglDepthbuffer[t]);
                            else e.deleteFramebuffer(n.__webglFramebuffer), n.__webglDepthbuffer && e.deleteRenderbuffer(n.__webglDepthbuffer), n.__webglMultisampledFramebuffer && e.deleteFramebuffer(n.__webglMultisampledFramebuffer), n.__webglColorRenderbuffer && e.deleteRenderbuffer(n.__webglColorRenderbuffer), n.__webglDepthRenderbuffer && e.deleteRenderbuffer(n.__webglDepthRenderbuffer);
                            i.remove(t.texture), i.remove(t)
                        }(n), o.memory.textures--
                }

                function setTexture2D(e, t) {
                    const r = i.get(e);
                    if (e.isVideoTexture && function updateVideoTexture(e) {
                            const t = o.render.frame;
                            h.get(e) !== t && (h.set(e, t), e.update())
                        }(e), e.version > 0 && r.__version !== e.version) {
                        const n = e.image;
                        if (void 0 === n);
                        else if (!1 !== n.complete) return void uploadTexture(r, e, t)
                    }
                    n.activeTexture(33984 + t), n.bindTexture(3553, r.__webglTexture)
                }

                function setTextureCube(t, r) {
                    const o = i.get(t);
                    t.version > 0 && o.__version !== t.version ? function uploadCubeTexture(t, i, r) {
                        if (6 !== i.image.length) return;
                        initTexture(t, i), n.activeTexture(33984 + r), n.bindTexture(34067, t.__webglTexture), e.pixelStorei(37440, i.flipY);
                        const o = i && (i.isCompressedTexture || i.image[0].isCompressedTexture),
                            c = i.image[0] && i.image[0].isDataTexture,
                            u = [];
                        for (let e = 0; e < 6; e++) u[e] = o || c ? c ? i.image[e].image : i.image[e] : resizeImage(i.image[e], !1, !0, l);
                        const h = u[0],
                            d = isPowerOfTwo(h) || s,
                            p = a.convert(i.format),
                            f = a.convert(i.type),
                            m = getInternalFormat(i.internalFormat, p, f);
                        let g;
                        if (setTextureParameters(34067, i, d), o) {
                            for (let e = 0; e < 6; e++) {
                                g = u[e].mipmaps;
                                for (let t = 0; t < g.length; t++) {
                                    const r = g[t];
                                    i.format !== Oi && i.format !== Fi ? null !== p && n.compressedTexImage2D(34069 + e, t, m, r.width, r.height, 0, r.data) : n.texImage2D(34069 + e, t, m, r.width, r.height, 0, p, f, r.data)
                                }
                            }
                            t.__maxMipLevel = g.length - 1
                        } else {
                            g = i.mipmaps;
                            for (let e = 0; e < 6; e++)
                                if (c) {
                                    n.texImage2D(34069 + e, 0, m, u[e].width, u[e].height, 0, p, f, u[e].data);
                                    for (let t = 0; t < g.length; t++) {
                                        const i = g[t].image[e].image;
                                        n.texImage2D(34069 + e, t + 1, m, i.width, i.height, 0, p, f, i.data)
                                    }
                                } else {
                                    n.texImage2D(34069 + e, 0, m, p, f, u[e]);
                                    for (let t = 0; t < g.length; t++) {
                                        const i = g[t];
                                        n.texImage2D(34069 + e, t + 1, m, p, f, i.image[e])
                                    }
                                }
                            t.__maxMipLevel = g.length
                        }
                        textureNeedsGenerateMipmaps(i, d) && generateMipmap(34067, i, h.width, h.height);
                        t.__version = i.version, i.onUpdate && i.onUpdate(i)
                    }(o, t, r) : (n.activeTexture(33984 + r), n.bindTexture(34067, o.__webglTexture))
                }

                function setTextureParameters(n, a, o) {
                    o ? (e.texParameteri(n, 10242, m[a.wrapS]), e.texParameteri(n, 10243, m[a.wrapT]), 32879 !== n && 35866 !== n || e.texParameteri(n, 32882, m[a.wrapR]), e.texParameteri(n, 10240, g[a.magFilter]), e.texParameteri(n, 10241, g[a.minFilter])) : (e.texParameteri(n, 10242, 33071), e.texParameteri(n, 10243, 33071), 32879 !== n && 35866 !== n || e.texParameteri(n, 32882, 33071), a.wrapS !== si || a.wrapT, e.texParameteri(n, 10240, filterFallback(a.magFilter)), e.texParameteri(n, 10241, filterFallback(a.minFilter)), a.minFilter !== ci && a.minFilter);
                    const l = t.get("EXT_texture_filter_anisotropic");
                    if (l) {
                        if (a.type === wi && null === t.get("OES_texture_float_linear")) return;
                        if (a.type === Ti && null === (s || t.get("OES_texture_half_float_linear"))) return;
                        (a.anisotropy > 1 || i.get(a).__currentAnisotropy) && (e.texParameterf(n, l.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(a.anisotropy, r.getMaxAnisotropy())), i.get(a).__currentAnisotropy = a.anisotropy)
                    }
                }

                function initTexture(t, n) {
                    void 0 === t.__webglInit && (t.__webglInit = !0, n.addEventListener("dispose", onTextureDispose), t.__webglTexture = e.createTexture(), o.memory.textures++)
                }

                function uploadTexture(t, i, r) {
                    let o = 3553;
                    i.isDataTexture2DArray && (o = 35866), i.isDataTexture3D && (o = 32879), initTexture(t, i), n.activeTexture(33984 + r), n.bindTexture(o, t.__webglTexture), e.pixelStorei(37440, i.flipY), e.pixelStorei(37441, i.premultiplyAlpha), e.pixelStorei(3317, i.unpackAlignment);
                    const l = function textureNeedsPowerOfTwo(e) {
                            return !s && (e.wrapS !== si || e.wrapT !== si || e.minFilter !== ci && e.minFilter !== fi)
                        }(i) && !1 === isPowerOfTwo(i.image),
                        u = resizeImage(i.image, l, !1, c),
                        h = isPowerOfTwo(u) || s,
                        d = a.convert(i.format);
                    let p, f = a.convert(i.type),
                        m = getInternalFormat(i.internalFormat, d, f);
                    setTextureParameters(o, i, h);
                    const g = i.mipmaps;
                    if (i.isDepthTexture) m = 6402, s ? m = i.type === wi ? 36012 : i.type === Ai ? 33190 : i.type === Ei ? 35056 : 33189 : i.type, i.format === Di && 6402 === m && i.type !== Mi && i.type !== Ai && (i.type = Mi, f = a.convert(i.type)), i.format === Vi && 6402 === m && (m = 34041, i.type !== Ei && (i.type = Ei, f = a.convert(i.type))), n.texImage2D(3553, 0, m, u.width, u.height, 0, d, f, null);
                    else if (i.isDataTexture)
                        if (g.length > 0 && h) {
                            for (let e = 0, t = g.length; e < t; e++) p = g[e], n.texImage2D(3553, e, m, p.width, p.height, 0, d, f, p.data);
                            i.generateMipmaps = !1, t.__maxMipLevel = g.length - 1
                        } else n.texImage2D(3553, 0, m, u.width, u.height, 0, d, f, u.data), t.__maxMipLevel = 0;
                    else if (i.isCompressedTexture) {
                        for (let e = 0, t = g.length; e < t; e++) p = g[e], i.format !== Oi && i.format !== Fi ? null !== d && n.compressedTexImage2D(3553, e, m, p.width, p.height, 0, p.data) : n.texImage2D(3553, e, m, p.width, p.height, 0, d, f, p.data);
                        t.__maxMipLevel = g.length - 1
                    } else if (i.isDataTexture2DArray) n.texImage3D(35866, 0, m, u.width, u.height, u.depth, 0, d, f, u.data), t.__maxMipLevel = 0;
                    else if (i.isDataTexture3D) n.texImage3D(32879, 0, m, u.width, u.height, u.depth, 0, d, f, u.data), t.__maxMipLevel = 0;
                    else if (g.length > 0 && h) {
                        for (let e = 0, t = g.length; e < t; e++) p = g[e], n.texImage2D(3553, e, m, d, f, p);
                        i.generateMipmaps = !1, t.__maxMipLevel = g.length - 1
                    } else n.texImage2D(3553, 0, m, d, f, u), t.__maxMipLevel = 0;
                    textureNeedsGenerateMipmaps(i, h) && generateMipmap(o, i, u.width, u.height), t.__version = i.version, i.onUpdate && i.onUpdate(i)
                }

                function setupFrameBufferTexture(t, r, o, s) {
                    const l = a.convert(r.texture.format),
                        c = a.convert(r.texture.type),
                        u = getInternalFormat(r.texture.internalFormat, l, c);
                    n.texImage2D(s, 0, u, r.width, r.height, 0, l, c, null), e.bindFramebuffer(36160, t), e.framebufferTexture2D(36160, o, s, i.get(r.texture).__webglTexture, 0), e.bindFramebuffer(36160, null)
                }

                function setupRenderBufferStorage(t, n, i) {
                    if (e.bindRenderbuffer(36161, t), n.depthBuffer && !n.stencilBuffer) {
                        let r = 33189;
                        if (i) {
                            const t = n.depthTexture;
                            t && t.isDepthTexture && (t.type === wi ? r = 36012 : t.type === Ai && (r = 33190));
                            const i = getRenderTargetSamples(n);
                            e.renderbufferStorageMultisample(36161, i, r, n.width, n.height)
                        } else e.renderbufferStorage(36161, r, n.width, n.height);
                        e.framebufferRenderbuffer(36160, 36096, 36161, t)
                    } else if (n.depthBuffer && n.stencilBuffer) {
                        if (i) {
                            const t = getRenderTargetSamples(n);
                            e.renderbufferStorageMultisample(36161, t, 35056, n.width, n.height)
                        } else e.renderbufferStorage(36161, 34041, n.width, n.height);
                        e.framebufferRenderbuffer(36160, 33306, 36161, t)
                    } else {
                        const t = a.convert(n.texture.format),
                            r = a.convert(n.texture.type),
                            o = getInternalFormat(n.texture.internalFormat, t, r);
                        if (i) {
                            const t = getRenderTargetSamples(n);
                            e.renderbufferStorageMultisample(36161, t, o, n.width, n.height)
                        } else e.renderbufferStorage(36161, o, n.width, n.height)
                    }
                    e.bindRenderbuffer(36161, null)
                }

                function setupDepthRenderbuffer(t) {
                    const n = i.get(t),
                        r = !0 === t.isWebGLCubeRenderTarget;
                    if (t.depthTexture) {
                        if (r) throw Error("target.depthTexture not supported in Cube render targets");
                        ! function setupDepthTexture(t, n) {
                            if (n && n.isWebGLCubeRenderTarget) throw Error("Depth Texture with cube render targets is not supported");
                            if (e.bindFramebuffer(36160, t), !n.depthTexture || !n.depthTexture.isDepthTexture) throw Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                            i.get(n.depthTexture).__webglTexture && n.depthTexture.image.width === n.width && n.depthTexture.image.height === n.height || (n.depthTexture.image.width = n.width, n.depthTexture.image.height = n.height, n.depthTexture.needsUpdate = !0), setTexture2D(n.depthTexture, 0);
                            const r = i.get(n.depthTexture).__webglTexture;
                            if (n.depthTexture.format === Di) e.framebufferTexture2D(36160, 36096, 3553, r, 0);
                            else {
                                if (n.depthTexture.format !== Vi) throw Error("Unknown depthTexture format");
                                e.framebufferTexture2D(36160, 33306, 3553, r, 0)
                            }
                        }(n.__webglFramebuffer, t)
                    } else if (r) {
                        n.__webglDepthbuffer = [];
                        for (let i = 0; i < 6; i++) e.bindFramebuffer(36160, n.__webglFramebuffer[i]), n.__webglDepthbuffer[i] = e.createRenderbuffer(), setupRenderBufferStorage(n.__webglDepthbuffer[i], t, !1)
                    } else e.bindFramebuffer(36160, n.__webglFramebuffer), n.__webglDepthbuffer = e.createRenderbuffer(), setupRenderBufferStorage(n.__webglDepthbuffer, t, !1);
                    e.bindFramebuffer(36160, null)
                }

                function getRenderTargetSamples(e) {
                    return s && e.isWebGLMultisampleRenderTarget ? Math.min(u, e.samples) : 0
                }
                const s = r.isWebGL2,
                    l = (r.maxTextures, r.maxCubemapSize),
                    c = r.maxTextureSize,
                    u = r.maxSamples,
                    h = new WeakMap;
                let d, p = !1;
                try {
                    p = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext("2d")
                } catch (e) {}
                let f = 0;
                const m = {
                        [oi]: 10497,
                        [si]: 33071,
                        [li]: 33648
                    },
                    g = {
                        [ci]: 9728,
                        [ui]: 9984,
                        [di]: 9986,
                        [fi]: 9729,
                        [mi]: 9985,
                        [vi]: 9987
                    };
                let y = !1,
                    x = !1;
                this.allocateTextureUnit = function allocateTextureUnit() {
                    const e = f;
                    return f += 1, e
                }, this.resetTextureUnits = function resetTextureUnits() {
                    f = 0
                }, this.setTexture2D = setTexture2D, this.setTexture2DArray = function setTexture2DArray(e, t) {
                    const r = i.get(e);
                    e.version > 0 && r.__version !== e.version ? uploadTexture(r, e, t) : (n.activeTexture(33984 + t), n.bindTexture(35866, r.__webglTexture))
                }, this.setTexture3D = function setTexture3D(e, t) {
                    const r = i.get(e);
                    e.version > 0 && r.__version !== e.version ? uploadTexture(r, e, t) : (n.activeTexture(33984 + t), n.bindTexture(32879, r.__webglTexture))
                }, this.setTextureCube = setTextureCube, this.setupRenderTarget = function setupRenderTarget(t) {
                    const r = i.get(t),
                        l = i.get(t.texture);
                    t.addEventListener("dispose", onRenderTargetDispose), l.__webglTexture = e.createTexture(), o.memory.textures++;
                    const c = !0 === t.isWebGLCubeRenderTarget,
                        u = !0 === t.isWebGLMultisampleRenderTarget,
                        h = isPowerOfTwo(t) || s;
                    if (!s || t.texture.format !== Fi || t.texture.type !== wi && t.texture.type !== Ti || (t.texture.format = Oi), c) {
                        r.__webglFramebuffer = [];
                        for (let t = 0; t < 6; t++) r.__webglFramebuffer[t] = e.createFramebuffer()
                    } else if (r.__webglFramebuffer = e.createFramebuffer(), u && s) {
                        r.__webglMultisampledFramebuffer = e.createFramebuffer(), r.__webglColorRenderbuffer = e.createRenderbuffer(), e.bindRenderbuffer(36161, r.__webglColorRenderbuffer);
                        const n = a.convert(t.texture.format),
                            i = a.convert(t.texture.type),
                            o = getInternalFormat(t.texture.internalFormat, n, i),
                            s = getRenderTargetSamples(t);
                        e.renderbufferStorageMultisample(36161, s, o, t.width, t.height), e.bindFramebuffer(36160, r.__webglMultisampledFramebuffer), e.framebufferRenderbuffer(36160, 36064, 36161, r.__webglColorRenderbuffer), e.bindRenderbuffer(36161, null), t.depthBuffer && (r.__webglDepthRenderbuffer = e.createRenderbuffer(), setupRenderBufferStorage(r.__webglDepthRenderbuffer, t, !0)), e.bindFramebuffer(36160, null)
                    }
                    if (c) {
                        n.bindTexture(34067, l.__webglTexture), setTextureParameters(34067, t.texture, h);
                        for (let e = 0; e < 6; e++) setupFrameBufferTexture(r.__webglFramebuffer[e], t, 36064, 34069 + e);
                        textureNeedsGenerateMipmaps(t.texture, h) && generateMipmap(34067, t.texture, t.width, t.height), n.bindTexture(34067, null)
                    } else n.bindTexture(3553, l.__webglTexture), setTextureParameters(3553, t.texture, h), setupFrameBufferTexture(r.__webglFramebuffer, t, 36064, 3553), textureNeedsGenerateMipmaps(t.texture, h) && generateMipmap(3553, t.texture, t.width, t.height), n.bindTexture(3553, null);
                    t.depthBuffer && setupDepthRenderbuffer(t)
                }, this.updateRenderTargetMipmap = function updateRenderTargetMipmap(e) {
                    const t = e.texture;
                    if (textureNeedsGenerateMipmaps(t, isPowerOfTwo(e) || s)) {
                        const r = e.isWebGLCubeRenderTarget ? 34067 : 3553,
                            a = i.get(t).__webglTexture;
                        n.bindTexture(r, a), generateMipmap(r, t, e.width, e.height), n.bindTexture(r, null)
                    }
                }, this.updateMultisampleRenderTarget = function updateMultisampleRenderTarget(t) {
                    if (t.isWebGLMultisampleRenderTarget && s) {
                        const n = i.get(t);
                        e.bindFramebuffer(36008, n.__webglMultisampledFramebuffer), e.bindFramebuffer(36009, n.__webglFramebuffer);
                        const r = t.width,
                            a = t.height;
                        let o = 16384;
                        t.depthBuffer && (o |= 256), t.stencilBuffer && (o |= 1024), e.blitFramebuffer(0, 0, r, a, 0, 0, r, a, o, 9728), e.bindFramebuffer(36160, n.__webglMultisampledFramebuffer)
                    }
                }, this.safeSetTexture2D = function safeSetTexture2D(e, t) {
                    e && e.isWebGLRenderTarget && (!1 === y && (y = !0), e = e.texture), setTexture2D(e, t)
                }, this.safeSetTextureCube = function safeSetTextureCube(e, t) {
                    e && e.isWebGLCubeRenderTarget && (!1 === x && (x = !0), e = e.texture), setTextureCube(e, t)
                }
            }

            function WebGLUtils(e, t, n) {
                const i = n.isWebGL2;
                return {
                    convert: function convert(e) {
                        let n;
                        if (e === xi) return 5121;
                        if (e === Li) return 32819;
                        if (e === Ci) return 32820;
                        if (e === Pi) return 33635;
                        if (e === _i) return 5120;
                        if (e === bi) return 5122;
                        if (e === Mi) return 5123;
                        if (e === Si) return 5124;
                        if (e === Ai) return 5125;
                        if (e === wi) return 5126;
                        if (e === Ti) return i ? 5131 : (n = t.get("OES_texture_half_float"), null !== n ? n.HALF_FLOAT_OES : null);
                        if (e === Ii) return 6406;
                        if (e === Fi) return 6407;
                        if (e === Oi) return 6408;
                        if (e === Bi) return 6409;
                        if (e === Ri) return 6410;
                        if (e === Di) return 6402;
                        if (e === Vi) return 34041;
                        if (e === Ui) return 6403;
                        if (e === zi) return 36244;
                        if (e === Gi) return 33319;
                        if (e === ki) return 33320;
                        if (e === ji) return 36248;
                        if (e === Wi) return 36249;
                        if (e === Hi || e === Xi || e === Yi || e === qi) {
                            if (n = t.get("WEBGL_compressed_texture_s3tc"), null === n) return null;
                            if (e === Hi) return n.COMPRESSED_RGB_S3TC_DXT1_EXT;
                            if (e === Xi) return n.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                            if (e === Yi) return n.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                            if (e === qi) return n.COMPRESSED_RGBA_S3TC_DXT5_EXT
                        }
                        if (e === Qi || e === Ji || e === Zi || e === Ki) {
                            if (n = t.get("WEBGL_compressed_texture_pvrtc"), null === n) return null;
                            if (e === Qi) return n.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                            if (e === Ji) return n.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                            if (e === Zi) return n.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                            if (e === Ki) return n.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                        }
                        if (e === $i) return n = t.get("WEBGL_compressed_texture_etc1"), null !== n ? n.COMPRESSED_RGB_ETC1_WEBGL : null;
                        if ((e === er || e === tr) && (n = t.get("WEBGL_compressed_texture_etc"), null !== n)) {
                            if (e === er) return n.COMPRESSED_RGB8_ETC2;
                            if (e === tr) return n.COMPRESSED_RGBA8_ETC2_EAC
                        }
                        return e === nr || e === ir || e === rr || e === ar || e === or || e === sr || e === lr || e === cr || e === ur || e === hr || e === dr || e === pr || e === fr || e === mr || e === vr || e === yr || e === xr || e === _r || e === br || e === Mr || e === Sr || e === Ar || e === wr || e === Tr || e === Lr || e === Cr || e === Pr || e === Er ? (n = t.get("WEBGL_compressed_texture_astc"), null !== n ? e : null) : e === gr ? (n = t.get("EXT_texture_compression_bptc"), null !== n ? e : null) : e === Ei ? i ? 34042 : (n = t.get("WEBGL_depth_texture"), null !== n ? n.UNSIGNED_INT_24_8_WEBGL : null) : void 0
                    }
                }
            }

            function ArrayCamera(e = []) {
                PerspectiveCamera.call(this), this.cameras = e
            }

            function Group() {
                Object3D.call(this), this.type = "Group"
            }

            function WebXRController() {
                this._targetRay = null, this._grip = null, this._hand = null
            }

            function WebXRManager(e, t) {
                function onSessionEvent(e) {
                    const t = c.get(e.inputSource);
                    t && t.dispatchEvent({
                        type: e.type,
                        data: e.inputSource
                    })
                }

                function onSessionEnd() {
                    c.forEach((function(e, t) {
                        e.disconnect(t)
                    })), c.clear(), e.setFramebuffer(null), e.setRenderTarget(e.getRenderTarget()), _.stop(), n.isPresenting = !1, n.dispatchEvent({
                        type: "sessionend"
                    })
                }

                function onRequestReferenceSpace(e) {
                    a = e, _.setContext(i), _.start(), n.isPresenting = !0, n.dispatchEvent({
                        type: "sessionstart"
                    })
                }

                function updateInputSources(e) {
                    const t = i.inputSources;
                    for (let e = 0; e < l.length; e++) c.set(t[e], l[e]);
                    for (let t = 0; t < e.removed.length; t++) {
                        const n = e.removed[t],
                            i = c.get(n);
                        i && (i.dispatchEvent({
                            type: "disconnected",
                            data: n
                        }), c.delete(n))
                    }
                    for (let t = 0; t < e.added.length; t++) {
                        const n = e.added[t],
                            i = c.get(n);
                        i && i.dispatchEvent({
                            type: "connected",
                            data: n
                        })
                    }
                }

                function updateCamera(e, t) {
                    null === t ? e.matrixWorld.copy(e.matrix) : e.matrixWorld.multiplyMatrices(t.matrixWorld, e.matrix), e.matrixWorldInverse.copy(e.matrixWorld).invert()
                }
                const n = this;
                let i = null,
                    r = 1,
                    a = null,
                    o = "local-floor",
                    s = null;
                const l = [],
                    c = new Map,
                    u = new PerspectiveCamera;
                u.layers.enable(1), u.viewport = new Vector4;
                const h = new PerspectiveCamera;
                h.layers.enable(2), h.viewport = new Vector4;
                const d = [u, h],
                    p = new ArrayCamera;
                p.layers.enable(1), p.layers.enable(2);
                let f = null,
                    m = null;
                this.enabled = !1, this.isPresenting = !1, this.getController = function(e) {
                    let t = l[e];
                    return void 0 === t && (t = new WebXRController, l[e] = t), t.getTargetRaySpace()
                }, this.getControllerGrip = function(e) {
                    let t = l[e];
                    return void 0 === t && (t = new WebXRController, l[e] = t), t.getGripSpace()
                }, this.getHand = function(e) {
                    let t = l[e];
                    return void 0 === t && (t = new WebXRController, l[e] = t), t.getHandSpace()
                }, this.setFramebufferScaleFactor = function(e) {
                    r = e, n.isPresenting
                }, this.setReferenceSpaceType = function(e) {
                    o = e, n.isPresenting
                }, this.getReferenceSpace = function() {
                    return a
                }, this.getSession = function() {
                    return i
                }, this.setSession = function(e) {
                    if (i = e, null !== i) {
                        i.addEventListener("select", onSessionEvent), i.addEventListener("selectstart", onSessionEvent), i.addEventListener("selectend", onSessionEvent), i.addEventListener("squeeze", onSessionEvent), i.addEventListener("squeezestart", onSessionEvent), i.addEventListener("squeezeend", onSessionEvent), i.addEventListener("end", onSessionEnd);
                        const e = t.getContextAttributes();
                        !0 !== e.xrCompatible && t.makeXRCompatible();
                        const n = {
                                antialias: e.antialias,
                                alpha: e.alpha,
                                depth: e.depth,
                                stencil: e.stencil,
                                framebufferScaleFactor: r
                            },
                            a = new XRWebGLLayer(i, t, n);
                        i.updateRenderState({
                            baseLayer: a
                        }), i.requestReferenceSpace(o).then(onRequestReferenceSpace), i.addEventListener("inputsourceschange", updateInputSources)
                    }
                };
                const g = new Vector3,
                    y = new Vector3;
                this.getCamera = function(e) {
                    p.near = h.near = u.near = e.near, p.far = h.far = u.far = e.far, f === p.near && m === p.far || (i.updateRenderState({
                        depthNear: p.near,
                        depthFar: p.far
                    }), f = p.near, m = p.far);
                    const t = e.parent,
                        n = p.cameras;
                    updateCamera(p, t);
                    for (let e = 0; e < n.length; e++) updateCamera(n[e], t);
                    e.matrixWorld.copy(p.matrixWorld);
                    const r = e.children;
                    for (let e = 0, t = r.length; e < t; e++) r[e].updateMatrixWorld(!0);
                    return 2 === n.length ? function setProjectionFromUnion(e, t, n) {
                        g.setFromMatrixPosition(t.matrixWorld), y.setFromMatrixPosition(n.matrixWorld);
                        const i = g.distanceTo(y),
                            r = t.projectionMatrix.elements,
                            a = n.projectionMatrix.elements,
                            o = r[14] / (r[10] - 1),
                            s = r[14] / (r[10] + 1),
                            l = (r[9] + 1) / r[5],
                            c = (r[9] - 1) / r[5],
                            u = (r[8] - 1) / r[0],
                            h = (a[8] + 1) / a[0],
                            d = o * u,
                            p = o * h,
                            f = i / (-u + h),
                            m = f * -u;
                        t.matrixWorld.decompose(e.position, e.quaternion, e.scale), e.translateX(m), e.translateZ(f), e.matrixWorld.compose(e.position, e.quaternion, e.scale), e.matrixWorldInverse.copy(e.matrixWorld).invert();
                        const x = o + f,
                            _ = s + f,
                            b = d - m,
                            M = p + (i - m),
                            S = l * s / _ * x,
                            A = c * s / _ * x;
                        e.projectionMatrix.makePerspective(b, M, S, A, x, _)
                    }(p, u, h) : p.projectionMatrix.copy(u.projectionMatrix), p
                };
                let x = null;
                const _ = new WebGLAnimation;
                _.setAnimationLoop((function onAnimationFrame(t, n) {
                    if (s = n.getViewerPose(a), null !== s) {
                        const t = s.views,
                            n = i.renderState.baseLayer;
                        e.setFramebuffer(n.framebuffer);
                        let r = !1;
                        t.length !== p.cameras.length && (p.cameras.length = 0, r = !0);
                        for (let e = 0; e < t.length; e++) {
                            const i = t[e],
                                a = n.getViewport(i),
                                o = d[e];
                            o.matrix.fromArray(i.transform.matrix), o.projectionMatrix.fromArray(i.projectionMatrix), o.viewport.set(a.x, a.y, a.width, a.height), 0 === e && p.matrix.copy(o.matrix), !0 === r && p.cameras.push(o)
                        }
                    }
                    const r = i.inputSources;
                    for (let e = 0; e < l.length; e++) {
                        const t = l[e],
                            i = r[e];
                        t.update(i, n, a)
                    }
                    x && x(t, n)
                })), this.setAnimationLoop = function(e) {
                    x = e
                }, this.dispose = function() {}
            }

            function WebGLMaterials(e) {
                function refreshUniformsCommon(t, n) {
                    t.opacity.value = n.opacity, n.color && t.diffuse.value.copy(n.color), n.emissive && t.emissive.value.copy(n.emissive).multiplyScalar(n.emissiveIntensity), n.map && (t.map.value = n.map), n.alphaMap && (t.alphaMap.value = n.alphaMap), n.specularMap && (t.specularMap.value = n.specularMap);
                    const i = e.get(n).envMap;
                    if (i) {
                        t.envMap.value = i, t.flipEnvMap.value = i.isCubeTexture && i._needsFlipEnvMap ? -1 : 1, t.reflectivity.value = n.reflectivity, t.refractionRatio.value = n.refractionRatio;
                        const r = e.get(i).__maxMipLevel;
                        void 0 !== r && (t.maxMipLevel.value = r)
                    }
                    let r, a;
                    n.lightMap && (t.lightMap.value = n.lightMap, t.lightMapIntensity.value = n.lightMapIntensity), n.aoMap && (t.aoMap.value = n.aoMap, t.aoMapIntensity.value = n.aoMapIntensity), n.map ? r = n.map : n.specularMap ? r = n.specularMap : n.displacementMap ? r = n.displacementMap : n.normalMap ? r = n.normalMap : n.bumpMap ? r = n.bumpMap : n.roughnessMap ? r = n.roughnessMap : n.metalnessMap ? r = n.metalnessMap : n.alphaMap ? r = n.alphaMap : n.emissiveMap ? r = n.emissiveMap : n.clearcoatMap ? r = n.clearcoatMap : n.clearcoatNormalMap ? r = n.clearcoatNormalMap : n.clearcoatRoughnessMap && (r = n.clearcoatRoughnessMap), void 0 !== r && (r.isWebGLRenderTarget && (r = r.texture), !0 === r.matrixAutoUpdate && r.updateMatrix(), t.uvTransform.value.copy(r.matrix)), n.aoMap ? a = n.aoMap : n.lightMap && (a = n.lightMap), void 0 !== a && (a.isWebGLRenderTarget && (a = a.texture), !0 === a.matrixAutoUpdate && a.updateMatrix(), t.uv2Transform.value.copy(a.matrix))
                }

                function refreshUniformsStandard(t, n) {
                    t.roughness.value = n.roughness, t.metalness.value = n.metalness, n.roughnessMap && (t.roughnessMap.value = n.roughnessMap), n.metalnessMap && (t.metalnessMap.value = n.metalnessMap), n.emissiveMap && (t.emissiveMap.value = n.emissiveMap), n.bumpMap && (t.bumpMap.value = n.bumpMap, t.bumpScale.value = n.bumpScale, n.side === un && (t.bumpScale.value *= -1)), n.normalMap && (t.normalMap.value = n.normalMap, t.normalScale.value.copy(n.normalScale), n.side === un && t.normalScale.value.negate()), n.displacementMap && (t.displacementMap.value = n.displacementMap, t.displacementScale.value = n.displacementScale, t.displacementBias.value = n.displacementBias);
                    e.get(n).envMap && (t.envMapIntensity.value = n.envMapIntensity)
                }
                return {
                    refreshFogUniforms: function refreshFogUniforms(e, t) {
                        e.fogColor.value.copy(t.color), t.isFog ? (e.fogNear.value = t.near, e.fogFar.value = t.far) : t.isFogExp2 && (e.fogDensity.value = t.density)
                    },
                    refreshMaterialUniforms: function refreshMaterialUniforms(e, t, n, i) {
                        t.isMeshBasicMaterial ? refreshUniformsCommon(e, t) : t.isMeshLambertMaterial ? (refreshUniformsCommon(e, t), function refreshUniformsLambert(e, t) {
                            t.emissiveMap && (e.emissiveMap.value = t.emissiveMap)
                        }(e, t)) : t.isMeshToonMaterial ? (refreshUniformsCommon(e, t), function refreshUniformsToon(e, t) {
                            t.gradientMap && (e.gradientMap.value = t.gradientMap);
                            t.emissiveMap && (e.emissiveMap.value = t.emissiveMap);
                            t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale, t.side === un && (e.bumpScale.value *= -1));
                            t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale), t.side === un && e.normalScale.value.negate());
                            t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias)
                        }(e, t)) : t.isMeshPhongMaterial ? (refreshUniformsCommon(e, t), function refreshUniformsPhong(e, t) {
                            e.specular.value.copy(t.specular), e.shininess.value = Math.max(t.shininess, 1e-4), t.emissiveMap && (e.emissiveMap.value = t.emissiveMap);
                            t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale, t.side === un && (e.bumpScale.value *= -1));
                            t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale), t.side === un && e.normalScale.value.negate());
                            t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias)
                        }(e, t)) : t.isMeshStandardMaterial ? (refreshUniformsCommon(e, t), t.isMeshPhysicalMaterial ? function refreshUniformsPhysical(e, t) {
                            refreshUniformsStandard(e, t), e.reflectivity.value = t.reflectivity, e.clearcoat.value = t.clearcoat, e.clearcoatRoughness.value = t.clearcoatRoughness, t.sheen && e.sheen.value.copy(t.sheen);
                            t.clearcoatMap && (e.clearcoatMap.value = t.clearcoatMap);
                            t.clearcoatRoughnessMap && (e.clearcoatRoughnessMap.value = t.clearcoatRoughnessMap);
                            t.clearcoatNormalMap && (e.clearcoatNormalScale.value.copy(t.clearcoatNormalScale), e.clearcoatNormalMap.value = t.clearcoatNormalMap, t.side === un && e.clearcoatNormalScale.value.negate());
                            e.transmission.value = t.transmission, t.transmissionMap && (e.transmissionMap.value = t.transmissionMap)
                        }(e, t) : refreshUniformsStandard(e, t)) : t.isMeshMatcapMaterial ? (refreshUniformsCommon(e, t), function refreshUniformsMatcap(e, t) {
                            t.matcap && (e.matcap.value = t.matcap);
                            t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale, t.side === un && (e.bumpScale.value *= -1));
                            t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale), t.side === un && e.normalScale.value.negate());
                            t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias)
                        }(e, t)) : t.isMeshDepthMaterial ? (refreshUniformsCommon(e, t), function refreshUniformsDepth(e, t) {
                            t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias)
                        }(e, t)) : t.isMeshDistanceMaterial ? (refreshUniformsCommon(e, t), function refreshUniformsDistance(e, t) {
                            t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias);
                            e.referencePosition.value.copy(t.referencePosition), e.nearDistance.value = t.nearDistance, e.farDistance.value = t.farDistance
                        }(e, t)) : t.isMeshNormalMaterial ? (refreshUniformsCommon(e, t), function refreshUniformsNormal(e, t) {
                            t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale, t.side === un && (e.bumpScale.value *= -1));
                            t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale), t.side === un && e.normalScale.value.negate());
                            t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias)
                        }(e, t)) : t.isLineBasicMaterial ? (! function refreshUniformsLine(e, t) {
                            e.diffuse.value.copy(t.color), e.opacity.value = t.opacity
                        }(e, t), t.isLineDashedMaterial && function refreshUniformsDash(e, t) {
                            e.dashSize.value = t.dashSize, e.totalSize.value = t.dashSize + t.gapSize, e.scale.value = t.scale
                        }(e, t)) : t.isPointsMaterial ? function refreshUniformsPoints(e, t, n, i) {
                            e.diffuse.value.copy(t.color), e.opacity.value = t.opacity, e.size.value = t.size * n, e.scale.value = .5 * i, t.map && (e.map.value = t.map);
                            t.alphaMap && (e.alphaMap.value = t.alphaMap);
                            let r;
                            t.map ? r = t.map : t.alphaMap && (r = t.alphaMap);
                            void 0 !== r && (!0 === r.matrixAutoUpdate && r.updateMatrix(), e.uvTransform.value.copy(r.matrix))
                        }(e, t, n, i) : t.isSpriteMaterial ? function refreshUniformsSprites(e, t) {
                            e.diffuse.value.copy(t.color), e.opacity.value = t.opacity, e.rotation.value = t.rotation, t.map && (e.map.value = t.map);
                            t.alphaMap && (e.alphaMap.value = t.alphaMap);
                            let n;
                            t.map ? n = t.map : t.alphaMap && (n = t.alphaMap);
                            void 0 !== n && (!0 === n.matrixAutoUpdate && n.updateMatrix(), e.uvTransform.value.copy(n.matrix))
                        }(e, t) : t.isShadowMaterial ? (e.color.value.copy(t.color), e.opacity.value = t.opacity) : t.isShaderMaterial && (t.uniformsNeedUpdate = !1)
                    }
                }
            }

            function WebGLRenderer(e) {
                function getTargetPixelRatio() {
                    return null === _ ? P : 1
                }

                function getContext(e, n) {
                    for (let i = 0; i < e.length; i++) {
                        const r = e[i],
                            a = t.getContext(r, n);
                        if (null !== a) return a
                    }
                    return null
                }

                function initGLContext() {
                    G = new WebGLExtensions(le), k = new WebGLCapabilities(le, G, e), !1 === k.isWebGL2 && (G.get("WEBGL_depth_texture"), G.get("OES_texture_float"), G.get("OES_texture_half_float"), G.get("OES_texture_half_float_linear"), G.get("OES_standard_derivatives"), G.get("OES_element_index_uint"), G.get("OES_vertex_array_object"), G.get("ANGLE_instanced_arrays")), G.get("OES_texture_float_linear"), oe = new WebGLUtils(le, G, k), j = new WebGLState(le, G, k), j.scissor(w.copy(O).multiplyScalar(P).floor()), j.viewport(A.copy(F).multiplyScalar(P).floor()), W = new WebGLInfo(le), H = new WebGLProperties, X = new WebGLTextures(le, G, j, H, k, oe, W), Y = new WebGLCubeMaps(f), q = new WebGLAttributes(le, k), se = new WebGLBindingStates(le, G, q, k), Q = new WebGLGeometries(le, q, W, se), J = new WebGLObjects(le, Q, q, W), ie = new WebGLMorphtargets(le), te = new WebGLClipping(H), Z = new WebGLPrograms(f, Y, G, k, se, te), K = new WebGLMaterials(H), $ = new WebGLRenderLists(H), ee = new WebGLRenderStates(G, k), ne = new WebGLBackground(f, Y, j, J, s), re = new WebGLBufferRenderer(le, G, W, k), ae = new WebGLIndexedBufferRenderer(le, G, W, k), W.programs = Z.programs, f.capabilities = k, f.extensions = G, f.properties = H, f.renderLists = $, f.state = j, f.info = W
                }

                function onContextLost(e) {
                    e.preventDefault(), m = !0
                }

                function onContextRestore() {
                    m = !1, initGLContext()
                }

                function onMaterialDispose(e) {
                    const t = e.target;
                    t.removeEventListener("dispose", onMaterialDispose),
                        function deallocateMaterial(e) {
                            releaseMaterialProgramReference(e), H.remove(e)
                        }(t)
                }

                function releaseMaterialProgramReference(e) {
                    const t = H.get(e).program;
                    void 0 !== t && Z.releaseProgram(t)
                }

                function projectObject(e, t, n, i) {
                    if (!1 === e.visible) return;
                    if (e.layers.test(t.layers))
                        if (e.isGroup) n = e.renderOrder;
                        else if (e.isLOD) !0 === e.autoUpdate && e.update(t);
                    else if (e.isLight) d.pushLight(e), e.castShadow && d.pushShadow(e);
                    else if (e.isSprite) {
                        if (!e.frustumCulled || R.intersectsSprite(e)) {
                            i && U.setFromMatrixPosition(e.matrixWorld).applyMatrix4(V);
                            const t = J.update(e),
                                r = e.material;
                            r.visible && h.push(e, t, r, n, U.z, null)
                        }
                    } else if (e.isImmediateRenderObject) i && U.setFromMatrixPosition(e.matrixWorld).applyMatrix4(V), h.push(e, null, e.material, n, U.z, null);
                    else if ((e.isMesh || e.isLine || e.isPoints) && (e.isSkinnedMesh && e.skeleton.frame !== W.render.frame && (e.skeleton.update(), e.skeleton.frame = W.render.frame), !e.frustumCulled || R.intersectsObject(e))) {
                        i && U.setFromMatrixPosition(e.matrixWorld).applyMatrix4(V);
                        const t = J.update(e),
                            r = e.material;
                        if (Array.isArray(r)) {
                            const i = t.groups;
                            for (let a = 0, o = i.length; a < o; a++) {
                                const o = i[a],
                                    s = r[o.materialIndex];
                                s && s.visible && h.push(e, t, s, n, U.z, o)
                            }
                        } else r.visible && h.push(e, t, r, n, U.z, null)
                    }
                    const r = e.children;
                    for (let e = 0, a = r.length; e < a; e++) projectObject(r[e], t, n, i)
                }

                function renderObjects(e, t, n) {
                    const i = !0 === t.isScene ? t.overrideMaterial : null;
                    for (let r = 0, a = e.length; r < a; r++) {
                        const a = e[r],
                            o = a.object,
                            s = a.geometry,
                            l = null === i ? a.material : i,
                            c = a.group;
                        if (n.isArrayCamera) {
                            const e = n.cameras;
                            for (let n = 0, i = e.length; n < i; n++) {
                                const i = e[n];
                                o.layers.test(i.layers) && (j.viewport(A.copy(i.viewport)), d.setupLightsView(i), renderObject(o, t, i, s, l, c))
                            }
                        } else renderObject(o, t, n, s, l, c)
                    }
                }

                function renderObject(e, t, n, i, r, a) {
                    if (e.onBeforeRender(f, t, n, i, r, a), e.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, e.matrixWorld), e.normalMatrix.getNormalMatrix(e.modelViewMatrix), e.isImmediateRenderObject) {
                        const i = setProgram(n, t, r, e);
                        j.setMaterial(r), se.reset(),
                            function renderObjectImmediate(e, t) {
                                e.render((function(e) {
                                    f.renderBufferImmediate(e, t)
                                }))
                            }(e, i)
                    } else f.renderBufferDirect(n, t, i, r, e, a);
                    e.onAfterRender(f, t, n, i, r, a)
                }

                function initMaterial(e, t, n) {
                    !0 !== t.isScene && (t = z);
                    const i = H.get(e),
                        r = d.state.lights,
                        a = d.state.shadowsArray,
                        o = r.state.version,
                        s = Z.getParameters(e, r.state, a, t, n),
                        l = Z.getProgramCacheKey(s);
                    let c = i.program,
                        u = !0;
                    if (void 0 === c) e.addEventListener("dispose", onMaterialDispose);
                    else if (c.cacheKey !== l) releaseMaterialProgramReference(e);
                    else if (i.lightsStateVersion !== o) u = !1;
                    else {
                        if (void 0 !== s.shaderID) {
                            const n = e.isMeshStandardMaterial ? t.environment : null;
                            return void(i.envMap = Y.get(e.envMap || n))
                        }
                        u = !1
                    }
                    u && (s.uniforms = Z.getUniforms(e), e.onBeforeCompile(s, f), c = Z.acquireProgram(s, l), i.program = c, i.uniforms = s.uniforms, i.outputEncoding = s.outputEncoding);
                    const h = i.uniforms;
                    (e.isShaderMaterial || e.isRawShaderMaterial) && !0 !== e.clipping || (i.numClippingPlanes = te.numPlanes, i.numIntersection = te.numIntersection, h.clippingPlanes = te.uniform), i.environment = e.isMeshStandardMaterial ? t.environment : null, i.fog = t.fog, i.envMap = Y.get(e.envMap || i.environment), i.needsLights = function materialNeedsLights(e) {
                        return e.isMeshLambertMaterial || e.isMeshToonMaterial || e.isMeshPhongMaterial || e.isMeshStandardMaterial || e.isShadowMaterial || e.isShaderMaterial && !0 === e.lights
                    }(e), i.lightsStateVersion = o, i.needsLights && (h.ambientLightColor.value = r.state.ambient, h.lightProbe.value = r.state.probe, h.directionalLights.value = r.state.directional, h.directionalLightShadows.value = r.state.directionalShadow, h.spotLights.value = r.state.spot, h.spotLightShadows.value = r.state.spotShadow, h.rectAreaLights.value = r.state.rectArea, h.ltc_1.value = r.state.rectAreaLTC1, h.ltc_2.value = r.state.rectAreaLTC2, h.pointLights.value = r.state.point, h.pointLightShadows.value = r.state.pointShadow, h.hemisphereLights.value = r.state.hemi, h.directionalShadowMap.value = r.state.directionalShadowMap, h.directionalShadowMatrix.value = r.state.directionalShadowMatrix, h.spotShadowMap.value = r.state.spotShadowMap, h.spotShadowMatrix.value = r.state.spotShadowMatrix, h.pointShadowMap.value = r.state.pointShadowMap, h.pointShadowMatrix.value = r.state.pointShadowMatrix);
                    const p = i.program.getUniforms(),
                        m = WebGLUniforms.seqWithValue(p.seq, h);
                    i.uniformsList = m
                }

                function setProgram(e, t, n, i) {
                    !0 !== t.isScene && (t = z), X.resetTextureUnits();
                    const r = t.fog,
                        a = n.isMeshStandardMaterial ? t.environment : null,
                        o = null === _ ? f.outputEncoding : _.texture.encoding,
                        s = Y.get(n.envMap || a),
                        l = H.get(n),
                        c = d.state.lights;
                    if (!0 === N && (!0 === D || e !== S)) {
                        const t = e === S && n.id === M;
                        te.setState(n, e, t)
                    }
                    n.version === l.__version ? n.fog && l.fog !== r || l.environment !== a || l.needsLights && l.lightsStateVersion !== c.state.version ? initMaterial(n, t, i) : void 0 === l.numClippingPlanes || l.numClippingPlanes === te.numPlanes && l.numIntersection === te.numIntersection ? (l.outputEncoding !== o || l.envMap !== s) && initMaterial(n, t, i) : initMaterial(n, t, i) : (initMaterial(n, t, i), l.__version = n.version);
                    let u = !1,
                        h = !1,
                        p = !1;
                    const m = l.program,
                        g = m.getUniforms(),
                        y = l.uniforms;
                    if (j.useProgram(m.program) && (u = !0, h = !0, p = !0), n.id !== M && (M = n.id, h = !0), u || S !== e) {
                        if (g.setValue(le, "projectionMatrix", e.projectionMatrix), k.logarithmicDepthBuffer && g.setValue(le, "logDepthBufFC", 2 / (Math.log(e.far + 1) / Math.LN2)), S !== e && (S = e, h = !0, p = !0), n.isShaderMaterial || n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshStandardMaterial || n.envMap) {
                            const t = g.map.cameraPosition;
                            void 0 !== t && t.setValue(le, U.setFromMatrixPosition(e.matrixWorld))
                        }(n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial) && g.setValue(le, "isOrthographic", !0 === e.isOrthographicCamera), (n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial || n.isShadowMaterial || n.skinning) && g.setValue(le, "viewMatrix", e.matrixWorldInverse)
                    }
                    if (n.skinning) {
                        g.setOptional(le, i, "bindMatrix"), g.setOptional(le, i, "bindMatrixInverse");
                        const e = i.skeleton;
                        if (e) {
                            const t = e.bones;
                            if (k.floatVertexTextures) {
                                if (null === e.boneTexture) {
                                    let n = Math.sqrt(4 * t.length);
                                    n = Fa.ceilPowerOfTwo(n), n = Math.max(n, 4);
                                    const i = new Float32Array(n * n * 4);
                                    i.set(e.boneMatrices);
                                    const r = new DataTexture(i, n, n, Oi, wi);
                                    e.boneMatrices = i, e.boneTexture = r, e.boneTextureSize = n
                                }
                                g.setValue(le, "boneTexture", e.boneTexture, X), g.setValue(le, "boneTextureSize", e.boneTextureSize)
                            } else g.setOptional(le, e, "boneMatrices")
                        }
                    }
                    return (h || l.receiveShadow !== i.receiveShadow) && (l.receiveShadow = i.receiveShadow, g.setValue(le, "receiveShadow", i.receiveShadow)), h && (g.setValue(le, "toneMappingExposure", f.toneMappingExposure), l.needsLights && function markUniformsLightsNeedsUpdate(e, t) {
                        e.ambientLightColor.needsUpdate = t, e.lightProbe.needsUpdate = t, e.directionalLights.needsUpdate = t, e.directionalLightShadows.needsUpdate = t, e.pointLights.needsUpdate = t, e.pointLightShadows.needsUpdate = t, e.spotLights.needsUpdate = t, e.spotLightShadows.needsUpdate = t, e.rectAreaLights.needsUpdate = t, e.hemisphereLights.needsUpdate = t
                    }(y, p), r && n.fog && K.refreshFogUniforms(y, r), K.refreshMaterialUniforms(y, n, P, C), WebGLUniforms.upload(le, l.uniformsList, y, X)), n.isShaderMaterial && !0 === n.uniformsNeedUpdate && (WebGLUniforms.upload(le, l.uniformsList, y, X), n.uniformsNeedUpdate = !1), n.isSpriteMaterial && g.setValue(le, "center", i.center), g.setValue(le, "modelViewMatrix", i.modelViewMatrix), g.setValue(le, "normalMatrix", i.normalMatrix), g.setValue(le, "modelMatrix", i.matrixWorld), m
                }
                const t = void 0 !== (e = e || {}).canvas ? e.canvas : function createCanvasElement() {
                        const e = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
                        return e.style.display = "block", e
                    }(),
                    n = void 0 !== e.context ? e.context : null,
                    i = void 0 !== e.alpha && e.alpha,
                    r = void 0 === e.depth || e.depth,
                    a = void 0 === e.stencil || e.stencil,
                    o = void 0 !== e.antialias && e.antialias,
                    s = void 0 === e.premultipliedAlpha || e.premultipliedAlpha,
                    l = void 0 !== e.preserveDrawingBuffer && e.preserveDrawingBuffer,
                    c = void 0 !== e.powerPreference ? e.powerPreference : "default",
                    u = void 0 !== e.failIfMajorPerformanceCaveat && e.failIfMajorPerformanceCaveat;
                let h = null,
                    d = null;
                const p = [];
                this.domElement = t, this.debug = {
                    checkShaderErrors: !0
                }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.gammaFactor = 2, this.outputEncoding = Hr, this.physicallyCorrectLights = !1, this.toneMapping = Yn, this.toneMappingExposure = 1, this.maxMorphTargets = 8, this.maxMorphNormals = 4;
                const f = this;
                let m = !1,
                    g = null,
                    y = 0,
                    x = 0,
                    _ = null,
                    b = null,
                    M = -1,
                    S = null;
                const A = new Vector4,
                    w = new Vector4;
                let T = null,
                    L = t.width,
                    C = t.height,
                    P = 1,
                    E = null,
                    I = null;
                const F = new Vector4(0, 0, L, C),
                    O = new Vector4(0, 0, L, C);
                let B = !1;
                const R = new Frustum;
                let N = !1,
                    D = !1;
                const V = new Matrix4,
                    U = new Vector3,
                    z = {
                        background: null,
                        fog: null,
                        environment: null,
                        overrideMaterial: null,
                        isScene: !0
                    };
                let G, k, j, W, H, X, Y, q, Q, J, Z, K, $, ee, te, ne, ie, re, ae, oe, se, le = n;
                try {
                    const e = {
                        alpha: i,
                        depth: r,
                        stencil: a,
                        antialias: o,
                        premultipliedAlpha: s,
                        preserveDrawingBuffer: l,
                        powerPreference: c,
                        failIfMajorPerformanceCaveat: u
                    };
                    if (t.addEventListener("webglcontextlost", onContextLost, !1), t.addEventListener("webglcontextrestored", onContextRestore, !1), null === le) {
                        const t = ["webgl2", "webgl", "experimental-webgl"];
                        if (!0 === f.isWebGL1Renderer && t.shift(), le = getContext(t, e), null === le) throw getContext(t) ? Error("Error creating WebGL context with your selected attributes.") : Error("Error creating WebGL context.")
                    }
                    void 0 === le.getShaderPrecisionFormat && (le.getShaderPrecisionFormat = function() {
                        return {
                            rangeMin: 1,
                            rangeMax: 1,
                            precision: 1
                        }
                    })
                } catch (e) {
                    throw e
                }
                initGLContext();
                const ce = new WebXRManager(f, le);
                this.xr = ce;
                const ue = new WebGLShadowMap(f, J, k.maxTextureSize);
                this.shadowMap = ue, this.getContext = function() {
                    return le
                }, this.getContextAttributes = function() {
                    return le.getContextAttributes()
                }, this.forceContextLoss = function() {
                    const e = G.get("WEBGL_lose_context");
                    e && e.loseContext()
                }, this.forceContextRestore = function() {
                    const e = G.get("WEBGL_lose_context");
                    e && e.restoreContext()
                }, this.getPixelRatio = function() {
                    return P
                }, this.setPixelRatio = function(e) {
                    void 0 !== e && (P = e, this.setSize(L, C, !1))
                }, this.getSize = function(e) {
                    return void 0 === e && (e = new Vector2), e.set(L, C)
                }, this.setSize = function(e, n, i) {
                    ce.isPresenting || (L = e, C = n, t.width = Math.floor(e * P), t.height = Math.floor(n * P), !1 !== i && (t.style.width = e + "px", t.style.height = n + "px"), this.setViewport(0, 0, e, n))
                }, this.getDrawingBufferSize = function(e) {
                    return void 0 === e && (e = new Vector2), e.set(L * P, C * P).floor()
                }, this.setDrawingBufferSize = function(e, n, i) {
                    L = e, C = n, P = i, t.width = Math.floor(e * i), t.height = Math.floor(n * i), this.setViewport(0, 0, e, n)
                }, this.getCurrentViewport = function(e) {
                    return void 0 === e && (e = new Vector4), e.copy(A)
                }, this.getViewport = function(e) {
                    return e.copy(F)
                }, this.setViewport = function(e, t, n, i) {
                    e.isVector4 ? F.set(e.x, e.y, e.z, e.w) : F.set(e, t, n, i), j.viewport(A.copy(F).multiplyScalar(P).floor())
                }, this.getScissor = function(e) {
                    return e.copy(O)
                }, this.setScissor = function(e, t, n, i) {
                    e.isVector4 ? O.set(e.x, e.y, e.z, e.w) : O.set(e, t, n, i), j.scissor(w.copy(O).multiplyScalar(P).floor())
                }, this.getScissorTest = function() {
                    return B
                }, this.setScissorTest = function(e) {
                    j.setScissorTest(B = e)
                }, this.setOpaqueSort = function(e) {
                    E = e
                }, this.setTransparentSort = function(e) {
                    I = e
                }, this.getClearColor = function(e) {
                    return void 0 === e && (e = new Color), e.copy(ne.getClearColor())
                }, this.setClearColor = function() {
                    ne.setClearColor.apply(ne, arguments)
                }, this.getClearAlpha = function() {
                    return ne.getClearAlpha()
                }, this.setClearAlpha = function() {
                    ne.setClearAlpha.apply(ne, arguments)
                }, this.clear = function(e, t, n) {
                    let i = 0;
                    (void 0 === e || e) && (i |= 16384), (void 0 === t || t) && (i |= 256), (void 0 === n || n) && (i |= 1024), le.clear(i)
                }, this.clearColor = function() {
                    this.clear(!0, !1, !1)
                }, this.clearDepth = function() {
                    this.clear(!1, !0, !1)
                }, this.clearStencil = function() {
                    this.clear(!1, !1, !0)
                }, this.dispose = function() {
                    t.removeEventListener("webglcontextlost", onContextLost, !1), t.removeEventListener("webglcontextrestored", onContextRestore, !1), $.dispose(), ee.dispose(), H.dispose(), Y.dispose(), J.dispose(), se.dispose(), ce.dispose(), de.stop()
                }, this.renderBufferImmediate = function(e, t) {
                    se.initAttributes();
                    const n = H.get(e);
                    e.hasPositions && !n.position && (n.position = le.createBuffer()), e.hasNormals && !n.normal && (n.normal = le.createBuffer()), e.hasUvs && !n.uv && (n.uv = le.createBuffer()), e.hasColors && !n.color && (n.color = le.createBuffer());
                    const i = t.getAttributes();
                    e.hasPositions && (le.bindBuffer(34962, n.position), le.bufferData(34962, e.positionArray, 35048), se.enableAttribute(i.position), le.vertexAttribPointer(i.position, 3, 5126, !1, 0, 0)), e.hasNormals && (le.bindBuffer(34962, n.normal), le.bufferData(34962, e.normalArray, 35048), se.enableAttribute(i.normal), le.vertexAttribPointer(i.normal, 3, 5126, !1, 0, 0)), e.hasUvs && (le.bindBuffer(34962, n.uv), le.bufferData(34962, e.uvArray, 35048), se.enableAttribute(i.uv), le.vertexAttribPointer(i.uv, 2, 5126, !1, 0, 0)), e.hasColors && (le.bindBuffer(34962, n.color), le.bufferData(34962, e.colorArray, 35048), se.enableAttribute(i.color), le.vertexAttribPointer(i.color, 3, 5126, !1, 0, 0)), se.disableUnusedAttributes(), le.drawArrays(4, 0, e.count), e.count = 0
                }, this.renderBufferDirect = function(e, t, n, i, r, a) {
                    null === t && (t = z);
                    const o = r.isMesh && r.matrixWorld.determinant() < 0,
                        s = setProgram(e, t, i, r);
                    j.setMaterial(i, o);
                    let l = n.index;
                    const c = n.attributes.position;
                    if (null === l) {
                        if (void 0 === c || 0 === c.count) return
                    } else if (0 === l.count) return;
                    let u, h = 1;
                    !0 === i.wireframe && (l = Q.getWireframeAttribute(n), h = 2), (i.morphTargets || i.morphNormals) && ie.update(r, n, i, s), se.setup(r, i, s, n, l);
                    let d = re;
                    null !== l && (u = q.get(l), d = ae, d.setIndex(u));
                    const p = null !== l ? l.count : c.count,
                        f = n.drawRange.start * h,
                        m = n.drawRange.count * h,
                        g = null !== a ? a.start * h : 0,
                        y = null !== a ? a.count * h : 1 / 0,
                        x = Math.max(f, g),
                        _ = Math.max(0, Math.min(p, f + m, g + y) - 1 - x + 1);
                    if (0 !== _) {
                        if (r.isMesh) !0 === i.wireframe ? (j.setLineWidth(i.wireframeLinewidth * getTargetPixelRatio()), d.setMode(1)) : d.setMode(4);
                        else if (r.isLine) {
                            let e = i.linewidth;
                            void 0 === e && (e = 1), j.setLineWidth(e * getTargetPixelRatio()), r.isLineSegments ? d.setMode(1) : r.isLineLoop ? d.setMode(2) : d.setMode(3)
                        } else r.isPoints ? d.setMode(0) : r.isSprite && d.setMode(4);
                        if (r.isInstancedMesh) d.renderInstances(x, _, r.count);
                        else if (n.isInstancedBufferGeometry) {
                            const e = Math.min(n.instanceCount, n._maxInstanceCount);
                            d.renderInstances(x, _, e)
                        } else d.render(x, _)
                    }
                }, this.compile = function(e, t) {
                    d = ee.get(e), d.init(), e.traverseVisible((function(e) {
                        e.isLight && e.layers.test(t.layers) && (d.pushLight(e), e.castShadow && d.pushShadow(e))
                    })), d.setupLights();
                    const n = new WeakMap;
                    e.traverse((function(t) {
                        const i = t.material;
                        if (i)
                            if (Array.isArray(i))
                                for (let r = 0; r < i.length; r++) {
                                    const a = i[r];
                                    !1 === n.has(a) && (initMaterial(a, e, t), n.set(a))
                                } else !1 === n.has(i) && (initMaterial(i, e, t), n.set(i))
                    }))
                };
                let he = null;
                const de = new WebGLAnimation;
                de.setAnimationLoop((function onAnimationFrame(e) {
                    ce.isPresenting || he && he(e)
                })), "undefined" != typeof window && de.setContext(window), this.setAnimationLoop = function(e) {
                    he = e, ce.setAnimationLoop(e), null === e ? de.stop() : de.start()
                }, this.render = function(e, t) {
                    let n, i;
                    if (void 0 !== arguments[2] && (n = arguments[2]), void 0 !== arguments[3] && (i = arguments[3]), void 0 !== t && !0 !== t.isCamera) return;
                    if (!0 === m) return;
                    se.resetDefaultState(), M = -1, S = null, !0 === e.autoUpdate && e.updateMatrixWorld(), null === t.parent && t.updateMatrixWorld(), !0 === ce.enabled && !0 === ce.isPresenting && (t = ce.getCamera(t)), !0 === e.isScene && e.onBeforeRender(f, e, t, n || _), d = ee.get(e, p.length), d.init(), p.push(d), V.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), R.setFromProjectionMatrix(V), D = this.localClippingEnabled, N = te.init(this.clippingPlanes, D, t), h = $.get(e, t), h.init(), projectObject(e, t, 0, f.sortObjects), h.finish(), !0 === f.sortObjects && h.sort(E, I), !0 === N && te.beginShadows();
                    const r = d.state.shadowsArray;
                    ue.render(r, e, t), d.setupLights(), d.setupLightsView(t), !0 === N && te.endShadows(), !0 === this.info.autoReset && this.info.reset(), void 0 !== n && this.setRenderTarget(n), ne.render(h, e, t, i);
                    const a = h.opaque,
                        o = h.transparent;
                    a.length > 0 && renderObjects(a, e, t), o.length > 0 && renderObjects(o, e, t), !0 === e.isScene && e.onAfterRender(f, e, t), null !== _ && (X.updateRenderTargetMipmap(_), X.updateMultisampleRenderTarget(_)), j.buffers.depth.setTest(!0), j.buffers.depth.setMask(!0), j.buffers.color.setMask(!0), j.setPolygonOffset(!1), p.pop(), d = p.length > 0 ? p[p.length - 1] : null, h = null
                }, this.setFramebuffer = function(e) {
                    g !== e && null === _ && le.bindFramebuffer(36160, e), g = e
                }, this.getActiveCubeFace = function() {
                    return y
                }, this.getActiveMipmapLevel = function() {
                    return x
                }, this.getRenderList = function() {
                    return h
                }, this.setRenderList = function(e) {
                    h = e
                }, this.getRenderTarget = function() {
                    return _
                }, this.setRenderTarget = function(e, t = 0, n = 0) {
                    _ = e, y = t, x = n, e && void 0 === H.get(e).__webglFramebuffer && X.setupRenderTarget(e);
                    let i = g,
                        r = !1;
                    if (e) {
                        const n = H.get(e).__webglFramebuffer;
                        e.isWebGLCubeRenderTarget ? (i = n[t], r = !0) : i = e.isWebGLMultisampleRenderTarget ? H.get(e).__webglMultisampledFramebuffer : n, A.copy(e.viewport), w.copy(e.scissor), T = e.scissorTest
                    } else A.copy(F).multiplyScalar(P).floor(), w.copy(O).multiplyScalar(P).floor(), T = B;
                    if (b !== i && (le.bindFramebuffer(36160, i), b = i), j.viewport(A), j.scissor(w), j.setScissorTest(T), r) {
                        const i = H.get(e.texture);
                        le.framebufferTexture2D(36160, 36064, 34069 + t, i.__webglTexture, n)
                    }
                }, this.readRenderTargetPixels = function(e, t, n, i, r, a, o) {
                    if (!e || !e.isWebGLRenderTarget) return;
                    let s = H.get(e).__webglFramebuffer;
                    if (e.isWebGLCubeRenderTarget && void 0 !== o && (s = s[o]), s) {
                        let o = !1;
                        s !== b && (le.bindFramebuffer(36160, s), o = !0);
                        try {
                            const s = e.texture,
                                l = s.format,
                                c = s.type;
                            if (l !== Oi && oe.convert(l) !== le.getParameter(35739)) return;
                            if (!(c === xi || oe.convert(c) === le.getParameter(35738) || c === wi && (k.isWebGL2 || G.get("OES_texture_float") || G.get("WEBGL_color_buffer_float")) || c === Ti && (k.isWebGL2 ? G.get("EXT_color_buffer_float") : G.get("EXT_color_buffer_half_float")))) return;
                            36053 === le.checkFramebufferStatus(36160) && t >= 0 && t <= e.width - i && n >= 0 && n <= e.height - r && le.readPixels(t, n, i, r, oe.convert(l), oe.convert(c), a)
                        } finally {
                            o && le.bindFramebuffer(36160, b)
                        }
                    }
                }, this.copyFramebufferToTexture = function(e, t, n = 0) {
                    const i = Math.pow(2, -n),
                        r = Math.floor(t.image.width * i),
                        a = Math.floor(t.image.height * i),
                        o = oe.convert(t.format);
                    X.setTexture2D(t, 0), le.copyTexImage2D(3553, n, o, e.x, e.y, r, a, 0), j.unbindTexture()
                }, this.copyTextureToTexture = function(e, t, n, i = 0) {
                    const r = t.image.width,
                        a = t.image.height,
                        o = oe.convert(n.format),
                        s = oe.convert(n.type);
                    X.setTexture2D(n, 0), le.pixelStorei(37440, n.flipY), le.pixelStorei(37441, n.premultiplyAlpha), le.pixelStorei(3317, n.unpackAlignment), t.isDataTexture ? le.texSubImage2D(3553, i, e.x, e.y, r, a, o, s, t.image.data) : t.isCompressedTexture ? le.compressedTexSubImage2D(3553, i, e.x, e.y, t.mipmaps[0].width, t.mipmaps[0].height, o, t.mipmaps[0].data) : le.texSubImage2D(3553, i, e.x, e.y, o, s, t.image), 0 === i && n.generateMipmaps && le.generateMipmap(3553), j.unbindTexture()
                }, this.initTexture = function(e) {
                    X.setTexture2D(e, 0), j.unbindTexture()
                }, this.resetState = function() {
                    j.reset(), se.reset()
                }, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
                    detail: this
                }))
            }

            function WebGL1Renderer(e) {
                WebGLRenderer.call(this, e)
            }

            function InterleavedBuffer(e, t) {
                this.array = e, this.stride = t, this.count = void 0 !== e ? e.length / t : 0, this.usage = xa, this.updateRange = {
                    offset: 0,
                    count: -1
                }, this.version = 0, this.uuid = Fa.generateUUID()
            }

            function InterleavedBufferAttribute(e, t, n, i) {
                this.name = "", this.data = e, this.itemSize = t, this.offset = n, this.normalized = !0 === i
            }

            function SpriteMaterial(e) {
                Material.call(this), this.type = "SpriteMaterial", this.color = new Color(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.setValues(e)
            }

            function Sprite(e) {
                if (Object3D.call(this), this.type = "Sprite", void 0 === Gs) {
                    Gs = new BufferGeometry;
                    const e = new InterleavedBuffer(new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]), 5);
                    Gs.setIndex([0, 1, 2, 0, 2, 3]), Gs.setAttribute("position", new InterleavedBufferAttribute(e, 3, 0, !1)), Gs.setAttribute("uv", new InterleavedBufferAttribute(e, 2, 3, !1))
                }
                this.geometry = Gs, this.material = void 0 !== e ? e : new SpriteMaterial, this.center = new Vector2(.5, .5)
            }

            function transformVertex(e, t, n, i, r, a) {
                Hs.subVectors(e, n).addScalar(.5).multiply(i), void 0 !== r ? (Xs.x = a * Hs.x - r * Hs.y, Xs.y = r * Hs.x + a * Hs.y) : Xs.copy(Hs), e.copy(t), e.x += Xs.x, e.y += Xs.y, e.applyMatrix4(Ys)
            }

            function LOD() {
                Object3D.call(this), this._currentLevel = 0, this.type = "LOD", Object.defineProperties(this, {
                    levels: {
                        enumerable: !0,
                        value: []
                    }
                }), this.autoUpdate = !0
            }

            function SkinnedMesh(e, t) {
                e && e.isGeometry, Mesh.call(this, e, t), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new Matrix4, this.bindMatrixInverse = new Matrix4
            }

            function Bone() {
                Object3D.call(this), this.type = "Bone"
            }

            function Skeleton(e = [], t = []) {
                this.uuid = Fa.generateUUID(), this.bones = e.slice(0), this.boneInverses = t, this.boneMatrices = null, this.boneTexture = null, this.boneTextureSize = 0, this.frame = -1, this.init()
            }

            function InstancedMesh(e, t, n) {
                Mesh.call(this, e, t), this.instanceMatrix = new BufferAttribute(new Float32Array(16 * n), 16), this.instanceColor = null, this.count = n, this.frustumCulled = !1
            }

            function LineBasicMaterial(e) {
                Material.call(this), this.type = "LineBasicMaterial", this.color = new Color(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.morphTargets = !1, this.setValues(e)
            }

            function Line(e = new BufferGeometry, t = new LineBasicMaterial) {
                Object3D.call(this), this.type = "Line", this.geometry = e, this.material = t, this.updateMorphTargets()
            }

            function LineSegments(e, t) {
                Line.call(this, e, t), this.type = "LineSegments"
            }

            function LineLoop(e, t) {
                Line.call(this, e, t), this.type = "LineLoop"
            }

            function PointsMaterial(e) {
                Material.call(this), this.type = "PointsMaterial", this.color = new Color(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.morphTargets = !1, this.setValues(e)
            }

            function Points(e = new BufferGeometry, t = new PointsMaterial) {
                Object3D.call(this), this.type = "Points", this.geometry = e, this.material = t, this.updateMorphTargets()
            }

            function testPoint(e, t, n, i, r, a, o) {
                const s = bl.distanceSqToPoint(e);
                if (s < n) {
                    const n = new Vector3;
                    bl.closestPointToPoint(e, n), n.applyMatrix4(i);
                    const l = r.ray.origin.distanceTo(n);
                    if (l < r.near || l > r.far) return;
                    a.push({
                        distance: l,
                        distanceToRay: Math.sqrt(s),
                        point: n,
                        index: t,
                        face: null,
                        object: o
                    })
                }
            }

            function VideoTexture(e, t, n, i, r, a, o, s, l) {
                Texture.call(this, e, t, n, i, r, a, o, s, l), this.format = void 0 !== o ? o : Fi, this.minFilter = void 0 !== a ? a : fi, this.magFilter = void 0 !== r ? r : fi, this.generateMipmaps = !1;
                const c = this;
                "requestVideoFrameCallback" in e && e.requestVideoFrameCallback((function updateVideo() {
                    c.needsUpdate = !0, e.requestVideoFrameCallback(updateVideo)
                }))
            }

            function CompressedTexture(e, t, n, i, r, a, o, s, l, c, u, h) {
                Texture.call(this, null, a, o, s, l, c, i, r, u, h), this.image = {
                    width: t,
                    height: n
                }, this.mipmaps = e, this.flipY = !1, this.generateMipmaps = !1
            }

            function CanvasTexture(e, t, n, i, r, a, o, s, l) {
                Texture.call(this, e, t, n, i, r, a, o, s, l), this.needsUpdate = !0
            }

            function DepthTexture(e, t, n, i, r, a, o, s, l, c) {
                if ((c = void 0 !== c ? c : Di) !== Di && c !== Vi) throw Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
                void 0 === n && c === Di && (n = Mi), void 0 === n && c === Vi && (n = Ei), Texture.call(this, null, i, r, a, o, s, c, n, l), this.image = {
                    width: e,
                    height: t
                }, this.magFilter = void 0 !== o ? o : ci, this.minFilter = void 0 !== s ? s : ci, this.flipY = !1, this.generateMipmaps = !1
            }

            function Geometry() {
                Object.defineProperty(this, "id", {
                    value: Al += 2
                }), this.uuid = Fa.generateUUID(), this.name = "", this.type = "Geometry", this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [
                    []
                ], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.elementsNeedUpdate = !1, this.verticesNeedUpdate = !1, this.uvsNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.lineDistancesNeedUpdate = !1, this.groupsNeedUpdate = !1
            }

            function linkedList(e, t, n, i, r) {
                let a, o;
                if (r === function signedArea(e, t, n, i) {
                        let r = 0;
                        for (let a = t, o = n - i; a < n; a += i) r += (e[o] - e[a]) * (e[a + 1] + e[o + 1]), o = a;
                        return r
                    }(e, t, n, i) > 0)
                    for (a = t; a < n; a += i) o = insertNode(a, e[a], e[a + 1], o);
                else
                    for (a = n - i; a >= t; a -= i) o = insertNode(a, e[a], e[a + 1], o);
                return o && equals(o, o.next) && (removeNode(o), o = o.next), o
            }

            function filterPoints(e, t) {
                if (!e) return e;
                t || (t = e);
                let n, i = e;
                do {
                    if (n = !1, i.steiner || !equals(i, i.next) && 0 !== three_module_area(i.prev, i, i.next)) i = i.next;
                    else {
                        if (removeNode(i), i = t = i.prev, i === i.next) break;
                        n = !0
                    }
                } while (n || i !== t);
                return t
            }

            function earcutLinked(e, t, n, i, r, a, o) {
                if (!e) return;
                !o && a && function indexCurve(e, t, n, i) {
                    let r = e;
                    do {
                        null === r.z && (r.z = zOrder(r.x, r.y, t, n, i)), r.prevZ = r.prev, r.nextZ = r.next, r = r.next
                    } while (r !== e);
                    r.prevZ.nextZ = null, r.prevZ = null,
                        function sortLinked(e) {
                            let t, n, i, r, a, o, s, l, c = 1;
                            do {
                                for (n = e, e = null, a = null, o = 0; n;) {
                                    for (o++, i = n, s = 0, t = 0; t < c && (s++, i = i.nextZ, i); t++);
                                    for (l = c; s > 0 || l > 0 && i;) 0 !== s && (0 === l || !i || n.z <= i.z) ? (r = n, n = n.nextZ, s--) : (r = i, i = i.nextZ, l--), a ? a.nextZ = r : e = r, r.prevZ = a, a = r;
                                    n = i
                                }
                                a.nextZ = null, c *= 2
                            } while (o > 1);
                            return e
                        }(r)
                }(e, i, r, a);
                let s, l, c = e;
                for (; e.prev !== e.next;)
                    if (s = e.prev, l = e.next, a ? isEarHashed(e, i, r, a) : isEar(e)) t.push(s.i / n), t.push(e.i / n), t.push(l.i / n), removeNode(e), e = l.next, c = l.next;
                    else if ((e = l) === c) {
                    o ? 1 === o ? earcutLinked(e = cureLocalIntersections(filterPoints(e), t, n), t, n, i, r, a, 2) : 2 === o && splitEarcut(e, t, n, i, r, a) : earcutLinked(filterPoints(e), t, n, i, r, a, 1);
                    break
                }
            }

            function isEar(e) {
                const t = e.prev,
                    n = e,
                    i = e.next;
                if (three_module_area(t, n, i) >= 0) return !1;
                let r = e.next.next;
                for (; r !== e.prev;) {
                    if (pointInTriangle(t.x, t.y, n.x, n.y, i.x, i.y, r.x, r.y) && three_module_area(r.prev, r, r.next) >= 0) return !1;
                    r = r.next
                }
                return !0
            }

            function isEarHashed(e, t, n, i) {
                const r = e.prev,
                    a = e,
                    o = e.next;
                if (three_module_area(r, a, o) >= 0) return !1;
                const s = r.x < a.x ? r.x < o.x ? r.x : o.x : a.x < o.x ? a.x : o.x,
                    l = r.y < a.y ? r.y < o.y ? r.y : o.y : a.y < o.y ? a.y : o.y,
                    c = r.x > a.x ? r.x > o.x ? r.x : o.x : a.x > o.x ? a.x : o.x,
                    u = r.y > a.y ? r.y > o.y ? r.y : o.y : a.y > o.y ? a.y : o.y,
                    h = zOrder(s, l, t, n, i),
                    d = zOrder(c, u, t, n, i);
                let p = e.prevZ,
                    f = e.nextZ;
                for (; p && p.z >= h && f && f.z <= d;) {
                    if (p !== e.prev && p !== e.next && pointInTriangle(r.x, r.y, a.x, a.y, o.x, o.y, p.x, p.y) && three_module_area(p.prev, p, p.next) >= 0) return !1;
                    if (p = p.prevZ, f !== e.prev && f !== e.next && pointInTriangle(r.x, r.y, a.x, a.y, o.x, o.y, f.x, f.y) && three_module_area(f.prev, f, f.next) >= 0) return !1;
                    f = f.nextZ
                }
                for (; p && p.z >= h;) {
                    if (p !== e.prev && p !== e.next && pointInTriangle(r.x, r.y, a.x, a.y, o.x, o.y, p.x, p.y) && three_module_area(p.prev, p, p.next) >= 0) return !1;
                    p = p.prevZ
                }
                for (; f && f.z <= d;) {
                    if (f !== e.prev && f !== e.next && pointInTriangle(r.x, r.y, a.x, a.y, o.x, o.y, f.x, f.y) && three_module_area(f.prev, f, f.next) >= 0) return !1;
                    f = f.nextZ
                }
                return !0
            }

            function cureLocalIntersections(e, t, n) {
                let i = e;
                do {
                    const r = i.prev,
                        a = i.next.next;
                    !equals(r, a) && intersects(r, i, i.next, a) && locallyInside(r, a) && locallyInside(a, r) && (t.push(r.i / n), t.push(i.i / n), t.push(a.i / n), removeNode(i), removeNode(i.next), i = e = a), i = i.next
                } while (i !== e);
                return filterPoints(i)
            }

            function splitEarcut(e, t, n, i, r, a) {
                let o = e;
                do {
                    let e = o.next.next;
                    for (; e !== o.prev;) {
                        if (o.i !== e.i && isValidDiagonal(o, e)) {
                            let s = splitPolygon(o, e);
                            return o = filterPoints(o, o.next), s = filterPoints(s, s.next), earcutLinked(o, t, n, i, r, a), void earcutLinked(s, t, n, i, r, a)
                        }
                        e = e.next
                    }
                    o = o.next
                } while (o !== e)
            }

            function compareX(e, t) {
                return e.x - t.x
            }

            function eliminateHole(e, t) {
                if (t = function findHoleBridge(e, t) {
                        let n = t;
                        const i = e.x,
                            r = e.y;
                        let a, o = -1 / 0;
                        do {
                            if (r <= n.y && r >= n.next.y && n.next.y !== n.y) {
                                const e = n.x + (r - n.y) * (n.next.x - n.x) / (n.next.y - n.y);
                                if (e <= i && e > o) {
                                    if (o = e, e === i) {
                                        if (r === n.y) return n;
                                        if (r === n.next.y) return n.next
                                    }
                                    a = n.x < n.next.x ? n : n.next
                                }
                            }
                            n = n.next
                        } while (n !== t);
                        if (!a) return null;
                        if (i === o) return a;
                        const s = a,
                            l = a.x,
                            c = a.y;
                        let u, h = 1 / 0;
                        n = a;
                        do {
                            i >= n.x && n.x >= l && i !== n.x && pointInTriangle(r < c ? i : o, r, l, c, r < c ? o : i, r, n.x, n.y) && (u = Math.abs(r - n.y) / (i - n.x), locallyInside(n, e) && (u < h || u === h && (n.x > a.x || n.x === a.x && sectorContainsSector(a, n))) && (a = n, h = u)), n = n.next
                        } while (n !== s);
                        return a
                    }(e, t), t) {
                    const n = splitPolygon(t, e);
                    filterPoints(t, t.next), filterPoints(n, n.next)
                }
            }

            function sectorContainsSector(e, t) {
                return three_module_area(e.prev, e, t.prev) < 0 && three_module_area(t.next, e, e.next) < 0
            }

            function zOrder(e, t, n, i, r) {
                return (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - n) * r) | e << 8)) | e << 4)) | e << 2)) | e << 1)) | (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - i) * r) | t << 8)) | t << 4)) | t << 2)) | t << 1)) << 1
            }

            function getLeftmost(e) {
                let t = e,
                    n = e;
                do {
                    (t.x < n.x || t.x === n.x && t.y < n.y) && (n = t), t = t.next
                } while (t !== e);
                return n
            }

            function pointInTriangle(e, t, n, i, r, a, o, s) {
                return (r - o) * (t - s) - (e - o) * (a - s) >= 0 && (e - o) * (i - s) - (n - o) * (t - s) >= 0 && (n - o) * (a - s) - (r - o) * (i - s) >= 0
            }

            function isValidDiagonal(e, t) {
                return e.next.i !== t.i && e.prev.i !== t.i && ! function intersectsPolygon(e, t) {
                    let n = e;
                    do {
                        if (n.i !== e.i && n.next.i !== e.i && n.i !== t.i && n.next.i !== t.i && intersects(n, n.next, e, t)) return !0;
                        n = n.next
                    } while (n !== e);
                    return !1
                }(e, t) && (locallyInside(e, t) && locallyInside(t, e) && function middleInside(e, t) {
                    let n = e,
                        i = !1;
                    const r = (e.x + t.x) / 2,
                        a = (e.y + t.y) / 2;
                    do {
                        n.y > a != n.next.y > a && n.next.y !== n.y && r < (n.next.x - n.x) * (a - n.y) / (n.next.y - n.y) + n.x && (i = !i), n = n.next
                    } while (n !== e);
                    return i
                }(e, t) && (three_module_area(e.prev, e, t.prev) || three_module_area(e, t.prev, t)) || equals(e, t) && three_module_area(e.prev, e, e.next) > 0 && three_module_area(t.prev, t, t.next) > 0)
            }

            function three_module_area(e, t, n) {
                return (t.y - e.y) * (n.x - t.x) - (t.x - e.x) * (n.y - t.y)
            }

            function equals(e, t) {
                return e.x === t.x && e.y === t.y
            }

            function intersects(e, t, n, i) {
                const r = sign(three_module_area(e, t, n)),
                    a = sign(three_module_area(e, t, i)),
                    o = sign(three_module_area(n, i, e)),
                    s = sign(three_module_area(n, i, t));
                return r !== a && o !== s || (!(0 !== r || !onSegment(e, n, t)) || (!(0 !== a || !onSegment(e, i, t)) || (!(0 !== o || !onSegment(n, e, i)) || !(0 !== s || !onSegment(n, t, i)))))
            }

            function onSegment(e, t, n) {
                return t.x <= Math.max(e.x, n.x) && t.x >= Math.min(e.x, n.x) && t.y <= Math.max(e.y, n.y) && t.y >= Math.min(e.y, n.y)
            }

            function sign(e) {
                return e > 0 ? 1 : e < 0 ? -1 : 0
            }

            function locallyInside(e, t) {
                return three_module_area(e.prev, e, e.next) < 0 ? three_module_area(e, t, e.next) >= 0 && three_module_area(e, e.prev, t) >= 0 : three_module_area(e, t, e.prev) < 0 || three_module_area(e, e.next, t) < 0
            }

            function splitPolygon(e, t) {
                const n = new Node(e.i, e.x, e.y),
                    i = new Node(t.i, t.x, t.y),
                    r = e.next,
                    a = t.prev;
                return e.next = t, t.prev = e, n.next = r, r.prev = n, i.next = n, n.prev = i, a.next = i, i.prev = a, i
            }

            function insertNode(e, t, n, i) {
                const r = new Node(e, t, n);
                return i ? (r.next = i.next, r.prev = i, i.next.prev = r, i.next = r) : (r.prev = r, r.next = r), r
            }

            function removeNode(e) {
                e.next.prev = e.prev, e.prev.next = e.next, e.prevZ && (e.prevZ.nextZ = e.nextZ), e.nextZ && (e.nextZ.prevZ = e.prevZ)
            }

            function Node(e, t, n) {
                this.i = e, this.x = t, this.y = n, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1
            }

            function removeDupEndPts(e) {
                const t = e.length;
                t > 2 && e[t - 1].equals(e[0]) && e.pop()
            }

            function addContour(e, t) {
                for (let n = 0; n < t.length; n++) e.push(t[n].x), e.push(t[n].y)
            }

            function ParametricBufferGeometry(e, t, n) {
                BufferGeometry.call(this), this.type = "ParametricBufferGeometry", this.parameters = {
                    func: e,
                    slices: t,
                    stacks: n
                };
                const i = [],
                    r = [],
                    a = [],
                    o = [],
                    s = 1e-5,
                    l = new Vector3,
                    c = new Vector3,
                    u = new Vector3,
                    h = new Vector3,
                    d = new Vector3;
                e.length;
                const p = t + 1;
                for (let i = 0; i <= n; i++) {
                    const p = i / n;
                    for (let n = 0; n <= t; n++) {
                        const i = n / t;
                        e(i, p, c), r.push(c.x, c.y, c.z), i - s >= 0 ? (e(i - s, p, u), h.subVectors(c, u)) : (e(i + s, p, u), h.subVectors(u, c)), p - s >= 0 ? (e(i, p - s, u), d.subVectors(c, u)) : (e(i, p + s, u), d.subVectors(u, c)), l.crossVectors(h, d).normalize(), a.push(l.x, l.y, l.z), o.push(i, p)
                    }
                }
                for (let e = 0; e < n; e++)
                    for (let n = 0; n < t; n++) {
                        const t = e * p + n,
                            r = e * p + n + 1,
                            a = (e + 1) * p + n + 1,
                            o = (e + 1) * p + n;
                        i.push(t, r, o), i.push(r, a, o)
                    }
                this.setIndex(i), this.setAttribute("position", new Float32BufferAttribute(r, 3)), this.setAttribute("normal", new Float32BufferAttribute(a, 3)), this.setAttribute("uv", new Float32BufferAttribute(o, 2))
            }

            function ParametricGeometry(e, t, n) {
                Geometry.call(this), this.type = "ParametricGeometry", this.parameters = {
                    func: e,
                    slices: t,
                    stacks: n
                }, this.fromBufferGeometry(new ParametricBufferGeometry(e, t, n)), this.mergeVertices()
            }

            function ShadowMaterial(e) {
                Material.call(this), this.type = "ShadowMaterial", this.color = new Color(0), this.transparent = !0, this.setValues(e)
            }

            function RawShaderMaterial(e) {
                ShaderMaterial.call(this, e), this.type = "RawShaderMaterial"
            }

            function MeshStandardMaterial(e) {
                Material.call(this), this.defines = {
                    STANDARD: ""
                }, this.type = "MeshStandardMaterial", this.color = new Color(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Color(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = ta, this.normalScale = new Vector2(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.vertexTangents = !1, this.setValues(e)
            }

            function MeshPhysicalMaterial(e) {
                MeshStandardMaterial.call(this), this.defines = {
                    STANDARD: "",
                    PHYSICAL: ""
                }, this.type = "MeshPhysicalMaterial", this.clearcoat = 0, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new Vector2(1, 1), this.clearcoatNormalMap = null, this.reflectivity = .5, Object.defineProperty(this, "ior", {
                    get: function() {
                        return (1 + .4 * this.reflectivity) / (1 - .4 * this.reflectivity)
                    },
                    set: function(e) {
                        this.reflectivity = Fa.clamp(2.5 * (e - 1) / (e + 1), 0, 1)
                    }
                }), this.sheen = null, this.transmission = 0, this.transmissionMap = null, this.setValues(e)
            }

            function MeshPhongMaterial(e) {
                Material.call(this), this.type = "MeshPhongMaterial", this.color = new Color(16777215), this.specular = new Color(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Color(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = ta, this.normalScale = new Vector2(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = Wn, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(e)
            }

            function MeshToonMaterial(e) {
                Material.call(this), this.defines = {
                    TOON: ""
                }, this.type = "MeshToonMaterial", this.color = new Color(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Color(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = ta, this.normalScale = new Vector2(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(e)
            }

            function MeshNormalMaterial(e) {
                Material.call(this), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = ta, this.normalScale = new Vector2(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(e)
            }

            function MeshLambertMaterial(e) {
                Material.call(this), this.type = "MeshLambertMaterial", this.color = new Color(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Color(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = Wn, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(e)
            }

            function MeshMatcapMaterial(e) {
                Material.call(this), this.defines = {
                    MATCAP: ""
                }, this.type = "MeshMatcapMaterial", this.color = new Color(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = ta, this.normalScale = new Vector2(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(e)
            }

            function LineDashedMaterial(e) {
                LineBasicMaterial.call(this), this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(e)
            }

            function Interpolant(e, t, n, i) {
                this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = void 0 !== i ? i : new t.constructor(n), this.sampleValues = t, this.valueSize = n
            }

            function CubicInterpolant(e, t, n, i) {
                Interpolant.call(this, e, t, n, i), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0
            }

            function LinearInterpolant(e, t, n, i) {
                Interpolant.call(this, e, t, n, i)
            }

            function DiscreteInterpolant(e, t, n, i) {
                Interpolant.call(this, e, t, n, i)
            }

            function KeyframeTrack(e, t, n, i) {
                if (void 0 === e) throw Error("THREE.KeyframeTrack: track name is undefined");
                if (void 0 === t || 0 === t.length) throw Error("THREE.KeyframeTrack: no keyframes in track named " + e);
                this.name = e, this.times = Bl.convertArray(t, this.TimeBufferType), this.values = Bl.convertArray(n, this.ValueBufferType), this.setInterpolation(i || this.DefaultInterpolation)
            }

            function BooleanKeyframeTrack(e, t, n) {
                KeyframeTrack.call(this, e, t, n)
            }

            function ColorKeyframeTrack(e, t, n, i) {
                KeyframeTrack.call(this, e, t, n, i)
            }

            function NumberKeyframeTrack(e, t, n, i) {
                KeyframeTrack.call(this, e, t, n, i)
            }

            function QuaternionLinearInterpolant(e, t, n, i) {
                Interpolant.call(this, e, t, n, i)
            }

            function QuaternionKeyframeTrack(e, t, n, i) {
                KeyframeTrack.call(this, e, t, n, i)
            }

            function StringKeyframeTrack(e, t, n, i) {
                KeyframeTrack.call(this, e, t, n, i)
            }

            function VectorKeyframeTrack(e, t, n, i) {
                KeyframeTrack.call(this, e, t, n, i)
            }

            function AnimationClip(e, t = -1, n, i = zr) {
                this.name = e, this.tracks = n, this.duration = t, this.blendMode = i, this.uuid = Fa.generateUUID(), this.duration < 0 && this.resetDuration()
            }

            function parseKeyframeTrack(e) {
                if (void 0 === e.type) throw Error("THREE.KeyframeTrack: track type undefined, can not parse");
                const t = function getTrackTypeForValueTypeName(e) {
                    switch (e.toLowerCase()) {
                        case "scalar":
                        case "double":
                        case "float":
                        case "number":
                        case "integer":
                            return NumberKeyframeTrack;
                        case "vector":
                        case "vector2":
                        case "vector3":
                        case "vector4":
                            return VectorKeyframeTrack;
                        case "color":
                            return ColorKeyframeTrack;
                        case "quaternion":
                            return QuaternionKeyframeTrack;
                        case "bool":
                        case "boolean":
                            return BooleanKeyframeTrack;
                        case "string":
                            return StringKeyframeTrack
                    }
                    throw Error("THREE.KeyframeTrack: Unsupported typeName: " + e)
                }(e.type);
                if (void 0 === e.times) {
                    const t = [],
                        n = [];
                    Bl.flattenJSON(e.keys, t, n, "value"), e.times = t, e.values = n
                }
                return void 0 !== t.parse ? t.parse(e) : new t(e.name, e.times, e.values, e.interpolation)
            }

            function LoadingManager(e, t, n) {
                const i = this;
                let r, a = !1,
                    o = 0,
                    s = 0;
                const l = [];
                this.onStart = void 0, this.onLoad = e, this.onProgress = t, this.onError = n, this.itemStart = function(e) {
                    s++, !1 === a && void 0 !== i.onStart && i.onStart(e, o, s), a = !0
                }, this.itemEnd = function(e) {
                    o++, void 0 !== i.onProgress && i.onProgress(e, o, s), o === s && (a = !1, void 0 !== i.onLoad && i.onLoad())
                }, this.itemError = function(e) {
                    void 0 !== i.onError && i.onError(e)
                }, this.resolveURL = function(e) {
                    return r ? r(e) : e
                }, this.setURLModifier = function(e) {
                    return r = e, this
                }, this.addHandler = function(e, t) {
                    return l.push(e, t), this
                }, this.removeHandler = function(e) {
                    const t = l.indexOf(e);
                    return -1 !== t && l.splice(t, 2), this
                }, this.getHandler = function(e) {
                    for (let t = 0, n = l.length; t < n; t += 2) {
                        const n = l[t],
                            i = l[t + 1];
                        if (n.global && (n.lastIndex = 0), n.test(e)) return i
                    }
                    return null
                }
            }

            function Loader(e) {
                this.manager = void 0 !== e ? e : Nl, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {}
            }

            function FileLoader(e) {
                Loader.call(this, e)
            }

            function AnimationLoader(e) {
                Loader.call(this, e)
            }

            function CompressedTextureLoader(e) {
                Loader.call(this, e)
            }

            function ImageLoader(e) {
                Loader.call(this, e)
            }

            function CubeTextureLoader(e) {
                Loader.call(this, e)
            }

            function DataTextureLoader(e) {
                Loader.call(this, e)
            }

            function TextureLoader(e) {
                Loader.call(this, e)
            }

            function Curve() {
                this.type = "Curve", this.arcLengthDivisions = 200
            }

            function EllipseCurve(e, t, n, i, r, a, o, s) {
                Curve.call(this), this.type = "EllipseCurve", this.aX = e || 0, this.aY = t || 0, this.xRadius = n || 1, this.yRadius = i || 1, this.aStartAngle = r || 0, this.aEndAngle = a || 2 * Math.PI, this.aClockwise = o || !1, this.aRotation = s || 0
            }

            function ArcCurve(e, t, n, i, r, a) {
                EllipseCurve.call(this, e, t, n, n, i, r, a), this.type = "ArcCurve"
            }

            function CubicPoly() {
                function init(r, a, o, s) {
                    e = r, t = o, n = -3 * r + 3 * a - 2 * o - s, i = 2 * r - 2 * a + o + s
                }
                let e = 0,
                    t = 0,
                    n = 0,
                    i = 0;
                return {
                    initCatmullRom: function(e, t, n, i, r) {
                        init(t, n, r * (n - e), r * (i - t))
                    },
                    initNonuniformCatmullRom: function(e, t, n, i, r, a, o) {
                        let s = (t - e) / r - (n - e) / (r + a) + (n - t) / a,
                            l = (n - t) / a - (i - t) / (a + o) + (i - n) / o;
                        s *= a, l *= a, init(t, n, s, l)
                    },
                    calc: function(r) {
                        const a = r * r;
                        return e + t * r + n * a + i * (a * r)
                    }
                }
            }

            function CatmullRomCurve3(e = [], t = !1, n = "centripetal", i = .5) {
                Curve.call(this), this.type = "CatmullRomCurve3", this.points = e, this.closed = t, this.curveType = n, this.tension = i
            }

            function CatmullRom(e, t, n, i, r) {
                const a = .5 * (i - t),
                    o = .5 * (r - n),
                    s = e * e;
                return (2 * n - 2 * i + a + o) * (e * s) + (-3 * n + 3 * i - 2 * a - o) * s + a * e + n
            }

            function QuadraticBezier(e, t, n, i) {
                return function QuadraticBezierP0(e, t) {
                    const n = 1 - e;
                    return n * n * t
                }(e, t) + function QuadraticBezierP1(e, t) {
                    return 2 * (1 - e) * e * t
                }(e, n) + function QuadraticBezierP2(e, t) {
                    return e * e * t
                }(e, i)
            }

            function CubicBezier(e, t, n, i, r) {
                return function CubicBezierP0(e, t) {
                    const n = 1 - e;
                    return n * n * n * t
                }(e, t) + function CubicBezierP1(e, t) {
                    const n = 1 - e;
                    return 3 * n * n * e * t
                }(e, n) + function CubicBezierP2(e, t) {
                    return 3 * (1 - e) * e * e * t
                }(e, i) + function CubicBezierP3(e, t) {
                    return e * e * e * t
                }(e, r)
            }

            function CubicBezierCurve(e = new Vector2, t = new Vector2, n = new Vector2, i = new Vector2) {
                Curve.call(this), this.type = "CubicBezierCurve", this.v0 = e, this.v1 = t, this.v2 = n, this.v3 = i
            }

            function CubicBezierCurve3(e = new Vector3, t = new Vector3, n = new Vector3, i = new Vector3) {
                Curve.call(this), this.type = "CubicBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = n, this.v3 = i
            }

            function LineCurve(e = new Vector2, t = new Vector2) {
                Curve.call(this), this.type = "LineCurve", this.v1 = e, this.v2 = t
            }

            function LineCurve3(e = new Vector3, t = new Vector3) {
                Curve.call(this), this.type = "LineCurve3", this.v1 = e, this.v2 = t
            }

            function QuadraticBezierCurve(e = new Vector2, t = new Vector2, n = new Vector2) {
                Curve.call(this), this.type = "QuadraticBezierCurve", this.v0 = e, this.v1 = t, this.v2 = n
            }

            function QuadraticBezierCurve3(e = new Vector3, t = new Vector3, n = new Vector3) {
                Curve.call(this), this.type = "QuadraticBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = n
            }

            function SplineCurve(e = []) {
                Curve.call(this), this.type = "SplineCurve", this.points = e
            }

            function CurvePath() {
                Curve.call(this), this.type = "CurvePath", this.curves = [], this.autoClose = !1
            }

            function Path(e) {
                CurvePath.call(this), this.type = "Path", this.currentPoint = new Vector2, e && this.setFromPoints(e)
            }

            function Shape(e) {
                Path.call(this, e), this.uuid = Fa.generateUUID(), this.type = "Shape", this.holes = []
            }

            function Light(e, t = 1) {
                Object3D.call(this), this.type = "Light", this.color = new Color(e), this.intensity = t
            }

            function HemisphereLight(e, t, n) {
                Light.call(this, e, n), this.type = "HemisphereLight", this.position.copy(Object3D.DefaultUp), this.updateMatrix(), this.groundColor = new Color(t)
            }

            function LightShadow(e) {
                this.camera = e, this.bias = 0, this.normalBias = 0, this.radius = 1, this.mapSize = new Vector2(512, 512), this.map = null, this.mapPass = null, this.matrix = new Matrix4, this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new Frustum, this._frameExtents = new Vector2(1, 1), this._viewportCount = 1, this._viewports = [new Vector4(0, 0, 1, 1)]
            }

            function SpotLightShadow() {
                LightShadow.call(this, new PerspectiveCamera(50, 1, .5, 500)), this.focus = 1
            }

            function SpotLight(e, t, n, i, r, a) {
                Light.call(this, e, t), this.type = "SpotLight", this.position.copy(Object3D.DefaultUp), this.updateMatrix(), this.target = new Object3D, Object.defineProperty(this, "power", {
                    get: function() {
                        return this.intensity * Math.PI
                    },
                    set: function(e) {
                        this.intensity = e / Math.PI
                    }
                }), this.distance = void 0 !== n ? n : 0, this.angle = void 0 !== i ? i : Math.PI / 3, this.penumbra = void 0 !== r ? r : 0, this.decay = void 0 !== a ? a : 1, this.shadow = new SpotLightShadow
            }

            function PointLightShadow() {
                LightShadow.call(this, new PerspectiveCamera(90, 1, .5, 500)), this._frameExtents = new Vector2(4, 2), this._viewportCount = 6, this._viewports = [new Vector4(2, 1, 1, 1), new Vector4(0, 1, 1, 1), new Vector4(3, 1, 1, 1), new Vector4(1, 1, 1, 1), new Vector4(3, 0, 1, 1), new Vector4(1, 0, 1, 1)], this._cubeDirections = [new Vector3(1, 0, 0), new Vector3(-1, 0, 0), new Vector3(0, 0, 1), new Vector3(0, 0, -1), new Vector3(0, 1, 0), new Vector3(0, -1, 0)], this._cubeUps = [new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 0, 1), new Vector3(0, 0, -1)]
            }

            function PointLight(e, t, n, i) {
                Light.call(this, e, t), this.type = "PointLight", Object.defineProperty(this, "power", {
                    get: function() {
                        return 4 * this.intensity * Math.PI
                    },
                    set: function(e) {
                        this.intensity = e / (4 * Math.PI)
                    }
                }), this.distance = void 0 !== n ? n : 0, this.decay = void 0 !== i ? i : 1, this.shadow = new PointLightShadow
            }

            function OrthographicCamera(e = -1, t = 1, n = 1, i = -1, r = .1, a = 2e3) {
                Camera.call(this), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = t, this.top = n, this.bottom = i, this.near = r, this.far = a, this.updateProjectionMatrix()
            }

            function DirectionalLightShadow() {
                LightShadow.call(this, new OrthographicCamera(-5, 5, 5, -5, .5, 500))
            }

            function DirectionalLight(e, t) {
                Light.call(this, e, t), this.type = "DirectionalLight", this.position.copy(Object3D.DefaultUp), this.updateMatrix(), this.target = new Object3D, this.shadow = new DirectionalLightShadow
            }

            function AmbientLight(e, t) {
                Light.call(this, e, t), this.type = "AmbientLight"
            }

            function RectAreaLight(e, t, n, i) {
                Light.call(this, e, t), this.type = "RectAreaLight", this.width = void 0 !== n ? n : 10, this.height = void 0 !== i ? i : 10
            }

            function LightProbe(e, t) {
                Light.call(this, void 0, t), this.type = "LightProbe", this.sh = void 0 !== e ? e : new SphericalHarmonics3
            }

            function MaterialLoader(e) {
                Loader.call(this, e), this.textures = {}
            }

            function InstancedBufferGeometry() {
                BufferGeometry.call(this), this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0
            }

            function InstancedBufferAttribute(e, t, n, i) {
                "number" == typeof n && (i = n, n = !1), BufferAttribute.call(this, e, t, n), this.meshPerAttribute = i || 1
            }

            function BufferGeometryLoader(e) {
                Loader.call(this, e)
            }

            function ImageBitmapLoader(e) {
                Loader.call(this, e), this.options = {
                    premultiplyAlpha: "none"
                }
            }

            function ShapePath() {
                this.type = "ShapePath", this.color = new Color, this.subPaths = [], this.currentPath = null
            }

            function Font(e) {
                this.type = "Font", this.data = e
            }

            function createPath(e, t, n, i, r) {
                const a = r.glyphs[e] || r.glyphs["?"];
                if (!a) return;
                const o = new ShapePath;
                let s, l, c, u, h, d, p, f;
                if (a.o) {
                    const e = a._cachedOutline || (a._cachedOutline = a.o.split(" "));
                    for (let r = 0, a = e.length; r < a;) {
                        switch (e[r++]) {
                            case "m":
                                s = e[r++] * t + n, l = e[r++] * t + i, o.moveTo(s, l);
                                break;
                            case "l":
                                s = e[r++] * t + n, l = e[r++] * t + i, o.lineTo(s, l);
                                break;
                            case "q":
                                c = e[r++] * t + n, u = e[r++] * t + i, h = e[r++] * t + n, d = e[r++] * t + i, o.quadraticCurveTo(h, d, c, u);
                                break;
                            case "b":
                                c = e[r++] * t + n, u = e[r++] * t + i, h = e[r++] * t + n, d = e[r++] * t + i, p = e[r++] * t + n, f = e[r++] * t + i, o.bezierCurveTo(h, d, p, f, c, u)
                        }
                    }
                }
                return {
                    offsetX: a.ha * t,
                    path: o
                }
            }

            function FontLoader(e) {
                Loader.call(this, e)
            }

            function AudioLoader(e) {
                Loader.call(this, e)
            }

            function HemisphereLightProbe(e, t, n) {
                LightProbe.call(this, void 0, n);
                const i = (new Color).set(e),
                    r = (new Color).set(t),
                    a = new Vector3(i.r, i.g, i.b),
                    o = new Vector3(r.r, r.g, r.b),
                    s = 1.7724538509055159;
                this.sh.coefficients[0].copy(a).add(o).multiplyScalar(s), this.sh.coefficients[1].copy(a).sub(o).multiplyScalar(1.5349900619197325)
            }

            function AmbientLightProbe(e, t) {
                LightProbe.call(this, void 0, t);
                const n = (new Color).set(e);
                this.sh.coefficients[0].set(n.r, n.g, n.b).multiplyScalar(3.5449077018110318)
            }

            function StereoCamera() {
                this.type = "StereoCamera", this.aspect = 1, this.eyeSep = .064, this.cameraL = new PerspectiveCamera, this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new PerspectiveCamera, this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1, this._cache = {
                    focus: null,
                    fov: null,
                    aspect: null,
                    near: null,
                    far: null,
                    zoom: null,
                    eyeSep: null
                }
            }

            function now() {
                return ("undefined" == typeof performance ? Date : performance).now()
            }

            function PropertyMixer(e, t, n) {
                let i, r, a;
                switch (this.binding = e, this.valueSize = n, t) {
                    case "quaternion":
                        i = this._slerp, r = this._slerpAdditive, a = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(6 * n), this._workIndex = 5;
                        break;
                    case "string":
                    case "bool":
                        i = this._select, r = this._select, a = this._setAdditiveIdentityOther, this.buffer = Array(5 * n);
                        break;
                    default:
                        i = this._lerp, r = this._lerpAdditive, a = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(5 * n)
                }
                this._mixBufferRegion = i, this._mixBufferRegionAdditive = r, this._setIdentity = a, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0
            }

            function Composite(e, t, n) {
                const i = n || PropertyBinding.parseTrackName(t);
                this._targetGroup = e, this._bindings = e.subscribe_(t, i)
            }

            function PropertyBinding(e, t, n) {
                this.path = t, this.parsedPath = n || PropertyBinding.parseTrackName(t), this.node = PropertyBinding.findNode(e, this.parsedPath.nodeName) || e, this.rootNode = e
            }

            function AnimationObjectGroup() {
                this.uuid = Fa.generateUUID(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
                const e = {};
                this._indicesByUUID = e;
                for (let t = 0, n = arguments.length; t !== n; ++t) e[arguments[t].uuid] = t;
                this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
                const t = this;
                this.stats = {
                    objects: {
                        get total() {
                            return t._objects.length
                        },
                        get inUse() {
                            return this.total - t.nCachedObjects_
                        }
                    },
                    get bindingsPerObject() {
                        return t._bindings.length
                    }
                }
            }

            function AnimationMixer(e) {
                this._root = e, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1
            }

            function InstancedInterleavedBuffer(e, t, n) {
                InterleavedBuffer.call(this, e, t), this.meshPerAttribute = n || 1
            }

            function GLBufferAttribute(e, t, n, i, r) {
                this.buffer = e, this.type = t, this.itemSize = n, this.elementSize = i, this.count = r, this.version = 0
            }

            function Raycaster(e, t, n, i) {
                this.ray = new Ray(e, t), this.near = n || 0, this.far = i || 1 / 0, this.camera = null, this.layers = new Layers, this.params = {
                    Mesh: {},
                    Line: {
                        threshold: 1
                    },
                    LOD: {},
                    Points: {
                        threshold: 1
                    },
                    Sprite: {}
                }, Object.defineProperties(this.params, {
                    PointCloud: {
                        get: function() {
                            return this.Points
                        }
                    }
                })
            }

            function ascSort(e, t) {
                return e.distance - t.distance
            }

            function intersectObject(e, t, n, i) {
                if (e.layers.test(t.layers) && e.raycast(t, n), !0 === i) {
                    const i = e.children;
                    for (let e = 0, r = i.length; e < r; e++) intersectObject(i[e], t, n, !0)
                }
            }

            function ImmediateRenderObject(e) {
                Object3D.call(this), this.material = e, this.render = function() {}, this.hasPositions = !1, this.hasNormals = !1, this.hasColors = !1, this.hasUvs = !1, this.positionArray = null, this.normalArray = null, this.colorArray = null, this.uvArray = null, this.count = 0
            }

            function getBoneList(e) {
                const t = [];
                e && e.isBone && t.push(e);
                for (let n = 0; n < e.children.length; n++) t.push.apply(t, getBoneList(e.children[n]));
                return t
            }

            function setPoint(e, t, n, i, r, a, o) {
                _c.set(r, a, o).unproject(i);
                const s = t[e];
                if (void 0 !== s) {
                    const e = n.getAttribute("position");
                    for (let t = 0, n = s.length; t < n; t++) e.setXYZ(s[t], _c.x, _c.y, _c.z)
                }
            }

            function _isLDR(e) {
                return void 0 !== e && e.type === xi && (e.encoding === Hr || e.encoding === Xr || e.encoding === Yr)
            }

            function _createPlanes() {
                const e = [],
                    t = [],
                    n = [];
                let i = 8;
                for (let r = 0; r < Ic; r++) {
                    const a = Math.pow(2, i);
                    t.push(a);
                    let o = 1 / a;
                    r > 4 ? o = Ec[r - 8 + 4 - 1] : 0 == r && (o = 0), n.push(o);
                    const s = 1 / (a - 1),
                        l = -s / 2,
                        c = 1 + s / 2,
                        u = [l, l, c, l, c, c, l, l, c, c, l, c],
                        h = 6,
                        d = 6,
                        p = 3,
                        f = 2,
                        m = 1,
                        g = new Float32Array(p * d * h),
                        y = new Float32Array(f * d * h),
                        x = new Float32Array(m * d * h);
                    for (let e = 0; e < h; e++) {
                        const t = e % 3 * 2 / 3 - 1,
                            n = e > 2 ? 0 : -1,
                            i = [t, n, 0, t + 2 / 3, n, 0, t + 2 / 3, n + 1, 0, t, n, 0, t + 2 / 3, n + 1, 0, t, n + 1, 0];
                        g.set(i, p * d * e), y.set(u, f * d * e);
                        const r = [e, e, e, e, e, e];
                        x.set(r, m * d * e)
                    }
                    const _ = new BufferGeometry;
                    _.setAttribute("position", new BufferAttribute(g, p)), _.setAttribute("uv", new BufferAttribute(y, f)), _.setAttribute("faceIndex", new BufferAttribute(x, m)), e.push(_), i > 4 && i--
                }
                return {
                    _lodPlanes: e,
                    _sizeLods: t,
                    _sigmas: n
                }
            }

            function _createRenderTarget(e) {
                const t = new WebGLRenderTarget(768, 768, e);
                return t.texture.mapping = ri, t.texture.name = "PMREM.cubeUv", t.scissorTest = !0, t
            }

            function _setViewport(e, t, n, i, r) {
                e.viewport.set(t, n, i, r), e.scissor.set(t, n, i, r)
            }

            function _getEquirectShader() {
                return new RawShaderMaterial({
                    name: "EquirectangularToCubeUV",
                    uniforms: {
                        envMap: {
                            value: null
                        },
                        texelSize: {
                            value: new Vector2(1, 1)
                        },
                        inputEncoding: {
                            value: Fc[Hr]
                        },
                        outputEncoding: {
                            value: Fc[Hr]
                        }
                    },
                    vertexShader: _getCommonVertexShader(),
                    fragmentShader: `\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform vec2 texelSize;\n\n\t\t\t${_getEncodings()}\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tvec2 f = fract( uv / texelSize - 0.5 );\n\t\t\t\tuv -= f * texelSize;\n\t\t\t\tvec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x += texelSize.x;\n\t\t\t\tvec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.y += texelSize.y;\n\t\t\t\tvec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x -= texelSize.x;\n\t\t\t\tvec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\n\t\t\t\tvec3 tm = mix( tl, tr, f.x );\n\t\t\t\tvec3 bm = mix( bl, br, f.x );\n\t\t\t\tgl_FragColor.rgb = mix( tm, bm, f.y );\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t`,
                    blending: fn,
                    depthTest: !1,
                    depthWrite: !1
                })
            }

            function _getCubemapShader() {
                return new RawShaderMaterial({
                    name: "CubemapToCubeUV",
                    uniforms: {
                        envMap: {
                            value: null
                        },
                        inputEncoding: {
                            value: Fc[Hr]
                        },
                        outputEncoding: {
                            value: Fc[Hr]
                        }
                    },
                    vertexShader: _getCommonVertexShader(),
                    fragmentShader: `\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\t${_getEncodings()}\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t`,
                    blending: fn,
                    depthTest: !1,
                    depthWrite: !1
                })
            }

            function _getCommonVertexShader() {
                return "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t"
            }

            function _getEncodings() {
                return "\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t"
            }

            function Face4(e, t, n, i, r, a, o) {
                return new Face3(e, t, n, r, a, o)
            }

            function MeshFaceMaterial(e) {
                return e
            }

            function MultiMaterial(e = []) {
                return e.isMultiMaterial = !0, e.materials = e, e.clone = function() {
                    return e.slice()
                }, e
            }

            function PointCloud(e, t) {
                return new Points(e, t)
            }

            function Particle(e) {
                return new Sprite(e)
            }

            function ParticleSystem(e, t) {
                return new Points(e, t)
            }

            function PointCloudMaterial(e) {
                return new PointsMaterial(e)
            }

            function ParticleBasicMaterial(e) {
                return new PointsMaterial(e)
            }

            function ParticleSystemMaterial(e) {
                return new PointsMaterial(e)
            }

            function Vertex(e, t, n) {
                return new Vector3(e, t, n)
            }

            function DynamicBufferAttribute(e, t) {
                return new BufferAttribute(e, t).setUsage(_a)
            }

            function Int8Attribute(e, t) {
                return new Int8BufferAttribute(e, t)
            }

            function Uint8Attribute(e, t) {
                return new Uint8BufferAttribute(e, t)
            }

            function Uint8ClampedAttribute(e, t) {
                return new Uint8ClampedBufferAttribute(e, t)
            }

            function Int16Attribute(e, t) {
                return new Int16BufferAttribute(e, t)
            }

            function Uint16Attribute(e, t) {
                return new Uint16BufferAttribute(e, t)
            }

            function Int32Attribute(e, t) {
                return new Int32BufferAttribute(e, t)
            }

            function Uint32Attribute(e, t) {
                return new Uint32BufferAttribute(e, t)
            }

            function Float32Attribute(e, t) {
                return new Float32BufferAttribute(e, t)
            }

            function Float64Attribute(e, t) {
                return new Float64BufferAttribute(e, t)
            }

            function ClosedSplineCurve3(e) {
                CatmullRomCurve3.call(this, e), this.type = "catmullrom", this.closed = !0
            }

            function SplineCurve3(e) {
                CatmullRomCurve3.call(this, e), this.type = "catmullrom"
            }

            function Spline(e) {
                CatmullRomCurve3.call(this, e), this.type = "catmullrom"
            }

            function AxisHelper(e) {
                return new AxesHelper(e)
            }

            function BoundingBoxHelper(e, t) {
                return new BoxHelper(e, t)
            }

            function EdgesHelper(e, t) {
                return new LineSegments(new EdgesGeometry(e.geometry), new LineBasicMaterial({
                    color: void 0 !== t ? t : 16777215
                }))
            }

            function WireframeHelper(e, t) {
                return new LineSegments(new WireframeGeometry(e.geometry), new LineBasicMaterial({
                    color: void 0 !== t ? t : 16777215
                }))
            }

            function XHRLoader(e) {
                return new FileLoader(e)
            }

            function BinaryTextureLoader(e) {
                return new DataTextureLoader(e)
            }

            function WebGLRenderTargetCube(e, t, n) {
                return new WebGLCubeRenderTarget(e, n)
            }

            function CanvasRenderer() {}

            function JSONLoader() {}

            function LensFlare() {}

            function _createSuper(e) {
                var t = function _isNativeReflectConstruct() {
                    if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                    if (Reflect.construct.sham) return !1;
                    if ("function" == typeof Proxy) return !0;
                    try {
                        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}))), !0
                    } catch (e) {
                        return !1
                    }
                }();
                return function _createSuperInternal() {
                    var n, i, r = _getPrototypeOf(e);
                    return t ? (i = _getPrototypeOf(this).constructor, n = Reflect.construct(r, arguments, i)) : n = r.apply(this, arguments), _possibleConstructorReturn(this, n)
                }
            }

            function lerp(e, t, n) {
                return e * (1 - n) + t * n
            }

            function SpriteSet_createSuper(e) {
                var t = function SpriteSet_isNativeReflectConstruct() {
                    if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                    if (Reflect.construct.sham) return !1;
                    if ("function" == typeof Proxy) return !0;
                    try {
                        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}))), !0
                    } catch (e) {
                        return !1
                    }
                }();
                return function _createSuperInternal() {
                    var n, i, r = _getPrototypeOf(e);
                    return t ? (i = _getPrototypeOf(this).constructor, n = Reflect.construct(r, arguments, i)) : n = r.apply(this, arguments), _possibleConstructorReturn(this, n)
                }
            }

            function ShaderPass_createSuper(e) {
                var t = function ShaderPass_isNativeReflectConstruct() {
                    if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                    if (Reflect.construct.sham) return !1;
                    if ("function" == typeof Proxy) return !0;
                    try {
                        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}))), !0
                    } catch (e) {
                        return !1
                    }
                }();
                return function _createSuperInternal() {
                    var n, i, r = _getPrototypeOf(e);
                    return t ? (i = _getPrototypeOf(this).constructor, n = Reflect.construct(r, arguments, i)) : n = r.apply(this, arguments), _possibleConstructorReturn(this, n)
                }
            }

            function RenderPass_createSuper(e) {
                var t = function RenderPass_isNativeReflectConstruct() {
                    if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                    if (Reflect.construct.sham) return !1;
                    if ("function" == typeof Proxy) return !0;
                    try {
                        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}))), !0
                    } catch (e) {
                        return !1
                    }
                }();
                return function _createSuperInternal() {
                    var n, i, r = _getPrototypeOf(e);
                    return t ? (i = _getPrototypeOf(this).constructor, n = Reflect.construct(r, arguments, i)) : n = r.apply(this, arguments), _possibleConstructorReturn(this, n)
                }
            }

            function UnrealBloomPass_createSuper(e) {
                var t = function UnrealBloomPass_isNativeReflectConstruct() {
                    if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                    if (Reflect.construct.sham) return !1;
                    if ("function" == typeof Proxy) return !0;
                    try {
                        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}))), !0
                    } catch (e) {
                        return !1
                    }
                }();
                return function _createSuperInternal() {
                    var n, i, r = _getPrototypeOf(e);
                    return t ? (i = _getPrototypeOf(this).constructor, n = Reflect.construct(r, arguments, i)) : n = r.apply(this, arguments), _possibleConstructorReturn(this, n)
                }
            }

            function LooseOctree_createSuper(e) {
                var t = function LooseOctree_isNativeReflectConstruct() {
                    if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                    if (Reflect.construct.sham) return !1;
                    if ("function" == typeof Proxy) return !0;
                    try {
                        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}))), !0
                    } catch (e) {
                        return !1
                    }
                }();
                return function _createSuperInternal() {
                    var n, i, r = _getPrototypeOf(e);
                    return t ? (i = _getPrototypeOf(this).constructor, n = Reflect.construct(r, arguments, i)) : n = r.apply(this, arguments), _possibleConstructorReturn(this, n)
                }
            }

            function LooseTrimesh_createSuper(e) {
                var t = function LooseTrimesh_isNativeReflectConstruct() {
                    if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                    if (Reflect.construct.sham) return !1;
                    if ("function" == typeof Proxy) return !0;
                    try {
                        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}))), !0
                    } catch (e) {
                        return !1
                    }
                }();
                return function _createSuperInternal() {
                    var n, i, r = _getPrototypeOf(e);
                    return t ? (i = _getPrototypeOf(this).constructor, n = Reflect.construct(r, arguments, i)) : n = r.apply(this, arguments), _possibleConstructorReturn(this, n)
                }
            }

            function isNativeReflectConstruct_isNativeReflectConstruct() {
                if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                if (Reflect.construct.sham) return !1;
                if ("function" == typeof Proxy) return !0;
                try {
                    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}))), !0
                } catch (e) {
                    return !1
                }
            }

            function _construct(e, t, n) {
                return _construct = isNativeReflectConstruct_isNativeReflectConstruct() ? Reflect.construct.bind() : function _construct(e, t, n) {
                    var i, r = [null];
                    return r.push.apply(r, t), i = new(Function.bind.apply(e, r)), n && _setPrototypeOf(i, n.prototype), i
                }, _construct.apply(null, arguments)
            }

            function _arrayLikeToArray(e, t) {
                (null == t || t > e.length) && (t = e.length);
                for (var n = 0, i = Array(t); n < t; n++) i[n] = e[n];
                return i
            }

            function _toConsumableArray(e) {
                return function _arrayWithoutHoles(e) {
                    if (Array.isArray(e)) return _arrayLikeToArray(e)
                }(e) || function _iterableToArray(e) {
                    if ("undefined" != typeof Symbol && null != e[Symbol.iterator] || null != e["@@iterator"]) return Array.from(e)
                }(e) || function _unsupportedIterableToArray(e, t) {
                    if (e) {
                        if ("string" == typeof e) return _arrayLikeToArray(e, t);
                        var n = Object.prototype.toString.call(e).slice(8, -1);
                        return "Object" === n && e.constructor && (n = e.constructor.name), "Map" === n || "Set" === n ? Array.from(e) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? _arrayLikeToArray(e, t) : void 0
                    }
                }(e) || function _nonIterableSpread() {
                    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                }()
            }

            function ConnectionComponent_createSuper(e) {
                var t = function ConnectionComponent_isNativeReflectConstruct() {
                    if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                    if (Reflect.construct.sham) return !1;
                    if ("function" == typeof Proxy) return !0;
                    try {
                        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}))), !0
                    } catch (e) {
                        return !1
                    }
                }();
                return function _createSuperInternal() {
                    var n, i, r = _getPrototypeOf(e);
                    return t ? (i = _getPrototypeOf(this).constructor, n = Reflect.construct(r, arguments, i)) : n = r.apply(this, arguments), _possibleConstructorReturn(this, n)
                }
            }

            function SingletonComponent_createSuper(e) {
                var t = function SingletonComponent_isNativeReflectConstruct() {
                    if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                    if (Reflect.construct.sham) return !1;
                    if ("function" == typeof Proxy) return !0;
                    try {
                        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}))), !0
                    } catch (e) {
                        return !1
                    }
                }();
                return function _createSuperInternal() {
                    var n, i, r = _getPrototypeOf(e);
                    return t ? (i = _getPrototypeOf(this).constructor, n = Reflect.construct(r, arguments, i)) : n = r.apply(this, arguments), _possibleConstructorReturn(this, n)
                }
            }

            function SingletonAudioComponent_createSuper(e) {
                var t = function SingletonAudioComponent_isNativeReflectConstruct() {
                    if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                    if (Reflect.construct.sham) return !1;
                    if ("function" == typeof Proxy) return !0;
                    try {
                        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}))), !0
                    } catch (e) {
                        return !1
                    }
                }();
                return function _createSuperInternal() {
                    var n, i, r = _getPrototypeOf(e);
                    return t ? (i = _getPrototypeOf(this).constructor, n = Reflect.construct(r, arguments, i)) : n = r.apply(this, arguments), _possibleConstructorReturn(this, n)
                }
            }

            function scrubToDefaults(e, t) {
                for (var n in e) void 0 === t[n] && (e[n] = void 0)
            }

            function initObject3D() {
                scrubToDefaults(this, Xe)
            }

            function initGroup() {
                scrubToDefaults(this, Ye)
            }

            function initMesh() {
                scrubToDefaults(this, He)
            }

            function initSkinnedMesh() {
                scrubToDefaults(this, We)
            }

            function OffsetPerspectiveCamera_createSuper(e) {
                var t = function OffsetPerspectiveCamera_isNativeReflectConstruct() {
                    if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                    if (Reflect.construct.sham) return !1;
                    if ("function" == typeof Proxy) return !0;
                    try {
                        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}))), !0
                    } catch (e) {
                        return !1
                    }
                }();
                return function _createSuperInternal() {
                    var n, i, r = _getPrototypeOf(e);
                    return t ? (i = _getPrototypeOf(this).constructor, n = Reflect.construct(r, arguments, i)) : n = r.apply(this, arguments), _possibleConstructorReturn(this, n)
                }
            }

            function index_renderer_createSuper(e) {
                var t = function index_renderer_isNativeReflectConstruct() {
                    if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                    if (Reflect.construct.sham) return !1;
                    if ("function" == typeof Proxy) return !0;
                    try {
                        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}))), !0
                    } catch (e) {
                        return !1
                    }
                }();
                return function _createSuperInternal() {
                    var n, i, r = _getPrototypeOf(e);
                    return t ? (i = _getPrototypeOf(this).constructor, n = Reflect.construct(r, arguments, i)) : n = r.apply(this, arguments), _possibleConstructorReturn(this, n)
                }
            }

            function ownKeys(e, t) {
                var n, i = Object.keys(e);
                return Object.getOwnPropertySymbols && (n = Object.getOwnPropertySymbols(e), t && (n = n.filter((function(t) {
                    return Object.getOwnPropertyDescriptor(e, t).enumerable
                }))), i.push.apply(i, n)), i
            }

            function _objectSpread(e) {
                var t, n;
                for (t = 1; t < arguments.length; t++) n = null != arguments[t] ? arguments[t] : {}, t % 2 ? ownKeys(Object(n), !0).forEach((function(t) {
                    _defineProperty(e, t, n[t])
                })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : ownKeys(Object(n)).forEach((function(t) {
                    Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t))
                }));
                return e
            }
            var t, n, i, r, a, o, s, l, c, u, h, d, p, f, m, g, y, x, _, b, M, S, A, w, T, L, C, P, E, I, F, O, B, R, N, D, V, U, z, G, k, j, W, H, X, Y, q, Q, J, Z, K, $, ee, te, ne, ie, re, ae, oe, se, le, ce, ue, he, de, pe, fe, me, ge, ve, ye, xe, _e, be, Me, Se, Ae, we, Te, Le, Ce, Pe, Ee, Ie, Fe, Oe, Be, Re, Ne, De, Ve, Ue, ze, Ge, ke, je, We, He, Xe, Ye, qe, Qe, Je, Ze, Ke, $e, et, tt, nt, it, rt, at, ot, st, lt, ct, ut, ht, dt, pt, ft, mt, gt, vt, yt, xt, _t, bt, Mt, St, At, wt, Tt, Lt, Ct, Pt, Et, It, Ft, Ot, Bt, Rt, Nt, Dt, Vt, Ut, zt, Gt, kt, jt, Wt, Ht, Xt, Yt, qt, Qt, Jt;
            __webpack_require__.r(e), t = {}, __webpack_require__.r(t), __webpack_require__.d(t, {
                ACESFilmicToneMapping: () => Zn,
                AddEquation: () => _n,
                AddOperation: () => Xn,
                AdditiveAnimationBlendMode: () => Gr,
                AdditiveBlending: () => gn,
                AlphaFormat: () => Ii,
                AlwaysDepth: () => Dn,
                AlwaysStencilFunc: () => ya,
                AmbientLight: () => AmbientLight,
                AmbientLightProbe: () => AmbientLightProbe,
                AnimationClip: () => AnimationClip,
                AnimationLoader: () => AnimationLoader,
                AnimationMixer: () => AnimationMixer,
                AnimationObjectGroup: () => AnimationObjectGroup,
                AnimationUtils: () => Bl,
                ArcCurve: () => ArcCurve,
                ArrayCamera: () => ArrayCamera,
                ArrowHelper: () => ArrowHelper,
                Audio: () => Audio,
                AudioAnalyser: () => AudioAnalyser,
                AudioContext: () => Yl,
                AudioListener: () => AudioListener,
                AudioLoader: () => AudioLoader,
                AxesHelper: () => AxesHelper,
                AxisHelper: () => AxisHelper,
                BackSide: () => un,
                BasicDepthPacking: () => $r,
                BasicShadowMap: () => an,
                BinaryTextureLoader: () => BinaryTextureLoader,
                Bone: () => Bone,
                BooleanKeyframeTrack: () => BooleanKeyframeTrack,
                BoundingBoxHelper: () => BoundingBoxHelper,
                Box2: () => Box2,
                Box3: () => Box3,
                Box3Helper: () => Box3Helper,
                BoxBufferGeometry: () => BoxBufferGeometry,
                BoxGeometry: () => BoxGeometry,
                BoxHelper: () => BoxHelper,
                BufferAttribute: () => BufferAttribute,
                BufferGeometry: () => BufferGeometry,
                BufferGeometryLoader: () => BufferGeometryLoader,
                ByteType: () => _i,
                Cache: () => Rl,
                Camera: () => Camera,
                CameraHelper: () => CameraHelper,
                CanvasRenderer: () => CanvasRenderer,
                CanvasTexture: () => CanvasTexture,
                CatmullRomCurve3: () => CatmullRomCurve3,
                CineonToneMapping: () => Jn,
                CircleBufferGeometry: () => CircleBufferGeometry,
                CircleGeometry: () => CircleGeometry,
                ClampToEdgeWrapping: () => si,
                Clock: () => Clock,
                ClosedSplineCurve3: () => ClosedSplineCurve3,
                Color: () => Color,
                ColorKeyframeTrack: () => ColorKeyframeTrack,
                CompressedTexture: () => CompressedTexture,
                CompressedTextureLoader: () => CompressedTextureLoader,
                ConeBufferGeometry: () => ConeBufferGeometry,
                ConeGeometry: () => ConeGeometry,
                CubeCamera: () => CubeCamera,
                CubeGeometry: () => BoxGeometry,
                CubeReflectionMapping: () => ei,
                CubeRefractionMapping: () => ti,
                CubeTexture: () => CubeTexture,
                CubeTextureLoader: () => CubeTextureLoader,
                CubeUVReflectionMapping: () => ri,
                CubeUVRefractionMapping: () => ai,
                CubicBezierCurve: () => CubicBezierCurve,
                CubicBezierCurve3: () => CubicBezierCurve3,
                CubicInterpolant: () => CubicInterpolant,
                CullFaceBack: () => tn,
                CullFaceFront: () => nn,
                CullFaceFrontBack: () => rn,
                CullFaceNone: () => en,
                Curve: () => Curve,
                CurvePath: () => CurvePath,
                CustomBlending: () => xn,
                CustomToneMapping: () => Kn,
                CylinderBufferGeometry: () => CylinderBufferGeometry,
                CylinderGeometry: () => CylinderGeometry,
                Cylindrical: () => Cylindrical,
                DataTexture: () => DataTexture,
                DataTexture2DArray: () => DataTexture2DArray,
                DataTexture3D: () => DataTexture3D,
                DataTextureLoader: () => DataTextureLoader,
                DataUtils: () => Cc,
                DecrementStencilOp: () => sa,
                DecrementWrapStencilOp: () => ca,
                DefaultLoadingManager: () => Nl,
                DepthFormat: () => Di,
                DepthStencilFormat: () => Vi,
                DepthTexture: () => DepthTexture,
                DirectionalLight: () => DirectionalLight,
                DirectionalLightHelper: () => DirectionalLightHelper,
                DiscreteInterpolant: () => DiscreteInterpolant,
                DodecahedronBufferGeometry: () => DodecahedronBufferGeometry,
                DodecahedronGeometry: () => DodecahedronGeometry,
                DoubleSide: () => hn,
                DstAlphaFactor: () => In,
                DstColorFactor: () => On,
                DynamicBufferAttribute: () => DynamicBufferAttribute,
                DynamicCopyUsage: () => Ta,
                DynamicDrawUsage: () => _a,
                DynamicReadUsage: () => Sa,
                EdgesGeometry: () => EdgesGeometry,
                EdgesHelper: () => EdgesHelper,
                EllipseCurve: () => EllipseCurve,
                EqualDepth: () => zn,
                EqualStencilFunc: () => pa,
                EquirectangularReflectionMapping: () => ni,
                EquirectangularRefractionMapping: () => ii,
                Euler: () => Euler,
                EventDispatcher: () => EventDispatcher,
                ExtrudeBufferGeometry: () => ExtrudeBufferGeometry,
                ExtrudeGeometry: () => ExtrudeGeometry,
                Face3: () => Face3,
                Face4: () => Face4,
                FaceColors: () => Hc,
                FileLoader: () => FileLoader,
                FlatShading: () => dn,
                Float16BufferAttribute: () => Float16BufferAttribute,
                Float32Attribute: () => Float32Attribute,
                Float32BufferAttribute: () => Float32BufferAttribute,
                Float64Attribute: () => Float64Attribute,
                Float64BufferAttribute: () => Float64BufferAttribute,
                FloatType: () => wi,
                Fog: () => Fog,
                FogExp2: () => FogExp2,
                Font: () => Font,
                FontLoader: () => FontLoader,
                FrontSide: () => cn,
                Frustum: () => Frustum,
                GLBufferAttribute: () => GLBufferAttribute,
                GLSL1: () => Ca,
                GLSL3: () => Pa,
                GammaEncoding: () => Yr,
                Geometry: () => Geometry,
                GeometryUtils: () => Yc,
                GreaterDepth: () => kn,
                GreaterEqualDepth: () => Gn,
                GreaterEqualStencilFunc: () => va,
                GreaterStencilFunc: () => ma,
                GridHelper: () => GridHelper,
                Group: () => Group,
                HalfFloatType: () => Ti,
                HemisphereLight: () => HemisphereLight,
                HemisphereLightHelper: () => HemisphereLightHelper,
                HemisphereLightProbe: () => HemisphereLightProbe,
                IcosahedronBufferGeometry: () => IcosahedronBufferGeometry,
                IcosahedronGeometry: () => IcosahedronGeometry,
                ImageBitmapLoader: () => ImageBitmapLoader,
                ImageLoader: () => ImageLoader,
                ImageUtils: () => Ba,
                ImmediateRenderObject: () => ImmediateRenderObject,
                IncrementStencilOp: () => oa,
                IncrementWrapStencilOp: () => la,
                InstancedBufferAttribute: () => InstancedBufferAttribute,
                InstancedBufferGeometry: () => InstancedBufferGeometry,
                InstancedInterleavedBuffer: () => InstancedInterleavedBuffer,
                InstancedMesh: () => InstancedMesh,
                Int16Attribute: () => Int16Attribute,
                Int16BufferAttribute: () => Int16BufferAttribute,
                Int32Attribute: () => Int32Attribute,
                Int32BufferAttribute: () => Int32BufferAttribute,
                Int8Attribute: () => Int8Attribute,
                Int8BufferAttribute: () => Int8BufferAttribute,
                IntType: () => Si,
                InterleavedBuffer: () => InterleavedBuffer,
                InterleavedBufferAttribute: () => InterleavedBufferAttribute,
                Interpolant: () => Interpolant,
                InterpolateDiscrete: () => Br,
                InterpolateLinear: () => Rr,
                InterpolateSmooth: () => Nr,
                InvertStencilOp: () => ua,
                JSONLoader: () => JSONLoader,
                KeepStencilOp: () => ra,
                KeyframeTrack: () => KeyframeTrack,
                LOD: () => LOD,
                LatheBufferGeometry: () => LatheBufferGeometry,
                LatheGeometry: () => LatheGeometry,
                Layers: () => Layers,
                LensFlare: () => LensFlare,
                LessDepth: () => Vn,
                LessEqualDepth: () => Un,
                LessEqualStencilFunc: () => fa,
                LessStencilFunc: () => da,
                Light: () => Light,
                LightProbe: () => LightProbe,
                Line: () => Line,
                Line3: () => Line3,
                LineBasicMaterial: () => LineBasicMaterial,
                LineCurve: () => LineCurve,
                LineCurve3: () => LineCurve3,
                LineDashedMaterial: () => LineDashedMaterial,
                LineLoop: () => LineLoop,
                LinePieces: () => jc,
                LineSegments: () => LineSegments,
                LineStrip: () => kc,
                LinearEncoding: () => Hr,
                LinearFilter: () => fi,
                LinearInterpolant: () => LinearInterpolant,
                LinearMipMapLinearFilter: () => yi,
                LinearMipMapNearestFilter: () => gi,
                LinearMipmapLinearFilter: () => vi,
                LinearMipmapNearestFilter: () => mi,
                LinearToneMapping: () => qn,
                Loader: () => Loader,
                LoaderUtils: () => kl,
                LoadingManager: () => LoadingManager,
                LogLuvEncoding: () => Qr,
                LoopOnce: () => Ir,
                LoopPingPong: () => Or,
                LoopRepeat: () => Fr,
                LuminanceAlphaFormat: () => Ri,
                LuminanceFormat: () => Bi,
                MOUSE: () => Kt,
                Material: () => Material,
                MaterialLoader: () => MaterialLoader,
                Math: () => Fa,
                MathUtils: () => Fa,
                Matrix3: () => Matrix3,
                Matrix4: () => Matrix4,
                MaxEquation: () => An,
                Mesh: () => Mesh,
                MeshBasicMaterial: () => MeshBasicMaterial,
                MeshDepthMaterial: () => MeshDepthMaterial,
                MeshDistanceMaterial: () => MeshDistanceMaterial,
                MeshFaceMaterial: () => MeshFaceMaterial,
                MeshLambertMaterial: () => MeshLambertMaterial,
                MeshMatcapMaterial: () => MeshMatcapMaterial,
                MeshNormalMaterial: () => MeshNormalMaterial,
                MeshPhongMaterial: () => MeshPhongMaterial,
                MeshPhysicalMaterial: () => MeshPhysicalMaterial,
                MeshStandardMaterial: () => MeshStandardMaterial,
                MeshToonMaterial: () => MeshToonMaterial,
                MinEquation: () => Sn,
                MirroredRepeatWrapping: () => li,
                MixOperation: () => Hn,
                MultiMaterial: () => MultiMaterial,
                MultiplyBlending: () => yn,
                MultiplyOperation: () => Wn,
                NearestFilter: () => ci,
                NearestMipMapLinearFilter: () => pi,
                NearestMipMapNearestFilter: () => hi,
                NearestMipmapLinearFilter: () => di,
                NearestMipmapNearestFilter: () => ui,
                NeverDepth: () => Nn,
                NeverStencilFunc: () => ha,
                NoBlending: () => fn,
                NoColors: () => Wc,
                NoToneMapping: () => Yn,
                NormalAnimationBlendMode: () => zr,
                NormalBlending: () => mn,
                NotEqualDepth: () => jn,
                NotEqualStencilFunc: () => ga,
                NumberKeyframeTrack: () => NumberKeyframeTrack,
                Object3D: () => Object3D,
                ObjectLoader: () => ObjectLoader,
                ObjectSpaceNormalMap: () => na,
                OctahedronBufferGeometry: () => OctahedronBufferGeometry,
                OctahedronGeometry: () => OctahedronGeometry,
                OneFactor: () => Tn,
                OneMinusDstAlphaFactor: () => Fn,
                OneMinusDstColorFactor: () => Bn,
                OneMinusSrcAlphaFactor: () => En,
                OneMinusSrcColorFactor: () => Cn,
                OrthographicCamera: () => OrthographicCamera,
                PCFShadowMap: () => on,
                PCFSoftShadowMap: () => sn,
                PMREMGenerator: () => PMREMGenerator,
                ParametricBufferGeometry: () => ParametricBufferGeometry,
                ParametricGeometry: () => ParametricGeometry,
                Particle: () => Particle,
                ParticleBasicMaterial: () => ParticleBasicMaterial,
                ParticleSystem: () => ParticleSystem,
                ParticleSystemMaterial: () => ParticleSystemMaterial,
                Path: () => Path,
                PerspectiveCamera: () => PerspectiveCamera,
                Plane: () => Plane,
                PlaneBufferGeometry: () => PlaneBufferGeometry,
                PlaneGeometry: () => PlaneGeometry,
                PlaneHelper: () => PlaneHelper,
                PointCloud: () => PointCloud,
                PointCloudMaterial: () => PointCloudMaterial,
                PointLight: () => PointLight,
                PointLightHelper: () => PointLightHelper,
                Points: () => Points,
                PointsMaterial: () => PointsMaterial,
                PolarGridHelper: () => PolarGridHelper,
                PolyhedronBufferGeometry: () => PolyhedronBufferGeometry,
                PolyhedronGeometry: () => PolyhedronGeometry,
                PositionalAudio: () => PositionalAudio,
                PropertyBinding: () => PropertyBinding,
                PropertyMixer: () => PropertyMixer,
                QuadraticBezierCurve: () => QuadraticBezierCurve,
                QuadraticBezierCurve3: () => QuadraticBezierCurve3,
                Quaternion: () => Quaternion,
                QuaternionKeyframeTrack: () => QuaternionKeyframeTrack,
                QuaternionLinearInterpolant: () => QuaternionLinearInterpolant,
                REVISION: () => Zt,
                RGBADepthPacking: () => ea,
                RGBAFormat: () => Oi,
                RGBAIntegerFormat: () => Wi,
                RGBA_ASTC_10x10_Format: () => pr,
                RGBA_ASTC_10x5_Format: () => ur,
                RGBA_ASTC_10x6_Format: () => hr,
                RGBA_ASTC_10x8_Format: () => dr,
                RGBA_ASTC_12x10_Format: () => fr,
                RGBA_ASTC_12x12_Format: () => mr,
                RGBA_ASTC_4x4_Format: () => nr,
                RGBA_ASTC_5x4_Format: () => ir,
                RGBA_ASTC_5x5_Format: () => rr,
                RGBA_ASTC_6x5_Format: () => ar,
                RGBA_ASTC_6x6_Format: () => or,
                RGBA_ASTC_8x5_Format: () => sr,
                RGBA_ASTC_8x6_Format: () => lr,
                RGBA_ASTC_8x8_Format: () => cr,
                RGBA_BPTC_Format: () => gr,
                RGBA_ETC2_EAC_Format: () => tr,
                RGBA_PVRTC_2BPPV1_Format: () => Ki,
                RGBA_PVRTC_4BPPV1_Format: () => Zi,
                RGBA_S3TC_DXT1_Format: () => Xi,
                RGBA_S3TC_DXT3_Format: () => Yi,
                RGBA_S3TC_DXT5_Format: () => qi,
                RGBDEncoding: () => Kr,
                RGBEEncoding: () => qr,
                RGBEFormat: () => Ni,
                RGBFormat: () => Fi,
                RGBIntegerFormat: () => ji,
                RGBM16Encoding: () => Zr,
                RGBM7Encoding: () => Jr,
                RGB_ETC1_Format: () => $i,
                RGB_ETC2_Format: () => er,
                RGB_PVRTC_2BPPV1_Format: () => Ji,
                RGB_PVRTC_4BPPV1_Format: () => Qi,
                RGB_S3TC_DXT1_Format: () => Hi,
                RGFormat: () => Gi,
                RGIntegerFormat: () => ki,
                RawShaderMaterial: () => RawShaderMaterial,
                Ray: () => Ray,
                Raycaster: () => Raycaster,
                RectAreaLight: () => RectAreaLight,
                RedFormat: () => Ui,
                RedIntegerFormat: () => zi,
                ReinhardToneMapping: () => Qn,
                RepeatWrapping: () => oi,
                ReplaceStencilOp: () => aa,
                ReverseSubtractEquation: () => Mn,
                RingBufferGeometry: () => RingBufferGeometry,
                RingGeometry: () => RingGeometry,
                SRGB8_ALPHA8_ASTC_10x10_Format: () => Cr,
                SRGB8_ALPHA8_ASTC_10x5_Format: () => wr,
                SRGB8_ALPHA8_ASTC_10x6_Format: () => Tr,
                SRGB8_ALPHA8_ASTC_10x8_Format: () => Lr,
                SRGB8_ALPHA8_ASTC_12x10_Format: () => Pr,
                SRGB8_ALPHA8_ASTC_12x12_Format: () => Er,
                SRGB8_ALPHA8_ASTC_4x4_Format: () => vr,
                SRGB8_ALPHA8_ASTC_5x4_Format: () => yr,
                SRGB8_ALPHA8_ASTC_5x5_Format: () => xr,
                SRGB8_ALPHA8_ASTC_6x5_Format: () => _r,
                SRGB8_ALPHA8_ASTC_6x6_Format: () => br,
                SRGB8_ALPHA8_ASTC_8x5_Format: () => Mr,
                SRGB8_ALPHA8_ASTC_8x6_Format: () => Sr,
                SRGB8_ALPHA8_ASTC_8x8_Format: () => Ar,
                Scene: () => Scene,
                SceneUtils: () => qc,
                ShaderChunk: () => Ms,
                ShaderLib: () => As,
                ShaderMaterial: () => ShaderMaterial,
                ShadowMaterial: () => ShadowMaterial,
                Shape: () => Shape,
                ShapeBufferGeometry: () => ShapeBufferGeometry,
                ShapeGeometry: () => ShapeGeometry,
                ShapePath: () => ShapePath,
                ShapeUtils: () => Fl,
                ShortType: () => bi,
                Skeleton: () => Skeleton,
                SkeletonHelper: () => SkeletonHelper,
                SkinnedMesh: () => SkinnedMesh,
                SmoothShading: () => pn,
                Sphere: () => Sphere,
                SphereBufferGeometry: () => SphereBufferGeometry,
                SphereGeometry: () => SphereGeometry,
                Spherical: () => Spherical,
                SphericalHarmonics3: () => SphericalHarmonics3,
                Spline: () => Spline,
                SplineCurve: () => SplineCurve,
                SplineCurve3: () => SplineCurve3,
                SpotLight: () => SpotLight,
                SpotLightHelper: () => SpotLightHelper,
                Sprite: () => Sprite,
                SpriteMaterial: () => SpriteMaterial,
                SrcAlphaFactor: () => Pn,
                SrcAlphaSaturateFactor: () => Rn,
                SrcColorFactor: () => Ln,
                StaticCopyUsage: () => wa,
                StaticDrawUsage: () => xa,
                StaticReadUsage: () => Ma,
                StereoCamera: () => StereoCamera,
                StreamCopyUsage: () => La,
                StreamDrawUsage: () => ba,
                StreamReadUsage: () => Aa,
                StringKeyframeTrack: () => StringKeyframeTrack,
                SubtractEquation: () => bn,
                SubtractiveBlending: () => vn,
                TOUCH: () => $t,
                TangentSpaceNormalMap: () => ta,
                TetrahedronBufferGeometry: () => TetrahedronBufferGeometry,
                TetrahedronGeometry: () => TetrahedronGeometry,
                TextBufferGeometry: () => TextBufferGeometry,
                TextGeometry: () => TextGeometry,
                Texture: () => Texture,
                TextureLoader: () => TextureLoader,
                TorusBufferGeometry: () => TorusBufferGeometry,
                TorusGeometry: () => TorusGeometry,
                TorusKnotBufferGeometry: () => TorusKnotBufferGeometry,
                TorusKnotGeometry: () => TorusKnotGeometry,
                Triangle: () => Triangle,
                TriangleFanDrawMode: () => Wr,
                TriangleStripDrawMode: () => jr,
                TrianglesDrawMode: () => kr,
                TubeBufferGeometry: () => TubeBufferGeometry,
                TubeGeometry: () => TubeGeometry,
                UVMapping: () => $n,
                Uint16Attribute: () => Uint16Attribute,
                Uint16BufferAttribute: () => Uint16BufferAttribute,
                Uint32Attribute: () => Uint32Attribute,
                Uint32BufferAttribute: () => Uint32BufferAttribute,
                Uint8Attribute: () => Uint8Attribute,
                Uint8BufferAttribute: () => Uint8BufferAttribute,
                Uint8ClampedAttribute: () => Uint8ClampedAttribute,
                Uint8ClampedBufferAttribute: () => Uint8ClampedBufferAttribute,
                Uniform: () => Uniform,
                UniformsLib: () => Ss,
                UniformsUtils: () => ys,
                UnsignedByteType: () => xi,
                UnsignedInt248Type: () => Ei,
                UnsignedIntType: () => Ai,
                UnsignedShort4444Type: () => Li,
                UnsignedShort5551Type: () => Ci,
                UnsignedShort565Type: () => Pi,
                UnsignedShortType: () => Mi,
                VSMShadowMap: () => ln,
                Vector2: () => Vector2,
                Vector3: () => Vector3,
                Vector4: () => Vector4,
                VectorKeyframeTrack: () => VectorKeyframeTrack,
                Vertex: () => Vertex,
                VertexColors: () => Xc,
                VideoTexture: () => VideoTexture,
                WebGL1Renderer: () => WebGL1Renderer,
                WebGLCubeRenderTarget: () => WebGLCubeRenderTarget,
                WebGLMultisampleRenderTarget: () => WebGLMultisampleRenderTarget,
                WebGLRenderTarget: () => WebGLRenderTarget,
                WebGLRenderTargetCube: () => WebGLRenderTargetCube,
                WebGLRenderer: () => WebGLRenderer,
                WebGLUtils: () => WebGLUtils,
                WireframeGeometry: () => WireframeGeometry,
                WireframeHelper: () => WireframeHelper,
                WrapAroundEnding: () => Ur,
                XHRLoader: () => XHRLoader,
                ZeroCurvatureEnding: () => Dr,
                ZeroFactor: () => wn,
                ZeroSlopeEnding: () => Vr,
                ZeroStencilOp: () => ia,
                sRGBEncoding: () => Xr
            });
            const Zt = "124",
                Kt = {
                    LEFT: 0,
                    MIDDLE: 1,
                    RIGHT: 2,
                    ROTATE: 0,
                    DOLLY: 1,
                    PAN: 2
                },
                $t = {
                    ROTATE: 0,
                    PAN: 1,
                    DOLLY_PAN: 2,
                    DOLLY_ROTATE: 3
                },
                en = 0,
                tn = 1,
                nn = 2,
                rn = 3,
                an = 0,
                on = 1,
                sn = 2,
                ln = 3,
                cn = 0,
                un = 1,
                hn = 2,
                dn = 1,
                pn = 2,
                fn = 0,
                mn = 1,
                gn = 2,
                vn = 3,
                yn = 4,
                xn = 5,
                _n = 100,
                bn = 101,
                Mn = 102,
                Sn = 103,
                An = 104,
                wn = 200,
                Tn = 201,
                Ln = 202,
                Cn = 203,
                Pn = 204,
                En = 205,
                In = 206,
                Fn = 207,
                On = 208,
                Bn = 209,
                Rn = 210,
                Nn = 0,
                Dn = 1,
                Vn = 2,
                Un = 3,
                zn = 4,
                Gn = 5,
                kn = 6,
                jn = 7,
                Wn = 0,
                Hn = 1,
                Xn = 2,
                Yn = 0,
                qn = 1,
                Qn = 2,
                Jn = 3,
                Zn = 4,
                Kn = 5,
                $n = 300,
                ei = 301,
                ti = 302,
                ni = 303,
                ii = 304,
                ri = 306,
                ai = 307,
                oi = 1e3,
                si = 1001,
                li = 1002,
                ci = 1003,
                ui = 1004,
                hi = 1004,
                di = 1005,
                pi = 1005,
                fi = 1006,
                mi = 1007,
                gi = 1007,
                vi = 1008,
                yi = 1008,
                xi = 1009,
                _i = 1010,
                bi = 1011,
                Mi = 1012,
                Si = 1013,
                Ai = 1014,
                wi = 1015,
                Ti = 1016,
                Li = 1017,
                Ci = 1018,
                Pi = 1019,
                Ei = 1020,
                Ii = 1021,
                Fi = 1022,
                Oi = 1023,
                Bi = 1024,
                Ri = 1025,
                Ni = Oi,
                Di = 1026,
                Vi = 1027,
                Ui = 1028,
                zi = 1029,
                Gi = 1030,
                ki = 1031,
                ji = 1032,
                Wi = 1033,
                Hi = 33776,
                Xi = 33777,
                Yi = 33778,
                qi = 33779,
                Qi = 35840,
                Ji = 35841,
                Zi = 35842,
                Ki = 35843,
                $i = 36196,
                er = 37492,
                tr = 37496,
                nr = 37808,
                ir = 37809,
                rr = 37810,
                ar = 37811,
                or = 37812,
                sr = 37813,
                lr = 37814,
                cr = 37815,
                ur = 37816,
                hr = 37817,
                dr = 37818,
                pr = 37819,
                fr = 37820,
                mr = 37821,
                gr = 36492,
                vr = 37840,
                yr = 37841,
                xr = 37842,
                _r = 37843,
                br = 37844,
                Mr = 37845,
                Sr = 37846,
                Ar = 37847,
                wr = 37848,
                Tr = 37849,
                Lr = 37850,
                Cr = 37851,
                Pr = 37852,
                Er = 37853,
                Ir = 2200,
                Fr = 2201,
                Or = 2202,
                Br = 2300,
                Rr = 2301,
                Nr = 2302,
                Dr = 2400,
                Vr = 2401,
                Ur = 2402,
                zr = 2500,
                Gr = 2501,
                kr = 0,
                jr = 1,
                Wr = 2,
                Hr = 3e3,
                Xr = 3001,
                Yr = 3007,
                qr = 3002,
                Qr = 3003,
                Jr = 3004,
                Zr = 3005,
                Kr = 3006,
                $r = 3200,
                ea = 3201,
                ta = 0,
                na = 1,
                ia = 0,
                ra = 7680,
                aa = 7681,
                oa = 7682,
                sa = 7683,
                la = 34055,
                ca = 34056,
                ua = 5386,
                ha = 512,
                da = 513,
                pa = 514,
                fa = 515,
                ma = 516,
                ga = 517,
                va = 518,
                ya = 519,
                xa = 35044,
                _a = 35048,
                ba = 35040,
                Ma = 35045,
                Sa = 35049,
                Aa = 35041,
                wa = 35046,
                Ta = 35050,
                La = 35042,
                Ca = "100",
                Pa = "300 es";
            Object.assign(EventDispatcher.prototype, {
                addEventListener: function(e, t) {
                    void 0 === this._listeners && (this._listeners = {});
                    const n = this._listeners;
                    void 0 === n[e] && (n[e] = []), -1 === n[e].indexOf(t) && n[e].push(t)
                },
                hasEventListener: function(e, t) {
                    if (void 0 === this._listeners) return !1;
                    const n = this._listeners;
                    return void 0 !== n[e] && -1 !== n[e].indexOf(t)
                },
                removeEventListener: function(e, t) {
                    if (void 0 === this._listeners) return;
                    const n = this._listeners[e];
                    if (void 0 !== n) {
                        const e = n.indexOf(t); - 1 !== e && n.splice(e, 1)
                    }
                },
                dispatchEvent: function(e) {
                    if (void 0 === this._listeners) return;
                    const t = this._listeners[e.type];
                    if (void 0 !== t) {
                        e.target = this;
                        const n = t.slice(0);
                        for (let t = 0, i = n.length; t < i; t++) n[t].call(this, e)
                    }
                }
            });
            const Ea = [];
            for (let e = 0; e < 256; e++) Ea[e] = (e < 16 ? "0" : "") + e.toString(16);
            let Ia = 1234567;
            const Fa = {
                DEG2RAD: Math.PI / 180,
                RAD2DEG: 180 / Math.PI,
                generateUUID: function() {
                    const e = 4294967295 * Math.random() | 0,
                        t = 4294967295 * Math.random() | 0,
                        n = 4294967295 * Math.random() | 0,
                        i = 4294967295 * Math.random() | 0;
                    return (Ea[255 & e] + Ea[e >> 8 & 255] + Ea[e >> 16 & 255] + Ea[e >> 24 & 255] + "-" + Ea[255 & t] + Ea[t >> 8 & 255] + "-" + Ea[t >> 16 & 15 | 64] + Ea[t >> 24 & 255] + "-" + Ea[63 & n | 128] + Ea[n >> 8 & 255] + "-" + Ea[n >> 16 & 255] + Ea[n >> 24 & 255] + Ea[255 & i] + Ea[i >> 8 & 255] + Ea[i >> 16 & 255] + Ea[i >> 24 & 255]).toUpperCase()
                },
                clamp: function(e, t, n) {
                    return Math.max(t, Math.min(n, e))
                },
                euclideanModulo: function(e, t) {
                    return (e % t + t) % t
                },
                mapLinear: function(e, t, n, i, r) {
                    return i + (e - t) * (r - i) / (n - t)
                },
                lerp: function(e, t, n) {
                    return (1 - n) * e + n * t
                },
                smoothstep: function(e, t, n) {
                    return e <= t ? 0 : e >= n ? 1 : (e = (e - t) / (n - t)) * e * (3 - 2 * e)
                },
                smootherstep: function(e, t, n) {
                    return e <= t ? 0 : e >= n ? 1 : (e = (e - t) / (n - t)) * e * e * (e * (6 * e - 15) + 10)
                },
                randInt: function(e, t) {
                    return e + Math.floor(Math.random() * (t - e + 1))
                },
                randFloat: function(e, t) {
                    return e + Math.random() * (t - e)
                },
                randFloatSpread: function(e) {
                    return e * (.5 - Math.random())
                },
                seededRandom: function(e) {
                    return void 0 !== e && (Ia = e % 2147483647), Ia = 16807 * Ia % 2147483647, (Ia - 1) / 2147483646
                },
                degToRad: function(e) {
                    return e * Fa.DEG2RAD
                },
                radToDeg: function(e) {
                    return e * Fa.RAD2DEG
                },
                isPowerOfTwo: function(e) {
                    return 0 == (e & e - 1) && 0 !== e
                },
                ceilPowerOfTwo: function(e) {
                    return Math.pow(2, Math.ceil(Math.log(e) / Math.LN2))
                },
                floorPowerOfTwo: function(e) {
                    return Math.pow(2, Math.floor(Math.log(e) / Math.LN2))
                },
                setQuaternionFromProperEuler: function(e, t, n, i, r) {
                    const a = Math.cos,
                        o = Math.sin,
                        s = a(n / 2),
                        l = o(n / 2),
                        c = a((t + i) / 2),
                        u = o((t + i) / 2),
                        h = a((t - i) / 2),
                        d = o((t - i) / 2),
                        p = a((i - t) / 2),
                        f = o((i - t) / 2);
                    switch (r) {
                        case "XYX":
                            e.set(s * u, l * h, l * d, s * c);
                            break;
                        case "YZY":
                            e.set(l * d, s * u, l * h, s * c);
                            break;
                        case "ZXZ":
                            e.set(l * h, l * d, s * u, s * c);
                            break;
                        case "XZX":
                            e.set(s * u, l * f, l * p, s * c);
                            break;
                        case "YXY":
                            e.set(l * p, s * u, l * f, s * c);
                            break;
                        case "ZYZ":
                            e.set(l * f, l * p, s * u, s * c)
                    }
                }
            };
            class Vector2 {
                constructor(e = 0, t = 0) {
                    Object.defineProperty(this, "isVector2", {
                        value: !0
                    }), this.x = e, this.y = t
                }
                get width() {
                    return this.x
                }
                set width(e) {
                    this.x = e
                }
                get height() {
                    return this.y
                }
                set height(e) {
                    this.y = e
                }
                set(e, t) {
                    return this.x = e, this.y = t, this
                }
                setScalar(e) {
                    return this.x = e, this.y = e, this
                }
                setX(e) {
                    return this.x = e, this
                }
                setY(e) {
                    return this.y = e, this
                }
                setComponent(e, t) {
                    switch (e) {
                        case 0:
                            this.x = t;
                            break;
                        case 1:
                            this.y = t;
                            break;
                        default:
                            throw Error("index is out of range: " + e)
                    }
                    return this
                }
                getComponent(e) {
                    switch (e) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        default:
                            throw Error("index is out of range: " + e)
                    }
                }
                clone() {
                    return new this.constructor(this.x, this.y)
                }
                copy(e) {
                    return this.x = e.x, this.y = e.y, this
                }
                add(e, t) {
                    return void 0 !== t ? this.addVectors(e, t) : (this.x += e.x, this.y += e.y, this)
                }
                addScalar(e) {
                    return this.x += e, this.y += e, this
                }
                addVectors(e, t) {
                    return this.x = e.x + t.x, this.y = e.y + t.y, this
                }
                addScaledVector(e, t) {
                    return this.x += e.x * t, this.y += e.y * t, this
                }
                sub(e, t) {
                    return void 0 !== t ? this.subVectors(e, t) : (this.x -= e.x, this.y -= e.y, this)
                }
                subScalar(e) {
                    return this.x -= e, this.y -= e, this
                }
                subVectors(e, t) {
                    return this.x = e.x - t.x, this.y = e.y - t.y, this
                }
                multiply(e) {
                    return this.x *= e.x, this.y *= e.y, this
                }
                multiplyScalar(e) {
                    return this.x *= e, this.y *= e, this
                }
                divide(e) {
                    return this.x /= e.x, this.y /= e.y, this
                }
                divideScalar(e) {
                    return this.multiplyScalar(1 / e)
                }
                applyMatrix3(e) {
                    const t = this.x,
                        n = this.y,
                        i = e.elements;
                    return this.x = i[0] * t + i[3] * n + i[6], this.y = i[1] * t + i[4] * n + i[7], this
                }
                min(e) {
                    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this
                }
                max(e) {
                    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this
                }
                clamp(e, t) {
                    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this
                }
                clampScalar(e, t) {
                    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this
                }
                clampLength(e, t) {
                    const n = this.length();
                    return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
                }
                floor() {
                    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
                }
                ceil() {
                    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
                }
                round() {
                    return this.x = Math.round(this.x), this.y = Math.round(this.y), this
                }
                roundToZero() {
                    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this
                }
                negate() {
                    return this.x = -this.x, this.y = -this.y, this
                }
                dot(e) {
                    return this.x * e.x + this.y * e.y
                }
                cross(e) {
                    return this.x * e.y - this.y * e.x
                }
                lengthSq() {
                    return this.x * this.x + this.y * this.y
                }
                length() {
                    return Math.sqrt(this.x * this.x + this.y * this.y)
                }
                manhattanLength() {
                    return Math.abs(this.x) + Math.abs(this.y)
                }
                normalize() {
                    return this.divideScalar(this.length() || 1)
                }
                angle() {
                    return Math.atan2(-this.y, -this.x) + Math.PI
                }
                distanceTo(e) {
                    return Math.sqrt(this.distanceToSquared(e))
                }
                distanceToSquared(e) {
                    const t = this.x - e.x,
                        n = this.y - e.y;
                    return t * t + n * n
                }
                manhattanDistanceTo(e) {
                    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y)
                }
                setLength(e) {
                    return this.normalize().multiplyScalar(e)
                }
                lerp(e, t) {
                    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this
                }
                lerpVectors(e, t, n) {
                    return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this
                }
                equals(e) {
                    return e.x === this.x && e.y === this.y
                }
                fromArray(e, t = 0) {
                    return this.x = e[t], this.y = e[t + 1], this
                }
                toArray(e = [], t = 0) {
                    return e[t] = this.x, e[t + 1] = this.y, e
                }
                fromBufferAttribute(e, t, n) {
                    return this.x = e.getX(t), this.y = e.getY(t), this
                }
                rotateAround(e, t) {
                    const n = Math.cos(t),
                        i = Math.sin(t),
                        r = this.x - e.x,
                        a = this.y - e.y;
                    return this.x = r * n - a * i + e.x, this.y = r * i + a * n + e.y, this
                }
                random() {
                    return this.x = Math.random(), this.y = Math.random(), this
                }
            }
            class Matrix3 {
                constructor() {
                    Object.defineProperty(this, "isMatrix3", {
                        value: !0
                    }), this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]
                }
                set(e, t, n, i, r, a, o, s, l) {
                    const c = this.elements;
                    return c[0] = e, c[1] = i, c[2] = o, c[3] = t, c[4] = r, c[5] = s, c[6] = n, c[7] = a, c[8] = l, this
                }
                identity() {
                    return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
                }
                clone() {
                    return (new this.constructor).fromArray(this.elements)
                }
                copy(e) {
                    const t = this.elements,
                        n = e.elements;
                    return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], this
                }
                extractBasis(e, t, n) {
                    return e.setFromMatrix3Column(this, 0), t.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this
                }
                setFromMatrix4(e) {
                    const t = e.elements;
                    return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this
                }
                multiply(e) {
                    return this.multiplyMatrices(this, e)
                }
                premultiply(e) {
                    return this.multiplyMatrices(e, this)
                }
                multiplyMatrices(e, t) {
                    const n = e.elements,
                        i = t.elements,
                        r = this.elements,
                        a = n[0],
                        o = n[3],
                        s = n[6],
                        l = n[1],
                        c = n[4],
                        u = n[7],
                        h = n[2],
                        d = n[5],
                        p = n[8],
                        f = i[0],
                        m = i[3],
                        g = i[6],
                        y = i[1],
                        x = i[4],
                        _ = i[7],
                        b = i[2],
                        M = i[5],
                        S = i[8];
                    return r[0] = a * f + o * y + s * b, r[3] = a * m + o * x + s * M, r[6] = a * g + o * _ + s * S, r[1] = l * f + c * y + u * b, r[4] = l * m + c * x + u * M, r[7] = l * g + c * _ + u * S, r[2] = h * f + d * y + p * b, r[5] = h * m + d * x + p * M, r[8] = h * g + d * _ + p * S, this
                }
                multiplyScalar(e) {
                    const t = this.elements;
                    return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this
                }
                determinant() {
                    const e = this.elements,
                        t = e[0],
                        n = e[1],
                        i = e[2],
                        r = e[3],
                        a = e[4],
                        o = e[5],
                        s = e[6],
                        l = e[7],
                        c = e[8];
                    return t * a * c - t * o * l - n * r * c + n * o * s + i * r * l - i * a * s
                }
                invert() {
                    const e = this.elements,
                        t = e[0],
                        n = e[1],
                        i = e[2],
                        r = e[3],
                        a = e[4],
                        o = e[5],
                        s = e[6],
                        l = e[7],
                        c = e[8],
                        u = c * a - o * l,
                        h = o * s - c * r,
                        d = l * r - a * s,
                        p = t * u + n * h + i * d;
                    if (0 === p) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
                    const f = 1 / p;
                    return e[0] = u * f, e[1] = (i * l - c * n) * f, e[2] = (o * n - i * a) * f, e[3] = h * f, e[4] = (c * t - i * s) * f, e[5] = (i * r - o * t) * f, e[6] = d * f, e[7] = (n * s - l * t) * f, e[8] = (a * t - n * r) * f, this
                }
                transpose() {
                    let e;
                    const t = this.elements;
                    return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this
                }
                getNormalMatrix(e) {
                    return this.setFromMatrix4(e).copy(this).invert().transpose()
                }
                transposeIntoArray(e) {
                    const t = this.elements;
                    return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this
                }
                setUvTransform(e, t, n, i, r, a, o) {
                    const s = Math.cos(r),
                        l = Math.sin(r);
                    return this.set(n * s, n * l, -n * (s * a + l * o) + a + e, -i * l, i * s, -i * (-l * a + s * o) + o + t, 0, 0, 1), this
                }
                scale(e, t) {
                    const n = this.elements;
                    return n[0] *= e, n[3] *= e, n[6] *= e, n[1] *= t, n[4] *= t, n[7] *= t, this
                }
                rotate(e) {
                    const t = Math.cos(e),
                        n = Math.sin(e),
                        i = this.elements,
                        r = i[0],
                        a = i[3],
                        o = i[6],
                        s = i[1],
                        l = i[4],
                        c = i[7];
                    return i[0] = t * r + n * s, i[3] = t * a + n * l, i[6] = t * o + n * c, i[1] = -n * r + t * s, i[4] = -n * a + t * l, i[7] = -n * o + t * c, this
                }
                translate(e, t) {
                    const n = this.elements;
                    return n[0] += e * n[2], n[3] += e * n[5], n[6] += e * n[8], n[1] += t * n[2], n[4] += t * n[5], n[7] += t * n[8], this
                }
                equals(e) {
                    const t = this.elements,
                        n = e.elements;
                    for (let e = 0; e < 9; e++)
                        if (t[e] !== n[e]) return !1;
                    return !0
                }
                fromArray(e, t = 0) {
                    for (let n = 0; n < 9; n++) this.elements[n] = e[n + t];
                    return this
                }
                toArray(e = [], t = 0) {
                    const n = this.elements;
                    return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e
                }
            }
            let Oa;
            const Ba = {
                getDataURL: function(e) {
                    if (/^data:/i.test(e.src)) return e.src;
                    if ("undefined" == typeof HTMLCanvasElement) return e.src;
                    let t;
                    if (e instanceof HTMLCanvasElement) t = e;
                    else {
                        void 0 === Oa && (Oa = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")), Oa.width = e.width, Oa.height = e.height;
                        const n = Oa.getContext("2d");
                        e instanceof ImageData ? n.putImageData(e, 0, 0) : n.drawImage(e, 0, 0, e.width, e.height), t = Oa
                    }
                    return t.width > 2048 || t.height > 2048 ? t.toDataURL("image/jpeg", .6) : t.toDataURL("image/png")
                }
            };
            let Ra = 0;
            Texture.DEFAULT_IMAGE = void 0, Texture.DEFAULT_MAPPING = $n, Texture.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
                constructor: Texture,
                isTexture: !0,
                updateMatrix: function() {
                    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(e) {
                    return this.name = e.name, this.image = e.image, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.encoding = e.encoding, this
                },
                toJSON: function(e) {
                    const t = void 0 === e || "string" == typeof e;
                    if (!t && void 0 !== e.textures[this.uuid]) return e.textures[this.uuid];
                    const n = {
                        metadata: {
                            version: 4.5,
                            type: "Texture",
                            generator: "Texture.toJSON"
                        },
                        uuid: this.uuid,
                        name: this.name,
                        mapping: this.mapping,
                        repeat: [this.repeat.x, this.repeat.y],
                        offset: [this.offset.x, this.offset.y],
                        center: [this.center.x, this.center.y],
                        rotation: this.rotation,
                        wrap: [this.wrapS, this.wrapT],
                        format: this.format,
                        type: this.type,
                        encoding: this.encoding,
                        minFilter: this.minFilter,
                        magFilter: this.magFilter,
                        anisotropy: this.anisotropy,
                        flipY: this.flipY,
                        premultiplyAlpha: this.premultiplyAlpha,
                        unpackAlignment: this.unpackAlignment
                    };
                    if (void 0 !== this.image) {
                        const i = this.image;
                        if (void 0 === i.uuid && (i.uuid = Fa.generateUUID()), !t && void 0 === e.images[i.uuid]) {
                            let t;
                            if (Array.isArray(i)) {
                                t = [];
                                for (let e = 0, n = i.length; e < n; e++) i[e].isDataTexture ? t.push(serializeImage(i[e].image)) : t.push(serializeImage(i[e]))
                            } else t = serializeImage(i);
                            e.images[i.uuid] = {
                                uuid: i.uuid,
                                url: t
                            }
                        }
                        n.image = i.uuid
                    }
                    return t || (e.textures[this.uuid] = n), n
                },
                dispose: function() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                },
                transformUv: function(e) {
                    if (this.mapping !== $n) return e;
                    if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1) switch (this.wrapS) {
                        case oi:
                            e.x = e.x - Math.floor(e.x);
                            break;
                        case si:
                            e.x = e.x < 0 ? 0 : 1;
                            break;
                        case li:
                            1 === Math.abs(Math.floor(e.x) % 2) ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x)
                    }
                    if (e.y < 0 || e.y > 1) switch (this.wrapT) {
                        case oi:
                            e.y = e.y - Math.floor(e.y);
                            break;
                        case si:
                            e.y = e.y < 0 ? 0 : 1;
                            break;
                        case li:
                            1 === Math.abs(Math.floor(e.y) % 2) ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y)
                    }
                    return this.flipY && (e.y = 1 - e.y), e
                }
            }), Object.defineProperty(Texture.prototype, "needsUpdate", {
                set: function(e) {
                    !0 === e && this.version++
                }
            });
            class Vector4 {
                constructor(e = 0, t = 0, n = 0, i = 1) {
                    Object.defineProperty(this, "isVector4", {
                        value: !0
                    }), this.x = e, this.y = t, this.z = n, this.w = i
                }
                get width() {
                    return this.z
                }
                set width(e) {
                    this.z = e
                }
                get height() {
                    return this.w
                }
                set height(e) {
                    this.w = e
                }
                set(e, t, n, i) {
                    return this.x = e, this.y = t, this.z = n, this.w = i, this
                }
                setScalar(e) {
                    return this.x = e, this.y = e, this.z = e, this.w = e, this
                }
                setX(e) {
                    return this.x = e, this
                }
                setY(e) {
                    return this.y = e, this
                }
                setZ(e) {
                    return this.z = e, this
                }
                setW(e) {
                    return this.w = e, this
                }
                setComponent(e, t) {
                    switch (e) {
                        case 0:
                            this.x = t;
                            break;
                        case 1:
                            this.y = t;
                            break;
                        case 2:
                            this.z = t;
                            break;
                        case 3:
                            this.w = t;
                            break;
                        default:
                            throw Error("index is out of range: " + e)
                    }
                    return this
                }
                getComponent(e) {
                    switch (e) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        case 2:
                            return this.z;
                        case 3:
                            return this.w;
                        default:
                            throw Error("index is out of range: " + e)
                    }
                }
                clone() {
                    return new this.constructor(this.x, this.y, this.z, this.w)
                }
                copy(e) {
                    return this.x = e.x, this.y = e.y, this.z = e.z, this.w = void 0 !== e.w ? e.w : 1, this
                }
                add(e, t) {
                    return void 0 !== t ? this.addVectors(e, t) : (this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this)
                }
                addScalar(e) {
                    return this.x += e, this.y += e, this.z += e, this.w += e, this
                }
                addVectors(e, t) {
                    return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this
                }
                addScaledVector(e, t) {
                    return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this
                }
                sub(e, t) {
                    return void 0 !== t ? this.subVectors(e, t) : (this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this)
                }
                subScalar(e) {
                    return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this
                }
                subVectors(e, t) {
                    return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this
                }
                multiplyScalar(e) {
                    return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this
                }
                applyMatrix4(e) {
                    const t = this.x,
                        n = this.y,
                        i = this.z,
                        r = this.w,
                        a = e.elements;
                    return this.x = a[0] * t + a[4] * n + a[8] * i + a[12] * r, this.y = a[1] * t + a[5] * n + a[9] * i + a[13] * r, this.z = a[2] * t + a[6] * n + a[10] * i + a[14] * r, this.w = a[3] * t + a[7] * n + a[11] * i + a[15] * r, this
                }
                divideScalar(e) {
                    return this.multiplyScalar(1 / e)
                }
                setAxisAngleFromQuaternion(e) {
                    this.w = 2 * Math.acos(e.w);
                    const t = Math.sqrt(1 - e.w * e.w);
                    return t < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this
                }
                setAxisAngleFromRotationMatrix(e) {
                    let t, n, i, r;
                    const a = .01,
                        o = .1,
                        s = e.elements,
                        l = s[0],
                        c = s[4],
                        u = s[8],
                        h = s[1],
                        d = s[5],
                        p = s[9],
                        f = s[2],
                        m = s[6],
                        g = s[10];
                    if (Math.abs(c - h) < a && Math.abs(u - f) < a && Math.abs(p - m) < a) {
                        if (Math.abs(c + h) < o && Math.abs(u + f) < o && Math.abs(p + m) < o && Math.abs(l + d + g - 3) < o) return this.set(1, 0, 0, 0), this;
                        t = Math.PI;
                        const e = (l + 1) / 2,
                            s = (d + 1) / 2,
                            y = (g + 1) / 2,
                            x = (c + h) / 4,
                            _ = (u + f) / 4,
                            b = (p + m) / 4;
                        return e > s && e > y ? e < a ? (n = 0, i = .707106781, r = .707106781) : (n = Math.sqrt(e), i = x / n, r = _ / n) : s > y ? s < a ? (n = .707106781, i = 0, r = .707106781) : (i = Math.sqrt(s), n = x / i, r = b / i) : y < a ? (n = .707106781, i = .707106781, r = 0) : (r = Math.sqrt(y), n = _ / r, i = b / r), this.set(n, i, r, 3.141592653589793), this
                    }
                    let y = Math.sqrt((m - p) * (m - p) + (u - f) * (u - f) + (h - c) * (h - c));
                    return Math.abs(y) < .001 && (y = 1), this.x = (m - p) / y, this.y = (u - f) / y, this.z = (h - c) / y, this.w = Math.acos((l + d + g - 1) / 2), this
                }
                min(e) {
                    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this
                }
                max(e) {
                    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this
                }
                clamp(e, t) {
                    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this.w = Math.max(e.w, Math.min(t.w, this.w)), this
                }
                clampScalar(e, t) {
                    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this.w = Math.max(e, Math.min(t, this.w)), this
                }
                clampLength(e, t) {
                    const n = this.length();
                    return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
                }
                floor() {
                    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
                }
                ceil() {
                    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
                }
                round() {
                    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
                }
                roundToZero() {
                    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this
                }
                negate() {
                    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
                }
                dot(e) {
                    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w
                }
                lengthSq() {
                    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
                }
                length() {
                    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
                }
                manhattanLength() {
                    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
                }
                normalize() {
                    return this.divideScalar(this.length() || 1)
                }
                setLength(e) {
                    return this.normalize().multiplyScalar(e)
                }
                lerp(e, t) {
                    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this
                }
                lerpVectors(e, t, n) {
                    return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this.z = e.z + (t.z - e.z) * n, this.w = e.w + (t.w - e.w) * n, this
                }
                equals(e) {
                    return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
                }
                fromArray(e, t = 0) {
                    return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this
                }
                toArray(e = [], t = 0) {
                    return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e
                }
                fromBufferAttribute(e, t, n) {
                    return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this.w = e.getW(t), this
                }
                random() {
                    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this
                }
            }
            WebGLRenderTarget.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
                constructor: WebGLRenderTarget,
                isWebGLRenderTarget: !0,
                setSize: function(e, t) {
                    this.width === e && this.height === t || (this.width = e, this.height = t, this.texture.image.width = e, this.texture.image.height = t, this.dispose()), this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t)
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(e) {
                    return this.width = e.width, this.height = e.height, this.viewport.copy(e.viewport), this.texture = e.texture.clone(), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, this.depthTexture = e.depthTexture, this
                },
                dispose: function() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            }), WebGLMultisampleRenderTarget.prototype = Object.assign(Object.create(WebGLRenderTarget.prototype), {
                constructor: WebGLMultisampleRenderTarget,
                isWebGLMultisampleRenderTarget: !0,
                copy: function(e) {
                    return WebGLRenderTarget.prototype.copy.call(this, e), this.samples = e.samples, this
                }
            });
            class Quaternion {
                constructor(e = 0, t = 0, n = 0, i = 1) {
                    Object.defineProperty(this, "isQuaternion", {
                        value: !0
                    }), this._x = e, this._y = t, this._z = n, this._w = i
                }
                static slerp(e, t, n, i) {
                    return n.copy(e).slerp(t, i)
                }
                static slerpFlat(e, t, n, i, r, a, o) {
                    let s = n[i + 0],
                        l = n[i + 1],
                        c = n[i + 2],
                        u = n[i + 3];
                    const h = r[a + 0],
                        d = r[a + 1],
                        p = r[a + 2],
                        f = r[a + 3];
                    if (u !== f || s !== h || l !== d || c !== p) {
                        let e = 1 - o;
                        const t = s * h + l * d + c * p + u * f,
                            n = t >= 0 ? 1 : -1,
                            i = 1 - t * t;
                        if (i > Number.EPSILON) {
                            const r = Math.sqrt(i),
                                a = Math.atan2(r, t * n);
                            e = Math.sin(e * a) / r, o = Math.sin(o * a) / r
                        }
                        const r = o * n;
                        if (s = s * e + h * r, l = l * e + d * r, c = c * e + p * r, u = u * e + f * r, e === 1 - o) {
                            const e = 1 / Math.sqrt(s * s + l * l + c * c + u * u);
                            s *= e, l *= e, c *= e, u *= e
                        }
                    }
                    e[t] = s, e[t + 1] = l, e[t + 2] = c, e[t + 3] = u
                }
                static multiplyQuaternionsFlat(e, t, n, i, r, a) {
                    const o = n[i],
                        s = n[i + 1],
                        l = n[i + 2],
                        c = n[i + 3],
                        u = r[a],
                        h = r[a + 1],
                        d = r[a + 2],
                        p = r[a + 3];
                    return e[t] = o * p + c * u + s * d - l * h, e[t + 1] = s * p + c * h + l * u - o * d, e[t + 2] = l * p + c * d + o * h - s * u, e[t + 3] = c * p - o * u - s * h - l * d, e
                }
                get x() {
                    return this._x
                }
                set x(e) {
                    this._x = e, this._onChangeCallback()
                }
                get y() {
                    return this._y
                }
                set y(e) {
                    this._y = e, this._onChangeCallback()
                }
                get z() {
                    return this._z
                }
                set z(e) {
                    this._z = e, this._onChangeCallback()
                }
                get w() {
                    return this._w
                }
                set w(e) {
                    this._w = e, this._onChangeCallback()
                }
                set(e, t, n, i) {
                    return this._x = e, this._y = t, this._z = n, this._w = i, this._onChangeCallback(), this
                }
                clone() {
                    return new this.constructor(this._x, this._y, this._z, this._w)
                }
                copy(e) {
                    return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this
                }
                setFromEuler(e, t) {
                    if (!e || !e.isEuler) throw Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
                    const n = e._x,
                        i = e._y,
                        r = e._z,
                        a = e._order,
                        o = Math.cos,
                        s = Math.sin,
                        l = o(n / 2),
                        c = o(i / 2),
                        u = o(r / 2),
                        h = s(n / 2),
                        d = s(i / 2),
                        p = s(r / 2);
                    switch (a) {
                        case "XYZ":
                            this._x = h * c * u + l * d * p, this._y = l * d * u - h * c * p, this._z = l * c * p + h * d * u, this._w = l * c * u - h * d * p;
                            break;
                        case "YXZ":
                            this._x = h * c * u + l * d * p, this._y = l * d * u - h * c * p, this._z = l * c * p - h * d * u, this._w = l * c * u + h * d * p;
                            break;
                        case "ZXY":
                            this._x = h * c * u - l * d * p, this._y = l * d * u + h * c * p, this._z = l * c * p + h * d * u, this._w = l * c * u - h * d * p;
                            break;
                        case "ZYX":
                            this._x = h * c * u - l * d * p, this._y = l * d * u + h * c * p, this._z = l * c * p - h * d * u, this._w = l * c * u + h * d * p;
                            break;
                        case "YZX":
                            this._x = h * c * u + l * d * p, this._y = l * d * u + h * c * p, this._z = l * c * p - h * d * u, this._w = l * c * u - h * d * p;
                            break;
                        case "XZY":
                            this._x = h * c * u - l * d * p, this._y = l * d * u - h * c * p, this._z = l * c * p + h * d * u, this._w = l * c * u + h * d * p
                    }
                    return !1 !== t && this._onChangeCallback(), this
                }
                setFromAxisAngle(e, t) {
                    const n = t / 2,
                        i = Math.sin(n);
                    return this._x = e.x * i, this._y = e.y * i, this._z = e.z * i, this._w = Math.cos(n), this._onChangeCallback(), this
                }
                setFromRotationMatrix(e) {
                    const t = e.elements,
                        n = t[0],
                        i = t[4],
                        r = t[8],
                        a = t[1],
                        o = t[5],
                        s = t[9],
                        l = t[2],
                        c = t[6],
                        u = t[10],
                        h = n + o + u;
                    if (h > 0) {
                        const e = .5 / Math.sqrt(h + 1);
                        this._w = .25 / e, this._x = (c - s) * e, this._y = (r - l) * e, this._z = (a - i) * e
                    } else if (n > o && n > u) {
                        const e = 2 * Math.sqrt(1 + n - o - u);
                        this._w = (c - s) / e, this._x = .25 * e, this._y = (i + a) / e, this._z = (r + l) / e
                    } else if (o > u) {
                        const e = 2 * Math.sqrt(1 + o - n - u);
                        this._w = (r - l) / e, this._x = (i + a) / e, this._y = .25 * e, this._z = (s + c) / e
                    } else {
                        const e = 2 * Math.sqrt(1 + u - n - o);
                        this._w = (a - i) / e, this._x = (r + l) / e, this._y = (s + c) / e, this._z = .25 * e
                    }
                    return this._onChangeCallback(), this
                }
                setFromUnitVectors(e, t) {
                    let n = e.dot(t) + 1;
                    return n < 1e-6 ? (n = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = n) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = n)) : (this._x = e.y * t.z - e.z * t.y, this._y = e.z * t.x - e.x * t.z, this._z = e.x * t.y - e.y * t.x, this._w = n), this.normalize()
                }
                angleTo(e) {
                    return 2 * Math.acos(Math.abs(Fa.clamp(this.dot(e), -1, 1)))
                }
                rotateTowards(e, t) {
                    const n = this.angleTo(e);
                    if (0 === n) return this;
                    const i = Math.min(1, t / n);
                    return this.slerp(e, i), this
                }
                identity() {
                    return this.set(0, 0, 0, 1)
                }
                invert() {
                    return this.conjugate()
                }
                conjugate() {
                    return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this
                }
                dot(e) {
                    return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
                }
                lengthSq() {
                    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
                }
                length() {
                    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
                }
                normalize() {
                    let e = this.length();
                    return 0 === e ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this
                }
                multiply(e, t) {
                    return void 0 !== t ? this.multiplyQuaternions(e, t) : this.multiplyQuaternions(this, e)
                }
                premultiply(e) {
                    return this.multiplyQuaternions(e, this)
                }
                multiplyQuaternions(e, t) {
                    const n = e._x,
                        i = e._y,
                        r = e._z,
                        a = e._w,
                        o = t._x,
                        s = t._y,
                        l = t._z,
                        c = t._w;
                    return this._x = n * c + a * o + i * l - r * s, this._y = i * c + a * s + r * o - n * l, this._z = r * c + a * l + n * s - i * o, this._w = a * c - n * o - i * s - r * l, this._onChangeCallback(), this
                }
                slerp(e, t) {
                    if (0 === t) return this;
                    if (1 === t) return this.copy(e);
                    const n = this._x,
                        i = this._y,
                        r = this._z,
                        a = this._w;
                    let o = a * e._w + n * e._x + i * e._y + r * e._z;
                    if (o < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, o = -o) : this.copy(e), o >= 1) return this._w = a, this._x = n, this._y = i, this._z = r, this;
                    const s = 1 - o * o;
                    if (s <= Number.EPSILON) {
                        const e = 1 - t;
                        return this._w = e * a + t * this._w, this._x = e * n + t * this._x, this._y = e * i + t * this._y, this._z = e * r + t * this._z, this.normalize(), this._onChangeCallback(), this
                    }
                    const l = Math.sqrt(s),
                        c = Math.atan2(l, o),
                        u = Math.sin((1 - t) * c) / l,
                        h = Math.sin(t * c) / l;
                    return this._w = a * u + this._w * h, this._x = n * u + this._x * h, this._y = i * u + this._y * h, this._z = r * u + this._z * h, this._onChangeCallback(), this
                }
                equals(e) {
                    return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w
                }
                fromArray(e, t = 0) {
                    return this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this._onChangeCallback(), this
                }
                toArray(e = [], t = 0) {
                    return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e
                }
                fromBufferAttribute(e, t) {
                    return this._x = e.getX(t), this._y = e.getY(t), this._z = e.getZ(t), this._w = e.getW(t), this
                }
                _onChange(e) {
                    return this._onChangeCallback = e, this
                }
                _onChangeCallback() {}
            }
            class Vector3 {
                constructor(e = 0, t = 0, n = 0) {
                    Object.defineProperty(this, "isVector3", {
                        value: !0
                    }), this.x = e, this.y = t, this.z = n
                }
                set(e, t, n) {
                    return void 0 === n && (n = this.z), this.x = e, this.y = t, this.z = n, this
                }
                setScalar(e) {
                    return this.x = e, this.y = e, this.z = e, this
                }
                setX(e) {
                    return this.x = e, this
                }
                setY(e) {
                    return this.y = e, this
                }
                setZ(e) {
                    return this.z = e, this
                }
                setComponent(e, t) {
                    switch (e) {
                        case 0:
                            this.x = t;
                            break;
                        case 1:
                            this.y = t;
                            break;
                        case 2:
                            this.z = t;
                            break;
                        default:
                            throw Error("index is out of range: " + e)
                    }
                    return this
                }
                getComponent(e) {
                    switch (e) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        case 2:
                            return this.z;
                        default:
                            throw Error("index is out of range: " + e)
                    }
                }
                clone() {
                    return new this.constructor(this.x, this.y, this.z)
                }
                copy(e) {
                    return this.x = e.x, this.y = e.y, this.z = e.z, this
                }
                add(e, t) {
                    return void 0 !== t ? this.addVectors(e, t) : (this.x += e.x, this.y += e.y, this.z += e.z, this)
                }
                addScalar(e) {
                    return this.x += e, this.y += e, this.z += e, this
                }
                addVectors(e, t) {
                    return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this
                }
                addScaledVector(e, t) {
                    return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this
                }
                sub(e, t) {
                    return void 0 !== t ? this.subVectors(e, t) : (this.x -= e.x, this.y -= e.y, this.z -= e.z, this)
                }
                subScalar(e) {
                    return this.x -= e, this.y -= e, this.z -= e, this
                }
                subVectors(e, t) {
                    return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this
                }
                multiply(e, t) {
                    return void 0 !== t ? this.multiplyVectors(e, t) : (this.x *= e.x, this.y *= e.y, this.z *= e.z, this)
                }
                multiplyScalar(e) {
                    return this.x *= e, this.y *= e, this.z *= e, this
                }
                multiplyVectors(e, t) {
                    return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this
                }
                applyEuler(e) {
                    return !e || e.isEuler, this.applyQuaternion(Da.setFromEuler(e))
                }
                applyAxisAngle(e, t) {
                    return this.applyQuaternion(Da.setFromAxisAngle(e, t))
                }
                applyMatrix3(e) {
                    const t = this.x,
                        n = this.y,
                        i = this.z,
                        r = e.elements;
                    return this.x = r[0] * t + r[3] * n + r[6] * i, this.y = r[1] * t + r[4] * n + r[7] * i, this.z = r[2] * t + r[5] * n + r[8] * i, this
                }
                applyNormalMatrix(e) {
                    return this.applyMatrix3(e).normalize()
                }
                applyMatrix4(e) {
                    const t = this.x,
                        n = this.y,
                        i = this.z,
                        r = e.elements,
                        a = 1 / (r[3] * t + r[7] * n + r[11] * i + r[15]);
                    return this.x = (r[0] * t + r[4] * n + r[8] * i + r[12]) * a, this.y = (r[1] * t + r[5] * n + r[9] * i + r[13]) * a, this.z = (r[2] * t + r[6] * n + r[10] * i + r[14]) * a, this
                }
                applyQuaternion(e) {
                    const t = this.x,
                        n = this.y,
                        i = this.z,
                        r = e.x,
                        a = e.y,
                        o = e.z,
                        s = e.w,
                        l = s * t + a * i - o * n,
                        c = s * n + o * t - r * i,
                        u = s * i + r * n - a * t,
                        h = -r * t - a * n - o * i;
                    return this.x = l * s + h * -r + c * -o - u * -a, this.y = c * s + h * -a + u * -r - l * -o, this.z = u * s + h * -o + l * -a - c * -r, this
                }
                project(e) {
                    return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)
                }
                unproject(e) {
                    return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)
                }
                transformDirection(e) {
                    const t = this.x,
                        n = this.y,
                        i = this.z,
                        r = e.elements;
                    return this.x = r[0] * t + r[4] * n + r[8] * i, this.y = r[1] * t + r[5] * n + r[9] * i, this.z = r[2] * t + r[6] * n + r[10] * i, this.normalize()
                }
                divide(e) {
                    return this.x /= e.x, this.y /= e.y, this.z /= e.z, this
                }
                divideScalar(e) {
                    return this.multiplyScalar(1 / e)
                }
                min(e) {
                    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this
                }
                max(e) {
                    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this
                }
                clamp(e, t) {
                    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this
                }
                clampScalar(e, t) {
                    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this
                }
                clampLength(e, t) {
                    const n = this.length();
                    return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
                }
                floor() {
                    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
                }
                ceil() {
                    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
                }
                round() {
                    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
                }
                roundToZero() {
                    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this
                }
                negate() {
                    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
                }
                dot(e) {
                    return this.x * e.x + this.y * e.y + this.z * e.z
                }
                lengthSq() {
                    return this.x * this.x + this.y * this.y + this.z * this.z
                }
                length() {
                    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
                }
                manhattanLength() {
                    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
                }
                normalize() {
                    return this.divideScalar(this.length() || 1)
                }
                setLength(e) {
                    return this.normalize().multiplyScalar(e)
                }
                lerp(e, t) {
                    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this
                }
                lerpVectors(e, t, n) {
                    return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this.z = e.z + (t.z - e.z) * n, this
                }
                cross(e, t) {
                    return void 0 !== t ? this.crossVectors(e, t) : this.crossVectors(this, e)
                }
                crossVectors(e, t) {
                    const n = e.x,
                        i = e.y,
                        r = e.z,
                        a = t.x,
                        o = t.y,
                        s = t.z;
                    return this.x = i * s - r * o, this.y = r * a - n * s, this.z = n * o - i * a, this
                }
                projectOnVector(e) {
                    const t = e.lengthSq();
                    if (0 === t) return this.set(0, 0, 0);
                    const n = e.dot(this) / t;
                    return this.copy(e).multiplyScalar(n)
                }
                projectOnPlane(e) {
                    return Na.copy(this).projectOnVector(e), this.sub(Na)
                }
                reflect(e) {
                    return this.sub(Na.copy(e).multiplyScalar(2 * this.dot(e)))
                }
                angleTo(e) {
                    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
                    if (0 === t) return Math.PI / 2;
                    const n = this.dot(e) / t;
                    return Math.acos(Fa.clamp(n, -1, 1))
                }
                distanceTo(e) {
                    return Math.sqrt(this.distanceToSquared(e))
                }
                distanceToSquared(e) {
                    const t = this.x - e.x,
                        n = this.y - e.y,
                        i = this.z - e.z;
                    return t * t + n * n + i * i
                }
                manhattanDistanceTo(e) {
                    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
                }
                setFromSpherical(e) {
                    return this.setFromSphericalCoords(e.radius, e.phi, e.theta)
                }
                setFromSphericalCoords(e, t, n) {
                    const i = Math.sin(t) * e;
                    return this.x = i * Math.sin(n), this.y = Math.cos(t) * e, this.z = i * Math.cos(n), this
                }
                setFromCylindrical(e) {
                    return this.setFromCylindricalCoords(e.radius, e.theta, e.y)
                }
                setFromCylindricalCoords(e, t, n) {
                    return this.x = e * Math.sin(t), this.y = n, this.z = e * Math.cos(t), this
                }
                setFromMatrixPosition(e) {
                    const t = e.elements;
                    return this.x = t[12], this.y = t[13], this.z = t[14], this
                }
                setFromMatrixScale(e) {
                    const t = this.setFromMatrixColumn(e, 0).length(),
                        n = this.setFromMatrixColumn(e, 1).length(),
                        i = this.setFromMatrixColumn(e, 2).length();
                    return this.x = t, this.y = n, this.z = i, this
                }
                setFromMatrixColumn(e, t) {
                    return this.fromArray(e.elements, 4 * t)
                }
                setFromMatrix3Column(e, t) {
                    return this.fromArray(e.elements, 3 * t)
                }
                equals(e) {
                    return e.x === this.x && e.y === this.y && e.z === this.z
                }
                fromArray(e, t = 0) {
                    return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this
                }
                toArray(e = [], t = 0) {
                    return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e
                }
                fromBufferAttribute(e, t, n) {
                    return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this
                }
                random() {
                    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this
                }
            }
            const Na = new Vector3,
                Da = new Quaternion;
            class Box3 {
                constructor(e, t) {
                    Object.defineProperty(this, "isBox3", {
                        value: !0
                    }), this.min = void 0 !== e ? e : new Vector3(1 / 0, 1 / 0, 1 / 0), this.max = void 0 !== t ? t : new Vector3(-1 / 0, -1 / 0, -1 / 0)
                }
                set(e, t) {
                    return this.min.copy(e), this.max.copy(t), this
                }
                setFromArray(e) {
                    let t = 1 / 0,
                        n = 1 / 0,
                        i = 1 / 0,
                        r = -1 / 0,
                        a = -1 / 0,
                        o = -1 / 0;
                    for (let s = 0, l = e.length; s < l; s += 3) {
                        const l = e[s],
                            c = e[s + 1],
                            u = e[s + 2];
                        l < t && (t = l), c < n && (n = c), u < i && (i = u), l > r && (r = l), c > a && (a = c), u > o && (o = u)
                    }
                    return this.min.set(t, n, i), this.max.set(r, a, o), this
                }
                setFromBufferAttribute(e) {
                    let t = 1 / 0,
                        n = 1 / 0,
                        i = 1 / 0,
                        r = -1 / 0,
                        a = -1 / 0,
                        o = -1 / 0;
                    for (let s = 0, l = e.count; s < l; s++) {
                        const l = e.getX(s),
                            c = e.getY(s),
                            u = e.getZ(s);
                        l < t && (t = l), c < n && (n = c), u < i && (i = u), l > r && (r = l), c > a && (a = c), u > o && (o = u)
                    }
                    return this.min.set(t, n, i), this.max.set(r, a, o), this
                }
                setFromPoints(e) {
                    this.makeEmpty();
                    for (let t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]);
                    return this
                }
                setFromCenterAndSize(e, t) {
                    const n = Ua.copy(t).multiplyScalar(.5);
                    return this.min.copy(e).sub(n), this.max.copy(e).add(n), this
                }
                setFromObject(e) {
                    return this.makeEmpty(), this.expandByObject(e)
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                copy(e) {
                    return this.min.copy(e.min), this.max.copy(e.max), this
                }
                makeEmpty() {
                    return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this
                }
                isEmpty() {
                    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
                }
                getCenter(e) {
                    return void 0 === e && (e = new Vector3), this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
                }
                getSize(e) {
                    return void 0 === e && (e = new Vector3), this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min)
                }
                expandByPoint(e) {
                    return this.min.min(e), this.max.max(e), this
                }
                expandByVector(e) {
                    return this.min.sub(e), this.max.add(e), this
                }
                expandByScalar(e) {
                    return this.min.addScalar(-e), this.max.addScalar(e), this
                }
                expandByObject(e) {
                    e.updateWorldMatrix(!1, !1);
                    const t = e.geometry;
                    void 0 !== t && (null === t.boundingBox && t.computeBoundingBox(), za.copy(t.boundingBox), za.applyMatrix4(e.matrixWorld), this.union(za));
                    const n = e.children;
                    for (let e = 0, t = n.length; e < t; e++) this.expandByObject(n[e]);
                    return this
                }
                containsPoint(e) {
                    return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z)
                }
                containsBox(e) {
                    return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z
                }
                getParameter(e, t) {
                    return void 0 === t && (t = new Vector3), t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z))
                }
                intersectsBox(e) {
                    return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z)
                }
                intersectsSphere(e) {
                    return this.clampPoint(e.center, Ua), Ua.distanceToSquared(e.center) <= e.radius * e.radius
                }
                intersectsPlane(e) {
                    let t, n;
                    return e.normal.x > 0 ? (t = e.normal.x * this.min.x, n = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, n = e.normal.x * this.min.x), e.normal.y > 0 ? (t += e.normal.y * this.min.y, n += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, n += e.normal.y * this.min.y), e.normal.z > 0 ? (t += e.normal.z * this.min.z, n += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, n += e.normal.z * this.min.z), t <= -e.constant && n >= -e.constant
                }
                intersectsTriangle(e) {
                    if (this.isEmpty()) return !1;
                    this.getCenter(Ya), qa.subVectors(this.max, Ya), Ga.subVectors(e.a, Ya), ka.subVectors(e.b, Ya), ja.subVectors(e.c, Ya), Wa.subVectors(ka, Ga), Ha.subVectors(ja, ka), Xa.subVectors(Ga, ja);
                    let t = [0, -Wa.z, Wa.y, 0, -Ha.z, Ha.y, 0, -Xa.z, Xa.y, Wa.z, 0, -Wa.x, Ha.z, 0, -Ha.x, Xa.z, 0, -Xa.x, -Wa.y, Wa.x, 0, -Ha.y, Ha.x, 0, -Xa.y, Xa.x, 0];
                    return !!satForAxes(t, Ga, ka, ja, qa) && (t = [1, 0, 0, 0, 1, 0, 0, 0, 1], !!satForAxes(t, Ga, ka, ja, qa) && (Qa.crossVectors(Wa, Ha), t = [Qa.x, Qa.y, Qa.z], satForAxes(t, Ga, ka, ja, qa)))
                }
                clampPoint(e, t) {
                    return void 0 === t && (t = new Vector3), t.copy(e).clamp(this.min, this.max)
                }
                distanceToPoint(e) {
                    return Ua.copy(e).clamp(this.min, this.max).sub(e).length()
                }
                getBoundingSphere(e) {
                    return this.getCenter(e.center), e.radius = .5 * this.getSize(Ua).length(), e
                }
                intersect(e) {
                    return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this
                }
                union(e) {
                    return this.min.min(e.min), this.max.max(e.max), this
                }
                applyMatrix4(e) {
                    return this.isEmpty() || (Va[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), Va[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), Va[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), Va[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), Va[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), Va[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), Va[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), Va[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(Va)), this
                }
                translate(e) {
                    return this.min.add(e), this.max.add(e), this
                }
                equals(e) {
                    return e.min.equals(this.min) && e.max.equals(this.max)
                }
            }
            const Va = [new Vector3, new Vector3, new Vector3, new Vector3, new Vector3, new Vector3, new Vector3, new Vector3],
                Ua = new Vector3,
                za = new Box3,
                Ga = new Vector3,
                ka = new Vector3,
                ja = new Vector3,
                Wa = new Vector3,
                Ha = new Vector3,
                Xa = new Vector3,
                Ya = new Vector3,
                qa = new Vector3,
                Qa = new Vector3,
                Ja = new Vector3,
                Za = new Box3;
            class Sphere {
                constructor(e, t) {
                    this.center = void 0 !== e ? e : new Vector3, this.radius = void 0 !== t ? t : -1
                }
                set(e, t) {
                    return this.center.copy(e), this.radius = t, this
                }
                setFromPoints(e, t) {
                    const n = this.center;
                    void 0 !== t ? n.copy(t) : Za.setFromPoints(e).getCenter(n);
                    let i = 0;
                    for (let t = 0, r = e.length; t < r; t++) i = Math.max(i, n.distanceToSquared(e[t]));
                    return this.radius = Math.sqrt(i), this
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                copy(e) {
                    return this.center.copy(e.center), this.radius = e.radius, this
                }
                isEmpty() {
                    return this.radius < 0
                }
                makeEmpty() {
                    return this.center.set(0, 0, 0), this.radius = -1, this
                }
                containsPoint(e) {
                    return e.distanceToSquared(this.center) <= this.radius * this.radius
                }
                distanceToPoint(e) {
                    return e.distanceTo(this.center) - this.radius
                }
                intersectsSphere(e) {
                    const t = this.radius + e.radius;
                    return e.center.distanceToSquared(this.center) <= t * t
                }
                intersectsBox(e) {
                    return e.intersectsSphere(this)
                }
                intersectsPlane(e) {
                    return Math.abs(e.distanceToPoint(this.center)) <= this.radius
                }
                clampPoint(e, t) {
                    const n = this.center.distanceToSquared(e);
                    return void 0 === t && (t = new Vector3), t.copy(e), n > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t
                }
                getBoundingBox(e) {
                    return void 0 === e && (e = new Box3), this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e)
                }
                applyMatrix4(e) {
                    return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this
                }
                translate(e) {
                    return this.center.add(e), this
                }
                equals(e) {
                    return e.center.equals(this.center) && e.radius === this.radius
                }
            }
            const Ka = new Vector3,
                $a = new Vector3,
                eo = new Vector3,
                to = new Vector3,
                no = new Vector3,
                io = new Vector3,
                ro = new Vector3;
            class Ray {
                constructor(e, t) {
                    this.origin = void 0 !== e ? e : new Vector3, this.direction = void 0 !== t ? t : new Vector3(0, 0, -1)
                }
                set(e, t) {
                    return this.origin.copy(e), this.direction.copy(t), this
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                copy(e) {
                    return this.origin.copy(e.origin), this.direction.copy(e.direction), this
                }
                at(e, t) {
                    return void 0 === t && (t = new Vector3), t.copy(this.direction).multiplyScalar(e).add(this.origin)
                }
                lookAt(e) {
                    return this.direction.copy(e).sub(this.origin).normalize(), this
                }
                recast(e) {
                    return this.origin.copy(this.at(e, Ka)), this
                }
                closestPointToPoint(e, t) {
                    void 0 === t && (t = new Vector3), t.subVectors(e, this.origin);
                    const n = t.dot(this.direction);
                    return n < 0 ? t.copy(this.origin) : t.copy(this.direction).multiplyScalar(n).add(this.origin)
                }
                distanceToPoint(e) {
                    return Math.sqrt(this.distanceSqToPoint(e))
                }
                distanceSqToPoint(e) {
                    const t = Ka.subVectors(e, this.origin).dot(this.direction);
                    return t < 0 ? this.origin.distanceToSquared(e) : (Ka.copy(this.direction).multiplyScalar(t).add(this.origin), Ka.distanceToSquared(e))
                }
                distanceSqToSegment(e, t, n, i) {
                    $a.copy(e).add(t).multiplyScalar(.5), eo.copy(t).sub(e).normalize(), to.copy(this.origin).sub($a);
                    const r = .5 * e.distanceTo(t),
                        a = -this.direction.dot(eo),
                        o = to.dot(this.direction),
                        s = -to.dot(eo),
                        l = to.lengthSq(),
                        c = Math.abs(1 - a * a);
                    let u, h, d, p;
                    if (c > 0)
                        if (u = a * s - o, h = a * o - s, p = r * c, u >= 0)
                            if (h >= -p)
                                if (h <= p) {
                                    const e = 1 / c;
                                    u *= e, h *= e, d = u * (u + a * h + 2 * o) + h * (a * u + h + 2 * s) + l
                                } else h = r, u = Math.max(0, -(a * h + o)), d = -u * u + h * (h + 2 * s) + l;
                    else h = -r, u = Math.max(0, -(a * h + o)), d = -u * u + h * (h + 2 * s) + l;
                    else h <= -p ? (u = Math.max(0, -(-a * r + o)), h = u > 0 ? -r : Math.min(Math.max(-r, -s), r), d = -u * u + h * (h + 2 * s) + l) : h <= p ? (u = 0, h = Math.min(Math.max(-r, -s), r), d = h * (h + 2 * s) + l) : (u = Math.max(0, -(a * r + o)), h = u > 0 ? r : Math.min(Math.max(-r, -s), r), d = -u * u + h * (h + 2 * s) + l);
                    else h = a > 0 ? -r : r, u = Math.max(0, -(a * h + o)), d = -u * u + h * (h + 2 * s) + l;
                    return n && n.copy(this.direction).multiplyScalar(u).add(this.origin), i && i.copy(eo).multiplyScalar(h).add($a), d
                }
                intersectSphere(e, t) {
                    Ka.subVectors(e.center, this.origin);
                    const n = Ka.dot(this.direction),
                        i = Ka.dot(Ka) - n * n,
                        r = e.radius * e.radius;
                    if (i > r) return null;
                    const a = Math.sqrt(r - i),
                        o = n - a,
                        s = n + a;
                    return o < 0 && s < 0 ? null : o < 0 ? this.at(s, t) : this.at(o, t)
                }
                intersectsSphere(e) {
                    return this.distanceSqToPoint(e.center) <= e.radius * e.radius
                }
                distanceToPlane(e) {
                    const t = e.normal.dot(this.direction);
                    if (0 === t) return 0 === e.distanceToPoint(this.origin) ? 0 : null;
                    const n = -(this.origin.dot(e.normal) + e.constant) / t;
                    return n >= 0 ? n : null
                }
                intersectPlane(e, t) {
                    const n = this.distanceToPlane(e);
                    return null === n ? null : this.at(n, t)
                }
                intersectsPlane(e) {
                    const t = e.distanceToPoint(this.origin);
                    if (0 === t) return !0;
                    return e.normal.dot(this.direction) * t < 0
                }
                intersectBox(e, t) {
                    let n, i, r, a, o, s;
                    const l = 1 / this.direction.x,
                        c = 1 / this.direction.y,
                        u = 1 / this.direction.z,
                        h = this.origin;
                    return l >= 0 ? (n = (e.min.x - h.x) * l, i = (e.max.x - h.x) * l) : (n = (e.max.x - h.x) * l, i = (e.min.x - h.x) * l), c >= 0 ? (r = (e.min.y - h.y) * c, a = (e.max.y - h.y) * c) : (r = (e.max.y - h.y) * c, a = (e.min.y - h.y) * c), n > a || r > i ? null : ((r > n || n != n) && (n = r), (a < i || i != i) && (i = a), u >= 0 ? (o = (e.min.z - h.z) * u, s = (e.max.z - h.z) * u) : (o = (e.max.z - h.z) * u, s = (e.min.z - h.z) * u), n > s || o > i ? null : ((o > n || n != n) && (n = o), (s < i || i != i) && (i = s), i < 0 ? null : this.at(n >= 0 ? n : i, t)))
                }
                intersectsBox(e) {
                    return null !== this.intersectBox(e, Ka)
                }
                intersectTriangle(e, t, n, i, r) {
                    no.subVectors(t, e), io.subVectors(n, e), ro.crossVectors(no, io);
                    let a, o = this.direction.dot(ro);
                    if (o > 0) {
                        if (i) return null;
                        a = 1
                    } else {
                        if (!(o < 0)) return null;
                        a = -1, o = -o
                    }
                    to.subVectors(this.origin, e);
                    const s = a * this.direction.dot(io.crossVectors(to, io));
                    if (s < 0) return null;
                    const l = a * this.direction.dot(no.cross(to));
                    if (l < 0) return null;
                    if (s + l > o) return null;
                    const c = -a * to.dot(ro);
                    return c < 0 ? null : this.at(c / o, r)
                }
                applyMatrix4(e) {
                    return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this
                }
                equals(e) {
                    return e.origin.equals(this.origin) && e.direction.equals(this.direction)
                }
            }
            class Matrix4 {
                constructor() {
                    Object.defineProperty(this, "isMatrix4", {
                        value: !0
                    }), this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]
                }
                set(e, t, n, i, r, a, o, s, l, c, u, h, d, p, f, m) {
                    const g = this.elements;
                    return g[0] = e, g[4] = t, g[8] = n, g[12] = i, g[1] = r, g[5] = a, g[9] = o, g[13] = s, g[2] = l, g[6] = c, g[10] = u, g[14] = h, g[3] = d, g[7] = p, g[11] = f, g[15] = m, this
                }
                identity() {
                    return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
                }
                clone() {
                    return (new Matrix4).fromArray(this.elements)
                }
                copy(e) {
                    const t = this.elements,
                        n = e.elements;
                    return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], t[9] = n[9], t[10] = n[10], t[11] = n[11], t[12] = n[12], t[13] = n[13], t[14] = n[14], t[15] = n[15], this
                }
                copyPosition(e) {
                    const t = this.elements,
                        n = e.elements;
                    return t[12] = n[12], t[13] = n[13], t[14] = n[14], this
                }
                extractBasis(e, t, n) {
                    return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this
                }
                makeBasis(e, t, n) {
                    return this.set(e.x, t.x, n.x, 0, e.y, t.y, n.y, 0, e.z, t.z, n.z, 0, 0, 0, 0, 1), this
                }
                extractRotation(e) {
                    const t = this.elements,
                        n = e.elements,
                        i = 1 / ao.setFromMatrixColumn(e, 0).length(),
                        r = 1 / ao.setFromMatrixColumn(e, 1).length(),
                        a = 1 / ao.setFromMatrixColumn(e, 2).length();
                    return t[0] = n[0] * i, t[1] = n[1] * i, t[2] = n[2] * i, t[3] = 0, t[4] = n[4] * r, t[5] = n[5] * r, t[6] = n[6] * r, t[7] = 0, t[8] = n[8] * a, t[9] = n[9] * a, t[10] = n[10] * a, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this
                }
                makeRotationFromEuler(e) {
                    !e || e.isEuler;
                    const t = this.elements,
                        n = e.x,
                        i = e.y,
                        r = e.z,
                        a = Math.cos(n),
                        o = Math.sin(n),
                        s = Math.cos(i),
                        l = Math.sin(i),
                        c = Math.cos(r),
                        u = Math.sin(r);
                    if ("XYZ" === e.order) {
                        const e = a * c,
                            n = a * u,
                            i = o * c,
                            r = o * u;
                        t[0] = s * c, t[4] = -s * u, t[8] = l, t[1] = n + i * l, t[5] = e - r * l, t[9] = -o * s, t[2] = r - e * l, t[6] = i + n * l, t[10] = a * s
                    } else if ("YXZ" === e.order) {
                        const e = s * c,
                            n = s * u,
                            i = l * c,
                            r = l * u;
                        t[0] = e + r * o, t[4] = i * o - n, t[8] = a * l, t[1] = a * u, t[5] = a * c, t[9] = -o, t[2] = n * o - i, t[6] = r + e * o, t[10] = a * s
                    } else if ("ZXY" === e.order) {
                        const e = s * c,
                            n = s * u,
                            i = l * c,
                            r = l * u;
                        t[0] = e - r * o, t[4] = -a * u, t[8] = i + n * o, t[1] = n + i * o, t[5] = a * c, t[9] = r - e * o, t[2] = -a * l, t[6] = o, t[10] = a * s
                    } else if ("ZYX" === e.order) {
                        const e = a * c,
                            n = a * u,
                            i = o * c,
                            r = o * u;
                        t[0] = s * c, t[4] = i * l - n, t[8] = e * l + r, t[1] = s * u, t[5] = r * l + e, t[9] = n * l - i, t[2] = -l, t[6] = o * s, t[10] = a * s
                    } else if ("YZX" === e.order) {
                        const e = a * s,
                            n = a * l,
                            i = o * s,
                            r = o * l;
                        t[0] = s * c, t[4] = r - e * u, t[8] = i * u + n, t[1] = u, t[5] = a * c, t[9] = -o * c, t[2] = -l * c, t[6] = n * u + i, t[10] = e - r * u
                    } else if ("XZY" === e.order) {
                        const e = a * s,
                            n = a * l,
                            i = o * s,
                            r = o * l;
                        t[0] = s * c, t[4] = -u, t[8] = l * c, t[1] = e * u + r, t[5] = a * c, t[9] = n * u - i, t[2] = i * u - n, t[6] = o * c, t[10] = r * u + e
                    }
                    return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this
                }
                makeRotationFromQuaternion(e) {
                    return this.compose(so, e, lo)
                }
                lookAt(e, t, n) {
                    const i = this.elements;
                    return ho.subVectors(e, t), 0 === ho.lengthSq() && (ho.z = 1), ho.normalize(), co.crossVectors(n, ho), 0 === co.lengthSq() && (1 === Math.abs(n.z) ? ho.x += 1e-4 : ho.z += 1e-4, ho.normalize(), co.crossVectors(n, ho)), co.normalize(), uo.crossVectors(ho, co), i[0] = co.x, i[4] = uo.x, i[8] = ho.x, i[1] = co.y, i[5] = uo.y, i[9] = ho.y, i[2] = co.z, i[6] = uo.z, i[10] = ho.z, this
                }
                multiply(e, t) {
                    return void 0 !== t ? this.multiplyMatrices(e, t) : this.multiplyMatrices(this, e)
                }
                premultiply(e) {
                    return this.multiplyMatrices(e, this)
                }
                multiplyMatrices(e, t) {
                    const n = e.elements,
                        i = t.elements,
                        r = this.elements,
                        a = n[0],
                        o = n[4],
                        s = n[8],
                        l = n[12],
                        c = n[1],
                        u = n[5],
                        h = n[9],
                        d = n[13],
                        p = n[2],
                        f = n[6],
                        m = n[10],
                        g = n[14],
                        y = n[3],
                        x = n[7],
                        _ = n[11],
                        b = n[15],
                        M = i[0],
                        S = i[4],
                        A = i[8],
                        w = i[12],
                        T = i[1],
                        L = i[5],
                        C = i[9],
                        P = i[13],
                        E = i[2],
                        I = i[6],
                        F = i[10],
                        O = i[14],
                        B = i[3],
                        R = i[7],
                        N = i[11],
                        D = i[15];
                    return r[0] = a * M + o * T + s * E + l * B, r[4] = a * S + o * L + s * I + l * R, r[8] = a * A + o * C + s * F + l * N, r[12] = a * w + o * P + s * O + l * D, r[1] = c * M + u * T + h * E + d * B, r[5] = c * S + u * L + h * I + d * R, r[9] = c * A + u * C + h * F + d * N, r[13] = c * w + u * P + h * O + d * D, r[2] = p * M + f * T + m * E + g * B, r[6] = p * S + f * L + m * I + g * R, r[10] = p * A + f * C + m * F + g * N, r[14] = p * w + f * P + m * O + g * D, r[3] = y * M + x * T + _ * E + b * B, r[7] = y * S + x * L + _ * I + b * R, r[11] = y * A + x * C + _ * F + b * N, r[15] = y * w + x * P + _ * O + b * D, this
                }
                multiplyScalar(e) {
                    const t = this.elements;
                    return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this
                }
                determinant() {
                    const e = this.elements,
                        t = e[0],
                        n = e[4],
                        i = e[8],
                        r = e[12],
                        a = e[1],
                        o = e[5],
                        s = e[9],
                        l = e[13],
                        c = e[2],
                        u = e[6],
                        h = e[10],
                        d = e[14];
                    return e[3] * (+r * s * u - i * l * u - r * o * h + n * l * h + i * o * d - n * s * d) + e[7] * (+t * s * d - t * l * h + r * a * h - i * a * d + i * l * c - r * s * c) + e[11] * (+t * l * u - t * o * d - r * a * u + n * a * d + r * o * c - n * l * c) + e[15] * (-i * o * c - t * s * u + t * o * h + i * a * u - n * a * h + n * s * c)
                }
                transpose() {
                    const e = this.elements;
                    let t;
                    return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this
                }
                setPosition(e, t, n) {
                    const i = this.elements;
                    return e.isVector3 ? (i[12] = e.x, i[13] = e.y, i[14] = e.z) : (i[12] = e, i[13] = t, i[14] = n), this
                }
                invert() {
                    const e = this.elements,
                        t = e[0],
                        n = e[1],
                        i = e[2],
                        r = e[3],
                        a = e[4],
                        o = e[5],
                        s = e[6],
                        l = e[7],
                        c = e[8],
                        u = e[9],
                        h = e[10],
                        d = e[11],
                        p = e[12],
                        f = e[13],
                        m = e[14],
                        g = e[15],
                        y = u * m * l - f * h * l + f * s * d - o * m * d - u * s * g + o * h * g,
                        x = p * h * l - c * m * l - p * s * d + a * m * d + c * s * g - a * h * g,
                        _ = c * f * l - p * u * l + p * o * d - a * f * d - c * o * g + a * u * g,
                        b = p * u * s - c * f * s - p * o * h + a * f * h + c * o * m - a * u * m,
                        M = t * y + n * x + i * _ + r * b;
                    if (0 === M) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
                    const S = 1 / M;
                    return e[0] = y * S, e[1] = (f * h * r - u * m * r - f * i * d + n * m * d + u * i * g - n * h * g) * S, e[2] = (o * m * r - f * s * r + f * i * l - n * m * l - o * i * g + n * s * g) * S, e[3] = (u * s * r - o * h * r - u * i * l + n * h * l + o * i * d - n * s * d) * S, e[4] = x * S, e[5] = (c * m * r - p * h * r + p * i * d - t * m * d - c * i * g + t * h * g) * S, e[6] = (p * s * r - a * m * r - p * i * l + t * m * l + a * i * g - t * s * g) * S, e[7] = (a * h * r - c * s * r + c * i * l - t * h * l - a * i * d + t * s * d) * S, e[8] = _ * S, e[9] = (p * u * r - c * f * r - p * n * d + t * f * d + c * n * g - t * u * g) * S, e[10] = (a * f * r - p * o * r + p * n * l - t * f * l - a * n * g + t * o * g) * S, e[11] = (c * o * r - a * u * r - c * n * l + t * u * l + a * n * d - t * o * d) * S, e[12] = b * S, e[13] = (c * f * i - p * u * i + p * n * h - t * f * h - c * n * m + t * u * m) * S, e[14] = (p * o * i - a * f * i - p * n * s + t * f * s + a * n * m - t * o * m) * S, e[15] = (a * u * i - c * o * i + c * n * s - t * u * s - a * n * h + t * o * h) * S, this
                }
                scale(e) {
                    const t = this.elements,
                        n = e.x,
                        i = e.y,
                        r = e.z;
                    return t[0] *= n, t[4] *= i, t[8] *= r, t[1] *= n, t[5] *= i, t[9] *= r, t[2] *= n, t[6] *= i, t[10] *= r, t[3] *= n, t[7] *= i, t[11] *= r, this
                }
                getMaxScaleOnAxis() {
                    const e = this.elements,
                        t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
                        n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
                        i = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
                    return Math.sqrt(Math.max(t, n, i))
                }
                makeTranslation(e, t, n) {
                    return this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, n, 0, 0, 0, 1), this
                }
                makeRotationX(e) {
                    const t = Math.cos(e),
                        n = Math.sin(e);
                    return this.set(1, 0, 0, 0, 0, t, -n, 0, 0, n, t, 0, 0, 0, 0, 1), this
                }
                makeRotationY(e) {
                    const t = Math.cos(e),
                        n = Math.sin(e);
                    return this.set(t, 0, n, 0, 0, 1, 0, 0, -n, 0, t, 0, 0, 0, 0, 1), this
                }
                makeRotationZ(e) {
                    const t = Math.cos(e),
                        n = Math.sin(e);
                    return this.set(t, -n, 0, 0, n, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
                }
                makeRotationAxis(e, t) {
                    const n = Math.cos(t),
                        i = Math.sin(t),
                        r = 1 - n,
                        a = e.x,
                        o = e.y,
                        s = e.z,
                        l = r * a,
                        c = r * o;
                    return this.set(l * a + n, l * o - i * s, l * s + i * o, 0, l * o + i * s, c * o + n, c * s - i * a, 0, l * s - i * o, c * s + i * a, r * s * s + n, 0, 0, 0, 0, 1), this
                }
                makeScale(e, t, n) {
                    return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this
                }
                makeShear(e, t, n) {
                    return this.set(1, t, n, 0, e, 1, n, 0, e, t, 1, 0, 0, 0, 0, 1), this
                }
                compose(e, t, n) {
                    const i = this.elements,
                        r = t._x,
                        a = t._y,
                        o = t._z,
                        s = t._w,
                        l = r + r,
                        c = a + a,
                        u = o + o,
                        h = r * l,
                        d = r * c,
                        p = r * u,
                        f = a * c,
                        m = a * u,
                        g = o * u,
                        y = s * l,
                        x = s * c,
                        _ = s * u,
                        b = n.x,
                        M = n.y,
                        S = n.z;
                    return i[0] = (1 - (f + g)) * b, i[1] = (d + _) * b, i[2] = (p - x) * b, i[3] = 0, i[4] = (d - _) * M, i[5] = (1 - (h + g)) * M, i[6] = (m + y) * M, i[7] = 0, i[8] = (p + x) * S, i[9] = (m - y) * S, i[10] = (1 - (h + f)) * S, i[11] = 0, i[12] = e.x, i[13] = e.y, i[14] = e.z, i[15] = 1, this
                }
                decompose(e, t, n) {
                    const i = this.elements;
                    let r = ao.set(i[0], i[1], i[2]).length();
                    const a = ao.set(i[4], i[5], i[6]).length(),
                        o = ao.set(i[8], i[9], i[10]).length();
                    this.determinant() < 0 && (r = -r), e.x = i[12], e.y = i[13], e.z = i[14], oo.copy(this);
                    const s = 1 / r,
                        l = 1 / a,
                        c = 1 / o;
                    return oo.elements[0] *= s, oo.elements[1] *= s, oo.elements[2] *= s, oo.elements[4] *= l, oo.elements[5] *= l, oo.elements[6] *= l, oo.elements[8] *= c, oo.elements[9] *= c, oo.elements[10] *= c, t.setFromRotationMatrix(oo), n.x = r, n.y = a, n.z = o, this
                }
                makePerspective(e, t, n, i, r, a) {
                    const o = this.elements,
                        s = 2 * r / (t - e),
                        l = 2 * r / (n - i),
                        c = (t + e) / (t - e),
                        u = (n + i) / (n - i),
                        h = -(a + r) / (a - r),
                        d = -2 * a * r / (a - r);
                    return o[0] = s, o[4] = 0, o[8] = c, o[12] = 0, o[1] = 0, o[5] = l, o[9] = u, o[13] = 0, o[2] = 0, o[6] = 0, o[10] = h, o[14] = d, o[3] = 0, o[7] = 0, o[11] = -1, o[15] = 0, this
                }
                makeOrthographic(e, t, n, i, r, a) {
                    const o = this.elements,
                        s = 1 / (t - e),
                        l = 1 / (n - i),
                        c = 1 / (a - r),
                        u = (t + e) * s,
                        h = (n + i) * l,
                        d = (a + r) * c;
                    return o[0] = 2 * s, o[4] = 0, o[8] = 0, o[12] = -u, o[1] = 0, o[5] = 2 * l, o[9] = 0, o[13] = -h, o[2] = 0, o[6] = 0, o[10] = -2 * c, o[14] = -d, o[3] = 0, o[7] = 0, o[11] = 0, o[15] = 1, this
                }
                equals(e) {
                    const t = this.elements,
                        n = e.elements;
                    for (let e = 0; e < 16; e++)
                        if (t[e] !== n[e]) return !1;
                    return !0
                }
                fromArray(e, t = 0) {
                    for (let n = 0; n < 16; n++) this.elements[n] = e[n + t];
                    return this
                }
                toArray(e = [], t = 0) {
                    const n = this.elements;
                    return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e[t + 9] = n[9], e[t + 10] = n[10], e[t + 11] = n[11], e[t + 12] = n[12], e[t + 13] = n[13], e[t + 14] = n[14], e[t + 15] = n[15], e
                }
            }
            const ao = new Vector3,
                oo = new Matrix4,
                so = new Vector3(0, 0, 0),
                lo = new Vector3(1, 1, 1),
                co = new Vector3,
                uo = new Vector3,
                ho = new Vector3;
            class Euler {
                constructor(e = 0, t = 0, n = 0, i = Euler.DefaultOrder) {
                    Object.defineProperty(this, "isEuler", {
                        value: !0
                    }), this._x = e, this._y = t, this._z = n, this._order = i
                }
                get x() {
                    return this._x
                }
                set x(e) {
                    this._x = e, this._onChangeCallback()
                }
                get y() {
                    return this._y
                }
                set y(e) {
                    this._y = e, this._onChangeCallback()
                }
                get z() {
                    return this._z
                }
                set z(e) {
                    this._z = e, this._onChangeCallback()
                }
                get order() {
                    return this._order
                }
                set order(e) {
                    this._order = e, this._onChangeCallback()
                }
                set(e, t, n, i) {
                    return this._x = e, this._y = t, this._z = n, this._order = i || this._order, this._onChangeCallback(), this
                }
                clone() {
                    return new this.constructor(this._x, this._y, this._z, this._order)
                }
                copy(e) {
                    return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this
                }
                setFromRotationMatrix(e, t, n) {
                    const i = Fa.clamp,
                        r = e.elements,
                        a = r[0],
                        o = r[4],
                        s = r[8],
                        l = r[1],
                        c = r[5],
                        u = r[9],
                        h = r[2],
                        d = r[6],
                        p = r[10];
                    switch (t = t || this._order) {
                        case "XYZ":
                            this._y = Math.asin(i(s, -1, 1)), Math.abs(s) < .9999999 ? (this._x = Math.atan2(-u, p), this._z = Math.atan2(-o, a)) : (this._x = Math.atan2(d, c), this._z = 0);
                            break;
                        case "YXZ":
                            this._x = Math.asin(-i(u, -1, 1)), Math.abs(u) < .9999999 ? (this._y = Math.atan2(s, p), this._z = Math.atan2(l, c)) : (this._y = Math.atan2(-h, a), this._z = 0);
                            break;
                        case "ZXY":
                            this._x = Math.asin(i(d, -1, 1)), Math.abs(d) < .9999999 ? (this._y = Math.atan2(-h, p), this._z = Math.atan2(-o, c)) : (this._y = 0, this._z = Math.atan2(l, a));
                            break;
                        case "ZYX":
                            this._y = Math.asin(-i(h, -1, 1)), Math.abs(h) < .9999999 ? (this._x = Math.atan2(d, p), this._z = Math.atan2(l, a)) : (this._x = 0, this._z = Math.atan2(-o, c));
                            break;
                        case "YZX":
                            this._z = Math.asin(i(l, -1, 1)), Math.abs(l) < .9999999 ? (this._x = Math.atan2(-u, c), this._y = Math.atan2(-h, a)) : (this._x = 0, this._y = Math.atan2(s, p));
                            break;
                        case "XZY":
                            this._z = Math.asin(-i(o, -1, 1)), Math.abs(o) < .9999999 ? (this._x = Math.atan2(d, c), this._y = Math.atan2(s, a)) : (this._x = Math.atan2(-u, p), this._y = 0)
                    }
                    return this._order = t, !1 !== n && this._onChangeCallback(), this
                }
                setFromQuaternion(e, t, n) {
                    return po.makeRotationFromQuaternion(e), this.setFromRotationMatrix(po, t, n)
                }
                setFromVector3(e, t) {
                    return this.set(e.x, e.y, e.z, t || this._order)
                }
                reorder(e) {
                    return fo.setFromEuler(this), this.setFromQuaternion(fo, e)
                }
                equals(e) {
                    return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order
                }
                fromArray(e) {
                    return this._x = e[0], this._y = e[1], this._z = e[2], void 0 !== e[3] && (this._order = e[3]), this._onChangeCallback(), this
                }
                toArray(e = [], t = 0) {
                    return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e
                }
                toVector3(e) {
                    return e ? e.set(this._x, this._y, this._z) : new Vector3(this._x, this._y, this._z)
                }
                _onChange(e) {
                    return this._onChangeCallback = e, this
                }
                _onChangeCallback() {}
            }
            Euler.DefaultOrder = "XYZ", Euler.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
            const po = new Matrix4,
                fo = new Quaternion;
            class Layers {
                constructor() {
                    this.mask = 1
                }
                set(e) {
                    this.mask = 1 << e | 0
                }
                enable(e) {
                    this.mask |= 1 << e | 0
                }
                enableAll() {
                    this.mask = -1
                }
                toggle(e) {
                    this.mask ^= 1 << e | 0
                }
                disable(e) {
                    this.mask &= ~(1 << e | 0)
                }
                disableAll() {
                    this.mask = 0
                }
                test(e) {
                    return 0 != (this.mask & e.mask)
                }
            }
            let mo = 0;
            const go = new Vector3,
                vo = new Quaternion,
                yo = new Matrix4,
                xo = new Vector3,
                _o = new Vector3,
                bo = new Vector3,
                Mo = new Quaternion,
                So = new Vector3(1, 0, 0),
                Ao = new Vector3(0, 1, 0),
                wo = new Vector3(0, 0, 1),
                To = {
                    type: "added"
                },
                Lo = {
                    type: "removed"
                };
            Object3D.DefaultUp = new Vector3(0, 1, 0), Object3D.DefaultMatrixAutoUpdate = !0, Object3D.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
                constructor: Object3D,
                isObject3D: !0,
                onBeforeRender: function() {},
                onAfterRender: function() {},
                applyMatrix4: function(e) {
                    this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale)
                },
                applyQuaternion: function(e) {
                    return this.quaternion.premultiply(e), this
                },
                setRotationFromAxisAngle: function(e, t) {
                    this.quaternion.setFromAxisAngle(e, t)
                },
                setRotationFromEuler: function(e) {
                    this.quaternion.setFromEuler(e, !0)
                },
                setRotationFromMatrix: function(e) {
                    this.quaternion.setFromRotationMatrix(e)
                },
                setRotationFromQuaternion: function(e) {
                    this.quaternion.copy(e)
                },
                rotateOnAxis: function(e, t) {
                    return vo.setFromAxisAngle(e, t), this.quaternion.multiply(vo), this
                },
                rotateOnWorldAxis: function(e, t) {
                    return vo.setFromAxisAngle(e, t), this.quaternion.premultiply(vo), this
                },
                rotateX: function(e) {
                    return this.rotateOnAxis(So, e)
                },
                rotateY: function(e) {
                    return this.rotateOnAxis(Ao, e)
                },
                rotateZ: function(e) {
                    return this.rotateOnAxis(wo, e)
                },
                translateOnAxis: function(e, t) {
                    return go.copy(e).applyQuaternion(this.quaternion), this.position.add(go.multiplyScalar(t)), this
                },
                translateX: function(e) {
                    return this.translateOnAxis(So, e)
                },
                translateY: function(e) {
                    return this.translateOnAxis(Ao, e)
                },
                translateZ: function(e) {
                    return this.translateOnAxis(wo, e)
                },
                localToWorld: function(e) {
                    return e.applyMatrix4(this.matrixWorld)
                },
                worldToLocal: function(e) {
                    return e.applyMatrix4(yo.copy(this.matrixWorld).invert())
                },
                lookAt: function(e, t, n) {
                    e.isVector3 ? xo.copy(e) : xo.set(e, t, n);
                    const i = this.parent;
                    this.updateWorldMatrix(!0, !1), _o.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? yo.lookAt(_o, xo, this.up) : yo.lookAt(xo, _o, this.up), this.quaternion.setFromRotationMatrix(yo), i && (yo.extractRotation(i.matrixWorld), vo.setFromRotationMatrix(yo), this.quaternion.premultiply(vo.invert()))
                },
                add: function(e) {
                    if (arguments.length > 1) {
                        for (let e = 0; e < arguments.length; e++) this.add(arguments[e]);
                        return this
                    }
                    return e === this || e && e.isObject3D && (null !== e.parent && e.parent.remove(e), e.parent = this, this.children.push(e), e.dispatchEvent(To)), this
                },
                remove: function(e) {
                    if (arguments.length > 1) {
                        for (let e = 0; e < arguments.length; e++) this.remove(arguments[e]);
                        return this
                    }
                    const t = this.children.indexOf(e);
                    return -1 !== t && (e.parent = null, this.children.splice(t, 1), e.dispatchEvent(Lo)), this
                },
                clear: function() {
                    for (let e = 0; e < this.children.length; e++) {
                        const t = this.children[e];
                        t.parent = null, t.dispatchEvent(Lo)
                    }
                    return this.children.length = 0, this
                },
                attach: function(e) {
                    return this.updateWorldMatrix(!0, !1), yo.copy(this.matrixWorld).invert(), null !== e.parent && (e.parent.updateWorldMatrix(!0, !1), yo.multiply(e.parent.matrixWorld)), e.applyMatrix4(yo), e.updateWorldMatrix(!1, !1), this.add(e), this
                },
                getObjectById: function(e) {
                    return this.getObjectByProperty("id", e)
                },
                getObjectByName: function(e) {
                    return this.getObjectByProperty("name", e)
                },
                getObjectByProperty: function(e, t) {
                    if (this[e] === t) return this;
                    for (let n = 0, i = this.children.length; n < i; n++) {
                        const i = this.children[n].getObjectByProperty(e, t);
                        if (void 0 !== i) return i
                    }
                },
                getWorldPosition: function(e) {
                    return void 0 === e && (e = new Vector3), this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld)
                },
                getWorldQuaternion: function(e) {
                    return void 0 === e && (e = new Quaternion), this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(_o, e, bo), e
                },
                getWorldScale: function(e) {
                    return void 0 === e && (e = new Vector3), this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(_o, Mo, e), e
                },
                getWorldDirection: function(e) {
                    void 0 === e && (e = new Vector3), this.updateWorldMatrix(!0, !1);
                    const t = this.matrixWorld.elements;
                    return e.set(t[8], t[9], t[10]).normalize()
                },
                raycast: function() {},
                traverse: function(e) {
                    e(this);
                    const t = this.children;
                    for (let n = 0, i = t.length; n < i; n++) t[n].traverse(e)
                },
                traverseVisible: function(e) {
                    if (!1 === this.visible) return;
                    e(this);
                    const t = this.children;
                    for (let n = 0, i = t.length; n < i; n++) t[n].traverseVisible(e)
                },
                traverseAncestors: function(e) {
                    const t = this.parent;
                    null !== t && (e(t), t.traverseAncestors(e))
                },
                updateMatrix: function() {
                    this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
                },
                updateMatrixWorld: function(e) {
                    this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, e = !0);
                    const t = this.children;
                    for (let n = 0, i = t.length; n < i; n++) t[n].updateMatrixWorld(e)
                },
                updateWorldMatrix: function(e, t) {
                    const n = this.parent;
                    if (!0 === e && null !== n && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), !0 === t) {
                        const e = this.children;
                        for (let t = 0, n = e.length; t < n; t++) e[t].updateWorldMatrix(!1, !0)
                    }
                },
                toJSON: function(e) {
                    function serialize(t, n) {
                        return void 0 === t[n.uuid] && (t[n.uuid] = n.toJSON(e)), n.uuid
                    }

                    function extractFromCache(e) {
                        const t = [];
                        for (const n in e) {
                            const i = e[n];
                            delete i.metadata, t.push(i)
                        }
                        return t
                    }
                    const t = void 0 === e || "string" == typeof e,
                        n = {};
                    t && (e = {
                        geometries: {},
                        materials: {},
                        textures: {},
                        images: {},
                        shapes: {},
                        skeletons: {},
                        animations: {}
                    }, n.metadata = {
                        version: 4.5,
                        type: "Object",
                        generator: "Object3D.toJSON"
                    });
                    const i = {};
                    if (i.uuid = this.uuid, i.type = this.type, "" !== this.name && (i.name = this.name), !0 === this.castShadow && (i.castShadow = !0), !0 === this.receiveShadow && (i.receiveShadow = !0), !1 === this.visible && (i.visible = !1), !1 === this.frustumCulled && (i.frustumCulled = !1), 0 !== this.renderOrder && (i.renderOrder = this.renderOrder), "{}" !== JSON.stringify(this.userData) && (i.userData = this.userData), i.layers = this.layers.mask, i.matrix = this.matrix.toArray(), !1 === this.matrixAutoUpdate && (i.matrixAutoUpdate = !1), this.isInstancedMesh && (i.type = "InstancedMesh", i.count = this.count, i.instanceMatrix = this.instanceMatrix.toJSON()), this.isMesh || this.isLine || this.isPoints) {
                        i.geometry = serialize(e.geometries, this.geometry);
                        const t = this.geometry.parameters;
                        if (void 0 !== t && void 0 !== t.shapes) {
                            const n = t.shapes;
                            if (Array.isArray(n))
                                for (let t = 0, i = n.length; t < i; t++) {
                                    const i = n[t];
                                    serialize(e.shapes, i)
                                } else serialize(e.shapes, n)
                        }
                    }
                    if (this.isSkinnedMesh && (i.bindMode = this.bindMode, i.bindMatrix = this.bindMatrix.toArray(), void 0 !== this.skeleton && (serialize(e.skeletons, this.skeleton), i.skeleton = this.skeleton.uuid)), void 0 !== this.material)
                        if (Array.isArray(this.material)) {
                            const t = [];
                            for (let n = 0, i = this.material.length; n < i; n++) t.push(serialize(e.materials, this.material[n]));
                            i.material = t
                        } else i.material = serialize(e.materials, this.material);
                    if (this.children.length > 0) {
                        i.children = [];
                        for (let t = 0; t < this.children.length; t++) i.children.push(this.children[t].toJSON(e).object)
                    }
                    if (this.animations.length > 0) {
                        i.animations = [];
                        for (let t = 0; t < this.animations.length; t++) {
                            const n = this.animations[t];
                            i.animations.push(serialize(e.animations, n))
                        }
                    }
                    if (t) {
                        const t = extractFromCache(e.geometries),
                            i = extractFromCache(e.materials),
                            r = extractFromCache(e.textures),
                            a = extractFromCache(e.images),
                            o = extractFromCache(e.shapes),
                            s = extractFromCache(e.skeletons),
                            l = extractFromCache(e.animations);
                        t.length > 0 && (n.geometries = t), i.length > 0 && (n.materials = i), r.length > 0 && (n.textures = r), a.length > 0 && (n.images = a), o.length > 0 && (n.shapes = o), s.length > 0 && (n.skeletons = s), l.length > 0 && (n.animations = l)
                    }
                    return n.object = i, n
                },
                clone: function(e) {
                    return (new this.constructor).copy(this, e)
                },
                copy: function(e, t = !0) {
                    if (this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.userData = JSON.parse(JSON.stringify(e.userData)), !0 === t)
                        for (let t = 0; t < e.children.length; t++) {
                            const n = e.children[t];
                            this.add(n.clone())
                        }
                    return this
                }
            });
            const Co = new Vector3,
                Po = new Vector3,
                Eo = new Matrix3;
            class Plane {
                constructor(e, t) {
                    Object.defineProperty(this, "isPlane", {
                        value: !0
                    }), this.normal = void 0 !== e ? e : new Vector3(1, 0, 0), this.constant = void 0 !== t ? t : 0
                }
                set(e, t) {
                    return this.normal.copy(e), this.constant = t, this
                }
                setComponents(e, t, n, i) {
                    return this.normal.set(e, t, n), this.constant = i, this
                }
                setFromNormalAndCoplanarPoint(e, t) {
                    return this.normal.copy(e), this.constant = -t.dot(this.normal), this
                }
                setFromCoplanarPoints(e, t, n) {
                    const i = Co.subVectors(n, t).cross(Po.subVectors(e, t)).normalize();
                    return this.setFromNormalAndCoplanarPoint(i, e), this
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                copy(e) {
                    return this.normal.copy(e.normal), this.constant = e.constant, this
                }
                normalize() {
                    const e = 1 / this.normal.length();
                    return this.normal.multiplyScalar(e), this.constant *= e, this
                }
                negate() {
                    return this.constant *= -1, this.normal.negate(), this
                }
                distanceToPoint(e) {
                    return this.normal.dot(e) + this.constant
                }
                distanceToSphere(e) {
                    return this.distanceToPoint(e.center) - e.radius
                }
                projectPoint(e, t) {
                    return void 0 === t && (t = new Vector3), t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e)
                }
                intersectLine(e, t) {
                    void 0 === t && (t = new Vector3);
                    const n = e.delta(Co),
                        i = this.normal.dot(n);
                    if (0 === i) return 0 === this.distanceToPoint(e.start) ? t.copy(e.start) : void 0;
                    const r = -(e.start.dot(this.normal) + this.constant) / i;
                    return r < 0 || r > 1 ? void 0 : t.copy(n).multiplyScalar(r).add(e.start)
                }
                intersectsLine(e) {
                    const t = this.distanceToPoint(e.start),
                        n = this.distanceToPoint(e.end);
                    return t < 0 && n > 0 || n < 0 && t > 0
                }
                intersectsBox(e) {
                    return e.intersectsPlane(this)
                }
                intersectsSphere(e) {
                    return e.intersectsPlane(this)
                }
                coplanarPoint(e) {
                    return void 0 === e && (e = new Vector3), e.copy(this.normal).multiplyScalar(-this.constant)
                }
                applyMatrix4(e, t) {
                    const n = t || Eo.getNormalMatrix(e),
                        i = this.coplanarPoint(Co).applyMatrix4(e),
                        r = this.normal.applyMatrix3(n).normalize();
                    return this.constant = -i.dot(r), this
                }
                translate(e) {
                    return this.constant -= e.dot(this.normal), this
                }
                equals(e) {
                    return e.normal.equals(this.normal) && e.constant === this.constant
                }
            }
            const Io = new Vector3,
                Fo = new Vector3,
                Oo = new Vector3,
                Bo = new Vector3,
                Ro = new Vector3,
                No = new Vector3,
                Do = new Vector3,
                Vo = new Vector3,
                Uo = new Vector3,
                zo = new Vector3;
            class Triangle {
                constructor(e, t, n) {
                    this.a = void 0 !== e ? e : new Vector3, this.b = void 0 !== t ? t : new Vector3, this.c = void 0 !== n ? n : new Vector3
                }
                static getNormal(e, t, n, i) {
                    void 0 === i && (i = new Vector3), i.subVectors(n, t), Io.subVectors(e, t), i.cross(Io);
                    const r = i.lengthSq();
                    return r > 0 ? i.multiplyScalar(1 / Math.sqrt(r)) : i.set(0, 0, 0)
                }
                static getBarycoord(e, t, n, i, r) {
                    Io.subVectors(i, t), Fo.subVectors(n, t), Oo.subVectors(e, t);
                    const a = Io.dot(Io),
                        o = Io.dot(Fo),
                        s = Io.dot(Oo),
                        l = Fo.dot(Fo),
                        c = Fo.dot(Oo),
                        u = a * l - o * o;
                    if (void 0 === r && (r = new Vector3), 0 === u) return r.set(-2, -1, -1);
                    const h = 1 / u,
                        d = (l * s - o * c) * h,
                        p = (a * c - o * s) * h;
                    return r.set(1 - d - p, p, d)
                }
                static containsPoint(e, t, n, i) {
                    return this.getBarycoord(e, t, n, i, Bo), Bo.x >= 0 && Bo.y >= 0 && Bo.x + Bo.y <= 1
                }
                static getUV(e, t, n, i, r, a, o, s) {
                    return this.getBarycoord(e, t, n, i, Bo), s.set(0, 0), s.addScaledVector(r, Bo.x), s.addScaledVector(a, Bo.y), s.addScaledVector(o, Bo.z), s
                }
                static isFrontFacing(e, t, n, i) {
                    return Io.subVectors(n, t), Fo.subVectors(e, t), Io.cross(Fo).dot(i) < 0
                }
                set(e, t, n) {
                    return this.a.copy(e), this.b.copy(t), this.c.copy(n), this
                }
                setFromPointsAndIndices(e, t, n, i) {
                    return this.a.copy(e[t]), this.b.copy(e[n]), this.c.copy(e[i]), this
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                copy(e) {
                    return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this
                }
                getArea() {
                    return Io.subVectors(this.c, this.b), Fo.subVectors(this.a, this.b), .5 * Io.cross(Fo).length()
                }
                getMidpoint(e) {
                    return void 0 === e && (e = new Vector3), e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
                }
                getNormal(e) {
                    return Triangle.getNormal(this.a, this.b, this.c, e)
                }
                getPlane(e) {
                    return void 0 === e && (e = new Plane), e.setFromCoplanarPoints(this.a, this.b, this.c)
                }
                getBarycoord(e, t) {
                    return Triangle.getBarycoord(e, this.a, this.b, this.c, t)
                }
                getUV(e, t, n, i, r) {
                    return Triangle.getUV(e, this.a, this.b, this.c, t, n, i, r)
                }
                containsPoint(e) {
                    return Triangle.containsPoint(e, this.a, this.b, this.c)
                }
                isFrontFacing(e) {
                    return Triangle.isFrontFacing(this.a, this.b, this.c, e)
                }
                intersectsBox(e) {
                    return e.intersectsTriangle(this)
                }
                closestPointToPoint(e, t) {
                    void 0 === t && (t = new Vector3);
                    const n = this.a,
                        i = this.b,
                        r = this.c;
                    let a, o;
                    Ro.subVectors(i, n), No.subVectors(r, n), Vo.subVectors(e, n);
                    const s = Ro.dot(Vo),
                        l = No.dot(Vo);
                    if (s <= 0 && l <= 0) return t.copy(n);
                    Uo.subVectors(e, i);
                    const c = Ro.dot(Uo),
                        u = No.dot(Uo);
                    if (c >= 0 && u <= c) return t.copy(i);
                    const h = s * u - c * l;
                    if (h <= 0 && s >= 0 && c <= 0) return a = s / (s - c), t.copy(n).addScaledVector(Ro, a);
                    zo.subVectors(e, r);
                    const d = Ro.dot(zo),
                        p = No.dot(zo);
                    if (p >= 0 && d <= p) return t.copy(r);
                    const f = d * l - s * p;
                    if (f <= 0 && l >= 0 && p <= 0) return o = l / (l - p), t.copy(n).addScaledVector(No, o);
                    const m = c * p - d * u;
                    if (m <= 0 && u - c >= 0 && d - p >= 0) return Do.subVectors(r, i), o = (u - c) / (u - c + (d - p)), t.copy(i).addScaledVector(Do, o);
                    const g = 1 / (m + f + h);
                    return a = f * g, o = h * g, t.copy(n).addScaledVector(Ro, a).addScaledVector(No, o)
                }
                equals(e) {
                    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c)
                }
            }
            const Go = {
                    aliceblue: 15792383,
                    antiquewhite: 16444375,
                    aqua: 65535,
                    aquamarine: 8388564,
                    azure: 15794175,
                    beige: 16119260,
                    bisque: 16770244,
                    black: 0,
                    blanchedalmond: 16772045,
                    blue: 255,
                    blueviolet: 9055202,
                    brown: 10824234,
                    burlywood: 14596231,
                    cadetblue: 6266528,
                    chartreuse: 8388352,
                    chocolate: 13789470,
                    coral: 16744272,
                    cornflowerblue: 6591981,
                    cornsilk: 16775388,
                    crimson: 14423100,
                    cyan: 65535,
                    darkblue: 139,
                    darkcyan: 35723,
                    darkgoldenrod: 12092939,
                    darkgray: 11119017,
                    darkgreen: 25600,
                    darkgrey: 11119017,
                    darkkhaki: 12433259,
                    darkmagenta: 9109643,
                    darkolivegreen: 5597999,
                    darkorange: 16747520,
                    darkorchid: 10040012,
                    darkred: 9109504,
                    darksalmon: 15308410,
                    darkseagreen: 9419919,
                    darkslateblue: 4734347,
                    darkslategray: 3100495,
                    darkslategrey: 3100495,
                    darkturquoise: 52945,
                    darkviolet: 9699539,
                    deeppink: 16716947,
                    deepskyblue: 49151,
                    dimgray: 6908265,
                    dimgrey: 6908265,
                    dodgerblue: 2003199,
                    firebrick: 11674146,
                    floralwhite: 16775920,
                    forestgreen: 2263842,
                    fuchsia: 16711935,
                    gainsboro: 14474460,
                    ghostwhite: 16316671,
                    gold: 16766720,
                    goldenrod: 14329120,
                    gray: 8421504,
                    green: 32768,
                    greenyellow: 11403055,
                    grey: 8421504,
                    honeydew: 15794160,
                    hotpink: 16738740,
                    indianred: 13458524,
                    indigo: 4915330,
                    ivory: 16777200,
                    khaki: 15787660,
                    lavender: 15132410,
                    lavenderblush: 16773365,
                    lawngreen: 8190976,
                    lemonchiffon: 16775885,
                    lightblue: 11393254,
                    lightcoral: 15761536,
                    lightcyan: 14745599,
                    lightgoldenrodyellow: 16448210,
                    lightgray: 13882323,
                    lightgreen: 9498256,
                    lightgrey: 13882323,
                    lightpink: 16758465,
                    lightsalmon: 16752762,
                    lightseagreen: 2142890,
                    lightskyblue: 8900346,
                    lightslategray: 7833753,
                    lightslategrey: 7833753,
                    lightsteelblue: 11584734,
                    lightyellow: 16777184,
                    lime: 65280,
                    limegreen: 3329330,
                    linen: 16445670,
                    magenta: 16711935,
                    maroon: 8388608,
                    mediumaquamarine: 6737322,
                    mediumblue: 205,
                    mediumorchid: 12211667,
                    mediumpurple: 9662683,
                    mediumseagreen: 3978097,
                    mediumslateblue: 8087790,
                    mediumspringgreen: 64154,
                    mediumturquoise: 4772300,
                    mediumvioletred: 13047173,
                    midnightblue: 1644912,
                    mintcream: 16121850,
                    mistyrose: 16770273,
                    moccasin: 16770229,
                    navajowhite: 16768685,
                    navy: 128,
                    oldlace: 16643558,
                    olive: 8421376,
                    olivedrab: 7048739,
                    orange: 16753920,
                    orangered: 16729344,
                    orchid: 14315734,
                    palegoldenrod: 15657130,
                    palegreen: 10025880,
                    paleturquoise: 11529966,
                    palevioletred: 14381203,
                    papayawhip: 16773077,
                    peachpuff: 16767673,
                    peru: 13468991,
                    pink: 16761035,
                    plum: 14524637,
                    powderblue: 11591910,
                    purple: 8388736,
                    rebeccapurple: 6697881,
                    red: 16711680,
                    rosybrown: 12357519,
                    royalblue: 4286945,
                    saddlebrown: 9127187,
                    salmon: 16416882,
                    sandybrown: 16032864,
                    seagreen: 3050327,
                    seashell: 16774638,
                    sienna: 10506797,
                    silver: 12632256,
                    skyblue: 8900331,
                    slateblue: 6970061,
                    slategray: 7372944,
                    slategrey: 7372944,
                    snow: 16775930,
                    springgreen: 65407,
                    steelblue: 4620980,
                    tan: 13808780,
                    teal: 32896,
                    thistle: 14204888,
                    tomato: 16737095,
                    turquoise: 4251856,
                    violet: 15631086,
                    wheat: 16113331,
                    white: 16777215,
                    whitesmoke: 16119285,
                    yellow: 16776960,
                    yellowgreen: 10145074
                },
                ko = {
                    h: 0,
                    s: 0,
                    l: 0
                },
                jo = {
                    h: 0,
                    s: 0,
                    l: 0
                };
            class Color {
                constructor(e, t, n) {
                    return Object.defineProperty(this, "isColor", {
                        value: !0
                    }), void 0 === t && void 0 === n ? this.set(e) : this.setRGB(e, t, n)
                }
                set(e) {
                    return e && e.isColor ? this.copy(e) : "number" == typeof e ? this.setHex(e) : "string" == typeof e && this.setStyle(e), this
                }
                setScalar(e) {
                    return this.r = e, this.g = e, this.b = e, this
                }
                setHex(e) {
                    return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (255 & e) / 255, this
                }
                setRGB(e, t, n) {
                    return this.r = e, this.g = t, this.b = n, this
                }
                setHSL(e, t, n) {
                    if (e = Fa.euclideanModulo(e, 1), t = Fa.clamp(t, 0, 1), n = Fa.clamp(n, 0, 1), 0 === t) this.r = this.g = this.b = n;
                    else {
                        const i = n <= .5 ? n * (1 + t) : n + t - n * t,
                            r = 2 * n - i;
                        this.r = hue2rgb(r, i, e + 1 / 3), this.g = hue2rgb(r, i, e), this.b = hue2rgb(r, i, e - 1 / 3)
                    }
                    return this
                }
                setStyle(e) {
                    let t;
                    if (t = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(e)) {
                        let e;
                        const n = t[1],
                            i = t[2];
                        switch (n) {
                            case "rgb":
                            case "rgba":
                                if (e = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(i)) return this.r = Math.min(255, parseInt(e[1], 10)) / 255, this.g = Math.min(255, parseInt(e[2], 10)) / 255, this.b = Math.min(255, parseInt(e[3], 10)) / 255, e[4], this;
                                if (e = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(i)) return this.r = Math.min(100, parseInt(e[1], 10)) / 100, this.g = Math.min(100, parseInt(e[2], 10)) / 100, this.b = Math.min(100, parseInt(e[3], 10)) / 100, e[4], this;
                                break;
                            case "hsl":
                            case "hsla":
                                if (e = /^(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(i)) {
                                    const t = parseFloat(e[1]) / 360,
                                        n = parseInt(e[2], 10) / 100,
                                        i = parseInt(e[3], 10) / 100;
                                    return e[4], this.setHSL(t, n, i)
                                }
                        }
                    } else if (t = /^\#([A-Fa-f\d]+)$/.exec(e)) {
                        const e = t[1],
                            n = e.length;
                        if (3 === n) return this.r = parseInt(e.charAt(0) + e.charAt(0), 16) / 255, this.g = parseInt(e.charAt(1) + e.charAt(1), 16) / 255, this.b = parseInt(e.charAt(2) + e.charAt(2), 16) / 255, this;
                        if (6 === n) return this.r = parseInt(e.charAt(0) + e.charAt(1), 16) / 255, this.g = parseInt(e.charAt(2) + e.charAt(3), 16) / 255, this.b = parseInt(e.charAt(4) + e.charAt(5), 16) / 255, this
                    }
                    return e && e.length > 0 ? this.setColorName(e) : this
                }
                setColorName(e) {
                    const t = Go[e];
                    return void 0 !== t && this.setHex(t), this
                }
                clone() {
                    return new this.constructor(this.r, this.g, this.b)
                }
                copy(e) {
                    return this.r = e.r, this.g = e.g, this.b = e.b, this
                }
                copyGammaToLinear(e, t = 2) {
                    return this.r = Math.pow(e.r, t), this.g = Math.pow(e.g, t), this.b = Math.pow(e.b, t), this
                }
                copyLinearToGamma(e, t = 2) {
                    const n = t > 0 ? 1 / t : 1;
                    return this.r = Math.pow(e.r, n), this.g = Math.pow(e.g, n), this.b = Math.pow(e.b, n), this
                }
                convertGammaToLinear(e) {
                    return this.copyGammaToLinear(this, e), this
                }
                convertLinearToGamma(e) {
                    return this.copyLinearToGamma(this, e), this
                }
                copySRGBToLinear(e) {
                    return this.r = SRGBToLinear(e.r), this.g = SRGBToLinear(e.g), this.b = SRGBToLinear(e.b), this
                }
                copyLinearToSRGB(e) {
                    return this.r = LinearToSRGB(e.r), this.g = LinearToSRGB(e.g), this.b = LinearToSRGB(e.b), this
                }
                convertSRGBToLinear() {
                    return this.copySRGBToLinear(this), this
                }
                convertLinearToSRGB() {
                    return this.copyLinearToSRGB(this), this
                }
                getHex() {
                    return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
                }
                getHexString() {
                    return ("000000" + this.getHex().toString(16)).slice(-6)
                }
                getHSL(e) {
                    void 0 === e && (e = {
                        h: 0,
                        s: 0,
                        l: 0
                    });
                    const t = this.r,
                        n = this.g,
                        i = this.b,
                        r = Math.max(t, n, i),
                        a = Math.min(t, n, i);
                    let o, s;
                    const l = (a + r) / 2;
                    if (a === r) o = 0, s = 0;
                    else {
                        const e = r - a;
                        switch (s = l <= .5 ? e / (r + a) : e / (2 - r - a), r) {
                            case t:
                                o = (n - i) / e + (n < i ? 6 : 0);
                                break;
                            case n:
                                o = (i - t) / e + 2;
                                break;
                            case i:
                                o = (t - n) / e + 4
                        }
                        o /= 6
                    }
                    return e.h = o, e.s = s, e.l = l, e
                }
                getStyle() {
                    return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
                }
                offsetHSL(e, t, n) {
                    return this.getHSL(ko), ko.h += e, ko.s += t, ko.l += n, this.setHSL(ko.h, ko.s, ko.l), this
                }
                add(e) {
                    return this.r += e.r, this.g += e.g, this.b += e.b, this
                }
                addColors(e, t) {
                    return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this
                }
                addScalar(e) {
                    return this.r += e, this.g += e, this.b += e, this
                }
                sub(e) {
                    return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this
                }
                multiply(e) {
                    return this.r *= e.r, this.g *= e.g, this.b *= e.b, this
                }
                multiplyScalar(e) {
                    return this.r *= e, this.g *= e, this.b *= e, this
                }
                lerp(e, t) {
                    return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this
                }
                lerpHSL(e, t) {
                    this.getHSL(ko), e.getHSL(jo);
                    const n = Fa.lerp(ko.h, jo.h, t),
                        i = Fa.lerp(ko.s, jo.s, t),
                        r = Fa.lerp(ko.l, jo.l, t);
                    return this.setHSL(n, i, r), this
                }
                equals(e) {
                    return e.r === this.r && e.g === this.g && e.b === this.b
                }
                fromArray(e, t = 0) {
                    return this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this
                }
                toArray(e = [], t = 0) {
                    return e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e
                }
                fromBufferAttribute(e, t) {
                    return this.r = e.getX(t), this.g = e.getY(t), this.b = e.getZ(t), !0 === e.normalized && (this.r /= 255, this.g /= 255, this.b /= 255), this
                }
                toJSON() {
                    return this.getHex()
                }
            }
            Color.NAMES = Go, Color.prototype.r = 1, Color.prototype.g = 1, Color.prototype.b = 1;
            class Face3 {
                constructor(e, t, n, i, r, a = 0) {
                    this.a = e, this.b = t, this.c = n, this.normal = i && i.isVector3 ? i : new Vector3, this.vertexNormals = Array.isArray(i) ? i : [], this.color = r && r.isColor ? r : new Color, this.vertexColors = Array.isArray(r) ? r : [], this.materialIndex = a
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                copy(e) {
                    this.a = e.a, this.b = e.b, this.c = e.c, this.normal.copy(e.normal), this.color.copy(e.color), this.materialIndex = e.materialIndex;
                    for (let t = 0, n = e.vertexNormals.length; t < n; t++) this.vertexNormals[t] = e.vertexNormals[t].clone();
                    for (let t = 0, n = e.vertexColors.length; t < n; t++) this.vertexColors[t] = e.vertexColors[t].clone();
                    return this
                }
            }
            let Wo = 0;
            Material.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
                constructor: Material,
                isMaterial: !0,
                onBeforeCompile: function() {},
                customProgramCacheKey: function() {
                    return this.onBeforeCompile.toString()
                },
                setValues: function(e) {
                    if (void 0 !== e)
                        for (const t in e) {
                            const n = e[t];
                            if (void 0 === n) continue;
                            if ("shading" === t) {
                                this.flatShading = n === dn;
                                continue
                            }
                            const i = this[t];
                            void 0 !== i && (i && i.isColor ? i.set(n) : i && i.isVector3 && n && n.isVector3 ? i.copy(n) : this[t] = n)
                        }
                },
                toJSON: function(e) {
                    function extractFromCache(e) {
                        const t = [];
                        for (const n in e) {
                            const i = e[n];
                            delete i.metadata, t.push(i)
                        }
                        return t
                    }
                    const t = void 0 === e || "string" == typeof e;
                    t && (e = {
                        textures: {},
                        images: {}
                    });
                    const n = {
                        metadata: {
                            version: 4.5,
                            type: "Material",
                            generator: "Material.toJSON"
                        }
                    };
                    if (n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), void 0 !== this.roughness && (n.roughness = this.roughness), void 0 !== this.metalness && (n.metalness = this.metalness), this.sheen && this.sheen.isColor && (n.sheen = this.sheen.getHex()), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.emissiveIntensity && 1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), void 0 !== this.shininess && (n.shininess = this.shininess), void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat), void 0 !== this.clearcoatRoughness && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(e).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(e).uuid), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(e).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(e).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(e).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(e).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(e).uuid, n.reflectivity = this.reflectivity, n.refractionRatio = this.refractionRatio, void 0 !== this.combine && (n.combine = this.combine), void 0 !== this.envMapIntensity && (n.envMapIntensity = this.envMapIntensity)), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(e).uuid), void 0 !== this.size && (n.size = this.size), void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation), this.blending !== mn && (n.blending = this.blending), !0 === this.flatShading && (n.flatShading = this.flatShading), this.side !== cn && (n.side = this.side), this.vertexColors && (n.vertexColors = !0), this.opacity < 1 && (n.opacity = this.opacity), !0 === this.transparent && (n.transparent = this.transparent), n.depthFunc = this.depthFunc, n.depthTest = this.depthTest, n.depthWrite = this.depthWrite, n.stencilWrite = this.stencilWrite, n.stencilWriteMask = this.stencilWriteMask, n.stencilFunc = this.stencilFunc, n.stencilRef = this.stencilRef, n.stencilFuncMask = this.stencilFuncMask, n.stencilFail = this.stencilFail, n.stencilZFail = this.stencilZFail, n.stencilZPass = this.stencilZPass, this.rotation && 0 !== this.rotation && (n.rotation = this.rotation), !0 === this.polygonOffset && (n.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (n.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (n.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth && 1 !== this.linewidth && (n.linewidth = this.linewidth), void 0 !== this.dashSize && (n.dashSize = this.dashSize), void 0 !== this.gapSize && (n.gapSize = this.gapSize), void 0 !== this.scale && (n.scale = this.scale), !0 === this.dithering && (n.dithering = !0), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), !0 === this.premultipliedAlpha && (n.premultipliedAlpha = this.premultipliedAlpha), !0 === this.wireframe && (n.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin), !0 === this.morphTargets && (n.morphTargets = !0), !0 === this.morphNormals && (n.morphNormals = !0), !0 === this.skinning && (n.skinning = !0), !1 === this.visible && (n.visible = !1), !1 === this.toneMapped && (n.toneMapped = !1), "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData), t) {
                        const t = extractFromCache(e.textures),
                            i = extractFromCache(e.images);
                        t.length > 0 && (n.textures = t), i.length > 0 && (n.images = i)
                    }
                    return n
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(e) {
                    this.name = e.name, this.fog = e.fog, this.blending = e.blending, this.side = e.side, this.flatShading = e.flatShading, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.stencilWriteMask = e.stencilWriteMask, this.stencilFunc = e.stencilFunc, this.stencilRef = e.stencilRef, this.stencilFuncMask = e.stencilFuncMask, this.stencilFail = e.stencilFail, this.stencilZFail = e.stencilZFail, this.stencilZPass = e.stencilZPass, this.stencilWrite = e.stencilWrite;
                    const t = e.clippingPlanes;
                    let n = null;
                    if (null !== t) {
                        const e = t.length;
                        n = Array(e);
                        for (let i = 0; i !== e; ++i) n[i] = t[i].clone()
                    }
                    return this.clippingPlanes = n, this.clipIntersection = e.clipIntersection, this.clipShadows = e.clipShadows, this.shadowSide = e.shadowSide, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.premultipliedAlpha = e.premultipliedAlpha, this.visible = e.visible, this.toneMapped = e.toneMapped, this.userData = JSON.parse(JSON.stringify(e.userData)), this
                },
                dispose: function() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            }), Object.defineProperty(Material.prototype, "needsUpdate", {
                set: function(e) {
                    !0 === e && this.version++
                }
            }), MeshBasicMaterial.prototype = Object.create(Material.prototype), MeshBasicMaterial.prototype.constructor = MeshBasicMaterial, MeshBasicMaterial.prototype.isMeshBasicMaterial = !0, MeshBasicMaterial.prototype.copy = function(e) {
                return Material.prototype.copy.call(this, e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this
            };
            const Ho = new Vector3,
                Xo = new Vector2;
            Object.defineProperty(BufferAttribute.prototype, "needsUpdate", {
                set: function(e) {
                    !0 === e && this.version++
                }
            }), Object.assign(BufferAttribute.prototype, {
                isBufferAttribute: !0,
                onUploadCallback: function() {},
                setUsage: function(e) {
                    return this.usage = e, this
                },
                copy: function(e) {
                    return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this
                },
                copyAt: function(e, t, n) {
                    e *= this.itemSize, n *= t.itemSize;
                    for (let i = 0, r = this.itemSize; i < r; i++) this.array[e + i] = t.array[n + i];
                    return this
                },
                copyArray: function(e) {
                    return this.array.set(e), this
                },
                copyColorsArray: function(e) {
                    const t = this.array;
                    let n = 0;
                    for (let i = 0, r = e.length; i < r; i++) {
                        let r = e[i];
                        void 0 === r && (r = new Color), t[n++] = r.r, t[n++] = r.g, t[n++] = r.b
                    }
                    return this
                },
                copyVector2sArray: function(e) {
                    const t = this.array;
                    let n = 0;
                    for (let i = 0, r = e.length; i < r; i++) {
                        let r = e[i];
                        void 0 === r && (r = new Vector2), t[n++] = r.x, t[n++] = r.y
                    }
                    return this
                },
                copyVector3sArray: function(e) {
                    const t = this.array;
                    let n = 0;
                    for (let i = 0, r = e.length; i < r; i++) {
                        let r = e[i];
                        void 0 === r && (r = new Vector3), t[n++] = r.x, t[n++] = r.y, t[n++] = r.z
                    }
                    return this
                },
                copyVector4sArray: function(e) {
                    const t = this.array;
                    let n = 0;
                    for (let i = 0, r = e.length; i < r; i++) {
                        let r = e[i];
                        void 0 === r && (r = new Vector4), t[n++] = r.x, t[n++] = r.y, t[n++] = r.z, t[n++] = r.w
                    }
                    return this
                },
                applyMatrix3: function(e) {
                    if (2 === this.itemSize)
                        for (let t = 0, n = this.count; t < n; t++) Xo.fromBufferAttribute(this, t), Xo.applyMatrix3(e), this.setXY(t, Xo.x, Xo.y);
                    else if (3 === this.itemSize)
                        for (let t = 0, n = this.count; t < n; t++) Ho.fromBufferAttribute(this, t), Ho.applyMatrix3(e), this.setXYZ(t, Ho.x, Ho.y, Ho.z);
                    return this
                },
                applyMatrix4: function(e) {
                    for (let t = 0, n = this.count; t < n; t++) Ho.x = this.getX(t), Ho.y = this.getY(t), Ho.z = this.getZ(t), Ho.applyMatrix4(e), this.setXYZ(t, Ho.x, Ho.y, Ho.z);
                    return this
                },
                applyNormalMatrix: function(e) {
                    for (let t = 0, n = this.count; t < n; t++) Ho.x = this.getX(t), Ho.y = this.getY(t), Ho.z = this.getZ(t), Ho.applyNormalMatrix(e), this.setXYZ(t, Ho.x, Ho.y, Ho.z);
                    return this
                },
                transformDirection: function(e) {
                    for (let t = 0, n = this.count; t < n; t++) Ho.x = this.getX(t), Ho.y = this.getY(t), Ho.z = this.getZ(t), Ho.transformDirection(e), this.setXYZ(t, Ho.x, Ho.y, Ho.z);
                    return this
                },
                set: function(e, t = 0) {
                    return this.array.set(e, t), this
                },
                getX: function(e) {
                    return this.array[e * this.itemSize]
                },
                setX: function(e, t) {
                    return this.array[e * this.itemSize] = t, this
                },
                getY: function(e) {
                    return this.array[e * this.itemSize + 1]
                },
                setY: function(e, t) {
                    return this.array[e * this.itemSize + 1] = t, this
                },
                getZ: function(e) {
                    return this.array[e * this.itemSize + 2]
                },
                setZ: function(e, t) {
                    return this.array[e * this.itemSize + 2] = t, this
                },
                getW: function(e) {
                    return this.array[e * this.itemSize + 3]
                },
                setW: function(e, t) {
                    return this.array[e * this.itemSize + 3] = t, this
                },
                setXY: function(e, t, n) {
                    return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = n, this
                },
                setXYZ: function(e, t, n, i) {
                    return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = i, this
                },
                setXYZW: function(e, t, n, i, r) {
                    return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = i, this.array[e + 3] = r, this
                },
                onUpload: function(e) {
                    return this.onUploadCallback = e, this
                },
                clone: function() {
                    return new this.constructor(this.array, this.itemSize).copy(this)
                },
                toJSON: function() {
                    return {
                        itemSize: this.itemSize,
                        type: this.array.constructor.name,
                        array: Array.prototype.slice.call(this.array),
                        normalized: this.normalized
                    }
                }
            }), Int8BufferAttribute.prototype = Object.create(BufferAttribute.prototype), Int8BufferAttribute.prototype.constructor = Int8BufferAttribute, Uint8BufferAttribute.prototype = Object.create(BufferAttribute.prototype), Uint8BufferAttribute.prototype.constructor = Uint8BufferAttribute, Uint8ClampedBufferAttribute.prototype = Object.create(BufferAttribute.prototype), Uint8ClampedBufferAttribute.prototype.constructor = Uint8ClampedBufferAttribute, Int16BufferAttribute.prototype = Object.create(BufferAttribute.prototype), Int16BufferAttribute.prototype.constructor = Int16BufferAttribute, Uint16BufferAttribute.prototype = Object.create(BufferAttribute.prototype), Uint16BufferAttribute.prototype.constructor = Uint16BufferAttribute, Int32BufferAttribute.prototype = Object.create(BufferAttribute.prototype), Int32BufferAttribute.prototype.constructor = Int32BufferAttribute, Uint32BufferAttribute.prototype = Object.create(BufferAttribute.prototype), Uint32BufferAttribute.prototype.constructor = Uint32BufferAttribute, Float16BufferAttribute.prototype = Object.create(BufferAttribute.prototype), Float16BufferAttribute.prototype.constructor = Float16BufferAttribute, Float16BufferAttribute.prototype.isFloat16BufferAttribute = !0, Float32BufferAttribute.prototype = Object.create(BufferAttribute.prototype), Float32BufferAttribute.prototype.constructor = Float32BufferAttribute, Float64BufferAttribute.prototype = Object.create(BufferAttribute.prototype), Float64BufferAttribute.prototype.constructor = Float64BufferAttribute;
            class DirectGeometry {
                constructor() {
                    this.vertices = [], this.normals = [], this.colors = [], this.uvs = [], this.uvs2 = [], this.groups = [], this.morphTargets = {}, this.skinWeights = [], this.skinIndices = [], this.boundingBox = null, this.boundingSphere = null, this.verticesNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.uvsNeedUpdate = !1, this.groupsNeedUpdate = !1
                }
                computeGroups(e) {
                    const t = [];
                    let n, i, r;
                    const a = e.faces;
                    for (i = 0; i < a.length; i++) {
                        const e = a[i];
                        e.materialIndex !== r && (r = e.materialIndex, void 0 !== n && (n.count = 3 * i - n.start, t.push(n)), n = {
                            start: 3 * i,
                            materialIndex: r
                        })
                    }
                    void 0 !== n && (n.count = 3 * i - n.start, t.push(n)), this.groups = t
                }
                fromGeometry(e) {
                    const t = e.faces,
                        n = e.vertices,
                        i = e.faceVertexUvs,
                        r = i[0] && i[0].length > 0,
                        a = i[1] && i[1].length > 0,
                        o = e.morphTargets,
                        s = o.length;
                    let l;
                    if (s > 0) {
                        l = [];
                        for (let e = 0; e < s; e++) l[e] = {
                            name: o[e].name,
                            data: []
                        };
                        this.morphTargets.position = l
                    }
                    const c = e.morphNormals,
                        u = c.length;
                    let h;
                    if (u > 0) {
                        h = [];
                        for (let e = 0; e < u; e++) h[e] = {
                            name: c[e].name,
                            data: []
                        };
                        this.morphTargets.normal = h
                    }
                    const d = e.skinIndices,
                        p = e.skinWeights,
                        f = d.length === n.length,
                        m = p.length === n.length;
                    n.length > 0 && t.length;
                    for (let e = 0; e < t.length; e++) {
                        const g = t[e];
                        this.vertices.push(n[g.a], n[g.b], n[g.c]);
                        const y = g.vertexNormals;
                        if (3 === y.length) this.normals.push(y[0], y[1], y[2]);
                        else {
                            const e = g.normal;
                            this.normals.push(e, e, e)
                        }
                        const x = g.vertexColors;
                        if (3 === x.length) this.colors.push(x[0], x[1], x[2]);
                        else {
                            const e = g.color;
                            this.colors.push(e, e, e)
                        }
                        if (!0 === r) {
                            const t = i[0][e];
                            void 0 !== t ? this.uvs.push(t[0], t[1], t[2]) : this.uvs.push(new Vector2, new Vector2, new Vector2)
                        }
                        if (!0 === a) {
                            const t = i[1][e];
                            void 0 !== t ? this.uvs2.push(t[0], t[1], t[2]) : this.uvs2.push(new Vector2, new Vector2, new Vector2)
                        }
                        for (let e = 0; e < s; e++) {
                            const t = o[e].vertices;
                            l[e].data.push(t[g.a], t[g.b], t[g.c])
                        }
                        for (let t = 0; t < u; t++) {
                            const n = c[t].vertexNormals[e];
                            h[t].data.push(n.a, n.b, n.c)
                        }
                        f && this.skinIndices.push(d[g.a], d[g.b], d[g.c]), m && this.skinWeights.push(p[g.a], p[g.b], p[g.c])
                    }
                    return this.computeGroups(e), this.verticesNeedUpdate = e.verticesNeedUpdate, this.normalsNeedUpdate = e.normalsNeedUpdate, this.colorsNeedUpdate = e.colorsNeedUpdate, this.uvsNeedUpdate = e.uvsNeedUpdate, this.groupsNeedUpdate = e.groupsNeedUpdate, null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()), this
                }
            }
            const Yo = {
                Int8Array,
                Uint8Array,
                Uint8ClampedArray: "undefined" != typeof Uint8ClampedArray ? Uint8ClampedArray : Uint8Array,
                Int16Array,
                Uint16Array,
                Int32Array,
                Uint32Array,
                Float32Array,
                Float64Array
            };
            let qo = 1;
            const Qo = new Matrix4,
                Jo = new Object3D,
                Zo = new Vector3,
                Ko = new Box3,
                $o = new Box3,
                es = new Vector3;
            BufferGeometry.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
                constructor: BufferGeometry,
                isBufferGeometry: !0,
                getIndex: function() {
                    return this.index
                },
                setIndex: function(e) {
                    return this.index = Array.isArray(e) ? new(arrayMax(e) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(e, 1) : e, this
                },
                getAttribute: function(e) {
                    return this.attributes[e]
                },
                setAttribute: function(e, t) {
                    return this.attributes[e] = t, this
                },
                deleteAttribute: function(e) {
                    return delete this.attributes[e], this
                },
                hasAttribute: function(e) {
                    return void 0 !== this.attributes[e]
                },
                addGroup: function(e, t, n = 0) {
                    this.groups.push({
                        start: e,
                        count: t,
                        materialIndex: n
                    })
                },
                clearGroups: function() {
                    this.groups = []
                },
                setDrawRange: function(e, t) {
                    this.drawRange.start = e, this.drawRange.count = t
                },
                applyMatrix4: function(e) {
                    const t = this.attributes.position;
                    void 0 !== t && (t.applyMatrix4(e), t.needsUpdate = !0);
                    const n = this.attributes.normal;
                    if (void 0 !== n) {
                        const t = (new Matrix3).getNormalMatrix(e);
                        n.applyNormalMatrix(t), n.needsUpdate = !0
                    }
                    const i = this.attributes.tangent;
                    return void 0 !== i && (i.transformDirection(e), i.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this
                },
                rotateX: function(e) {
                    return Qo.makeRotationX(e), this.applyMatrix4(Qo), this
                },
                rotateY: function(e) {
                    return Qo.makeRotationY(e), this.applyMatrix4(Qo), this
                },
                rotateZ: function(e) {
                    return Qo.makeRotationZ(e), this.applyMatrix4(Qo), this
                },
                translate: function(e, t, n) {
                    return Qo.makeTranslation(e, t, n), this.applyMatrix4(Qo), this
                },
                scale: function(e, t, n) {
                    return Qo.makeScale(e, t, n), this.applyMatrix4(Qo), this
                },
                lookAt: function(e) {
                    return Jo.lookAt(e), Jo.updateMatrix(), this.applyMatrix4(Jo.matrix), this
                },
                center: function() {
                    return this.computeBoundingBox(), this.boundingBox.getCenter(Zo).negate(), this.translate(Zo.x, Zo.y, Zo.z), this
                },
                setFromObject: function(e) {
                    const t = e.geometry;
                    if (e.isPoints || e.isLine) {
                        const e = new Float32BufferAttribute(3 * t.vertices.length, 3),
                            n = new Float32BufferAttribute(3 * t.colors.length, 3);
                        if (this.setAttribute("position", e.copyVector3sArray(t.vertices)), this.setAttribute("color", n.copyColorsArray(t.colors)), t.lineDistances && t.lineDistances.length === t.vertices.length) {
                            const e = new Float32BufferAttribute(t.lineDistances.length, 1);
                            this.setAttribute("lineDistance", e.copyArray(t.lineDistances))
                        }
                        null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone())
                    } else e.isMesh && t && t.isGeometry && this.fromGeometry(t);
                    return this
                },
                setFromPoints: function(e) {
                    const t = [];
                    for (let n = 0, i = e.length; n < i; n++) {
                        const i = e[n];
                        t.push(i.x, i.y, i.z || 0)
                    }
                    return this.setAttribute("position", new Float32BufferAttribute(t, 3)), this
                },
                updateFromObject: function(e) {
                    let t = e.geometry;
                    if (e.isMesh) {
                        let e = t.__directGeometry;
                        if (!0 === t.elementsNeedUpdate && (e = void 0, t.elementsNeedUpdate = !1), void 0 === e) return this.fromGeometry(t);
                        e.verticesNeedUpdate = t.verticesNeedUpdate, e.normalsNeedUpdate = t.normalsNeedUpdate, e.colorsNeedUpdate = t.colorsNeedUpdate, e.uvsNeedUpdate = t.uvsNeedUpdate, e.groupsNeedUpdate = t.groupsNeedUpdate, t.verticesNeedUpdate = !1, t.normalsNeedUpdate = !1, t.colorsNeedUpdate = !1, t.uvsNeedUpdate = !1, t.groupsNeedUpdate = !1, t = e
                    }
                    if (!0 === t.verticesNeedUpdate) {
                        const e = this.attributes.position;
                        void 0 !== e && (e.copyVector3sArray(t.vertices), e.needsUpdate = !0), t.verticesNeedUpdate = !1
                    }
                    if (!0 === t.normalsNeedUpdate) {
                        const e = this.attributes.normal;
                        void 0 !== e && (e.copyVector3sArray(t.normals), e.needsUpdate = !0), t.normalsNeedUpdate = !1
                    }
                    if (!0 === t.colorsNeedUpdate) {
                        const e = this.attributes.color;
                        void 0 !== e && (e.copyColorsArray(t.colors), e.needsUpdate = !0), t.colorsNeedUpdate = !1
                    }
                    if (t.uvsNeedUpdate) {
                        const e = this.attributes.uv;
                        void 0 !== e && (e.copyVector2sArray(t.uvs), e.needsUpdate = !0), t.uvsNeedUpdate = !1
                    }
                    if (t.lineDistancesNeedUpdate) {
                        const e = this.attributes.lineDistance;
                        void 0 !== e && (e.copyArray(t.lineDistances), e.needsUpdate = !0), t.lineDistancesNeedUpdate = !1
                    }
                    return t.groupsNeedUpdate && (t.computeGroups(e.geometry), this.groups = t.groups, t.groupsNeedUpdate = !1), this
                },
                fromGeometry: function(e) {
                    return e.__directGeometry = (new DirectGeometry).fromGeometry(e), this.fromDirectGeometry(e.__directGeometry)
                },
                fromDirectGeometry: function(e) {
                    const t = new Float32Array(3 * e.vertices.length);
                    if (this.setAttribute("position", new BufferAttribute(t, 3).copyVector3sArray(e.vertices)), e.normals.length > 0) {
                        const t = new Float32Array(3 * e.normals.length);
                        this.setAttribute("normal", new BufferAttribute(t, 3).copyVector3sArray(e.normals))
                    }
                    if (e.colors.length > 0) {
                        const t = new Float32Array(3 * e.colors.length);
                        this.setAttribute("color", new BufferAttribute(t, 3).copyColorsArray(e.colors))
                    }
                    if (e.uvs.length > 0) {
                        const t = new Float32Array(2 * e.uvs.length);
                        this.setAttribute("uv", new BufferAttribute(t, 2).copyVector2sArray(e.uvs))
                    }
                    if (e.uvs2.length > 0) {
                        const t = new Float32Array(2 * e.uvs2.length);
                        this.setAttribute("uv2", new BufferAttribute(t, 2).copyVector2sArray(e.uvs2))
                    }
                    this.groups = e.groups;
                    for (const t in e.morphTargets) {
                        const n = [],
                            i = e.morphTargets[t];
                        for (let e = 0, t = i.length; e < t; e++) {
                            const t = i[e],
                                r = new Float32BufferAttribute(3 * t.data.length, 3);
                            r.name = t.name, n.push(r.copyVector3sArray(t.data))
                        }
                        this.morphAttributes[t] = n
                    }
                    if (e.skinIndices.length > 0) {
                        const t = new Float32BufferAttribute(4 * e.skinIndices.length, 4);
                        this.setAttribute("skinIndex", t.copyVector4sArray(e.skinIndices))
                    }
                    if (e.skinWeights.length > 0) {
                        const t = new Float32BufferAttribute(4 * e.skinWeights.length, 4);
                        this.setAttribute("skinWeight", t.copyVector4sArray(e.skinWeights))
                    }
                    return null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()), this
                },
                computeBoundingBox: function() {
                    null === this.boundingBox && (this.boundingBox = new Box3);
                    const e = this.attributes.position,
                        t = this.morphAttributes.position;
                    if (e && e.isGLBufferAttribute) this.boundingBox.set(new Vector3(-1 / 0, -1 / 0, -1 / 0), new Vector3(1 / 0, 1 / 0, 1 / 0));
                    else {
                        if (void 0 !== e) {
                            if (this.boundingBox.setFromBufferAttribute(e), t)
                                for (let e = 0, n = t.length; e < n; e++) {
                                    const n = t[e];
                                    Ko.setFromBufferAttribute(n), this.morphTargetsRelative ? (es.addVectors(this.boundingBox.min, Ko.min), this.boundingBox.expandByPoint(es), es.addVectors(this.boundingBox.max, Ko.max), this.boundingBox.expandByPoint(es)) : (this.boundingBox.expandByPoint(Ko.min), this.boundingBox.expandByPoint(Ko.max))
                                }
                        } else this.boundingBox.makeEmpty();
                        isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || this.boundingBox.min.z
                    }
                },
                computeBoundingSphere: function() {
                    null === this.boundingSphere && (this.boundingSphere = new Sphere);
                    const e = this.attributes.position,
                        t = this.morphAttributes.position;
                    if (e && e.isGLBufferAttribute) this.boundingSphere.set(new Vector3, 1 / 0);
                    else if (e) {
                        const n = this.boundingSphere.center;
                        if (Ko.setFromBufferAttribute(e), t)
                            for (let e = 0, n = t.length; e < n; e++) {
                                const n = t[e];
                                $o.setFromBufferAttribute(n), this.morphTargetsRelative ? (es.addVectors(Ko.min, $o.min), Ko.expandByPoint(es), es.addVectors(Ko.max, $o.max), Ko.expandByPoint(es)) : (Ko.expandByPoint($o.min), Ko.expandByPoint($o.max))
                            }
                        Ko.getCenter(n);
                        let i = 0;
                        for (let t = 0, r = e.count; t < r; t++) es.fromBufferAttribute(e, t), i = Math.max(i, n.distanceToSquared(es));
                        if (t)
                            for (let r = 0, a = t.length; r < a; r++) {
                                const a = t[r],
                                    o = this.morphTargetsRelative;
                                for (let t = 0, r = a.count; t < r; t++) es.fromBufferAttribute(a, t), o && (Zo.fromBufferAttribute(e, t), es.add(Zo)), i = Math.max(i, n.distanceToSquared(es))
                            }
                        this.boundingSphere.radius = Math.sqrt(i), this.boundingSphere.radius
                    }
                },
                computeFaceNormals: function() {},
                computeVertexNormals: function() {
                    const e = this.index,
                        t = this.getAttribute("position");
                    if (void 0 !== t) {
                        let n = this.getAttribute("normal");
                        if (void 0 === n) n = new BufferAttribute(new Float32Array(3 * t.count), 3), this.setAttribute("normal", n);
                        else
                            for (let e = 0, t = n.count; e < t; e++) n.setXYZ(e, 0, 0, 0);
                        const i = new Vector3,
                            r = new Vector3,
                            a = new Vector3,
                            o = new Vector3,
                            s = new Vector3,
                            l = new Vector3,
                            c = new Vector3,
                            u = new Vector3;
                        if (e)
                            for (let h = 0, d = e.count; h < d; h += 3) {
                                const d = e.getX(h + 0),
                                    p = e.getX(h + 1),
                                    f = e.getX(h + 2);
                                i.fromBufferAttribute(t, d), r.fromBufferAttribute(t, p), a.fromBufferAttribute(t, f), c.subVectors(a, r), u.subVectors(i, r), c.cross(u), o.fromBufferAttribute(n, d), s.fromBufferAttribute(n, p), l.fromBufferAttribute(n, f), o.add(c), s.add(c), l.add(c), n.setXYZ(d, o.x, o.y, o.z), n.setXYZ(p, s.x, s.y, s.z), n.setXYZ(f, l.x, l.y, l.z)
                            } else
                                for (let e = 0, o = t.count; e < o; e += 3) i.fromBufferAttribute(t, e + 0), r.fromBufferAttribute(t, e + 1), a.fromBufferAttribute(t, e + 2), c.subVectors(a, r), u.subVectors(i, r), c.cross(u), n.setXYZ(e + 0, c.x, c.y, c.z), n.setXYZ(e + 1, c.x, c.y, c.z), n.setXYZ(e + 2, c.x, c.y, c.z);
                        this.normalizeNormals(), n.needsUpdate = !0
                    }
                },
                merge: function(e, t) {
                    if (!e || !e.isBufferGeometry) return;
                    void 0 === t && (t = 0);
                    const n = this.attributes;
                    for (const i in n) {
                        if (void 0 === e.attributes[i]) continue;
                        const r = n[i].array,
                            a = e.attributes[i],
                            o = a.array,
                            s = a.itemSize * t,
                            l = Math.min(o.length, r.length - s);
                        for (let e = 0, t = s; e < l; e++, t++) r[t] = o[e]
                    }
                    return this
                },
                normalizeNormals: function() {
                    const e = this.attributes.normal;
                    for (let t = 0, n = e.count; t < n; t++) es.fromBufferAttribute(e, t), es.normalize(), e.setXYZ(t, es.x, es.y, es.z)
                },
                toNonIndexed: function() {
                    function convertBufferAttribute(e, t) {
                        const n = e.array,
                            i = e.itemSize,
                            r = e.normalized,
                            a = new n.constructor(t.length * i);
                        let o = 0,
                            s = 0;
                        for (let e = 0, r = t.length; e < r; e++) {
                            o = t[e] * i;
                            for (let e = 0; e < i; e++) a[s++] = n[o++]
                        }
                        return new BufferAttribute(a, i, r)
                    }
                    if (null === this.index) return this;
                    const e = new BufferGeometry,
                        t = this.index.array,
                        n = this.attributes;
                    for (const i in n) {
                        const r = convertBufferAttribute(n[i], t);
                        e.setAttribute(i, r)
                    }
                    const i = this.morphAttributes;
                    for (const n in i) {
                        const r = [],
                            a = i[n];
                        for (let e = 0, n = a.length; e < n; e++) {
                            const n = convertBufferAttribute(a[e], t);
                            r.push(n)
                        }
                        e.morphAttributes[n] = r
                    }
                    e.morphTargetsRelative = this.morphTargetsRelative;
                    const r = this.groups;
                    for (let t = 0, n = r.length; t < n; t++) {
                        const n = r[t];
                        e.addGroup(n.start, n.count, n.materialIndex)
                    }
                    return e
                },
                toJSON: function() {
                    const e = {
                        metadata: {
                            version: 4.5,
                            type: "BufferGeometry",
                            generator: "BufferGeometry.toJSON"
                        }
                    };
                    if (e.uuid = this.uuid, e.type = this.type, "" !== this.name && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), void 0 !== this.parameters) {
                        const t = this.parameters;
                        for (const n in t) void 0 !== t[n] && (e[n] = t[n]);
                        return e
                    }
                    e.data = {
                        attributes: {}
                    };
                    const t = this.index;
                    null !== t && (e.data.index = {
                        type: t.array.constructor.name,
                        array: Array.prototype.slice.call(t.array)
                    });
                    const n = this.attributes;
                    for (const t in n) {
                        const i = n[t],
                            r = i.toJSON(e.data);
                        "" !== i.name && (r.name = i.name), e.data.attributes[t] = r
                    }
                    const i = {};
                    let r = !1;
                    for (const t in this.morphAttributes) {
                        const n = this.morphAttributes[t],
                            a = [];
                        for (let t = 0, i = n.length; t < i; t++) {
                            const i = n[t],
                                r = i.toJSON(e.data);
                            "" !== i.name && (r.name = i.name), a.push(r)
                        }
                        a.length > 0 && (i[t] = a, r = !0)
                    }
                    r && (e.data.morphAttributes = i, e.data.morphTargetsRelative = this.morphTargetsRelative);
                    const a = this.groups;
                    a.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(a)));
                    const o = this.boundingSphere;
                    return null !== o && (e.data.boundingSphere = {
                        center: o.center.toArray(),
                        radius: o.radius
                    }), e
                },
                clone: function() {
                    return (new BufferGeometry).copy(this)
                },
                copy: function(e) {
                    this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
                    const t = {};
                    this.name = e.name;
                    const n = e.index;
                    null !== n && this.setIndex(n.clone(t));
                    const i = e.attributes;
                    for (const e in i) {
                        const n = i[e];
                        this.setAttribute(e, n.clone(t))
                    }
                    const r = e.morphAttributes;
                    for (const e in r) {
                        const n = [],
                            i = r[e];
                        for (let e = 0, r = i.length; e < r; e++) n.push(i[e].clone(t));
                        this.morphAttributes[e] = n
                    }
                    this.morphTargetsRelative = e.morphTargetsRelative;
                    const a = e.groups;
                    for (let e = 0, t = a.length; e < t; e++) {
                        const t = a[e];
                        this.addGroup(t.start, t.count, t.materialIndex)
                    }
                    const o = e.boundingBox;
                    null !== o && (this.boundingBox = o.clone());
                    const s = e.boundingSphere;
                    return null !== s && (this.boundingSphere = s.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, this
                },
                dispose: function() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            });
            const ts = new Matrix4,
                ns = new Ray,
                is = new Sphere,
                rs = new Vector3,
                as = new Vector3,
                os = new Vector3,
                ss = new Vector3,
                ls = new Vector3,
                cs = new Vector3,
                us = new Vector3,
                hs = new Vector3,
                ds = new Vector3,
                ps = new Vector2,
                fs = new Vector2,
                ms = new Vector2,
                gs = new Vector3,
                vs = new Vector3;
            Mesh.prototype = Object.assign(Object.create(Object3D.prototype), {
                constructor: Mesh,
                isMesh: !0,
                copy: function(e) {
                    return Object3D.prototype.copy.call(this, e), void 0 !== e.morphTargetInfluences && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), void 0 !== e.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this.material = e.material, this.geometry = e.geometry, this
                },
                updateMorphTargets: function() {
                    const e = this.geometry;
                    if (e.isBufferGeometry) {
                        const t = e.morphAttributes,
                            n = Object.keys(t);
                        if (n.length > 0) {
                            const e = t[n[0]];
                            if (void 0 !== e) {
                                this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                                for (let t = 0, n = e.length; t < n; t++) {
                                    const n = e[t].name || t + "";
                                    this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = t
                                }
                            }
                        }
                    } else {
                        const t = e.morphTargets;
                        void 0 !== t && t.length
                    }
                },
                raycast: function(e, t) {
                    const n = this.geometry,
                        i = this.material,
                        r = this.matrixWorld;
                    if (void 0 === i) return;
                    if (null === n.boundingSphere && n.computeBoundingSphere(), is.copy(n.boundingSphere), is.applyMatrix4(r), !1 === e.ray.intersectsSphere(is)) return;
                    if (ts.copy(r).invert(), ns.copy(e.ray).applyMatrix4(ts), null !== n.boundingBox && !1 === ns.intersectsBox(n.boundingBox)) return;
                    let a;
                    if (n.isBufferGeometry) {
                        const r = n.index,
                            o = n.attributes.position,
                            s = n.morphAttributes.position,
                            l = n.morphTargetsRelative,
                            c = n.attributes.uv,
                            u = n.attributes.uv2,
                            h = n.groups,
                            d = n.drawRange;
                        if (null !== r)
                            if (Array.isArray(i))
                                for (let n = 0, p = h.length; n < p; n++) {
                                    const p = h[n],
                                        f = i[p.materialIndex];
                                    for (let n = Math.max(p.start, d.start), i = Math.min(p.start + p.count, d.start + d.count); n < i; n += 3) {
                                        const i = r.getX(n),
                                            h = r.getX(n + 1),
                                            d = r.getX(n + 2);
                                        a = checkBufferGeometryIntersection(this, f, e, ns, o, s, l, c, u, i, h, d), a && (a.faceIndex = Math.floor(n / 3), a.face.materialIndex = p.materialIndex, t.push(a))
                                    }
                                } else {
                                    for (let n = Math.max(0, d.start), h = Math.min(r.count, d.start + d.count); n < h; n += 3) {
                                        const h = r.getX(n),
                                            d = r.getX(n + 1),
                                            p = r.getX(n + 2);
                                        a = checkBufferGeometryIntersection(this, i, e, ns, o, s, l, c, u, h, d, p), a && (a.faceIndex = Math.floor(n / 3), t.push(a))
                                    }
                                } else if (void 0 !== o)
                                    if (Array.isArray(i))
                                        for (let n = 0, r = h.length; n < r; n++) {
                                            const r = h[n],
                                                p = i[r.materialIndex];
                                            for (let n = Math.max(r.start, d.start), i = Math.min(r.start + r.count, d.start + d.count); n < i; n += 3) {
                                                a = checkBufferGeometryIntersection(this, p, e, ns, o, s, l, c, u, n, n + 1, n + 2), a && (a.faceIndex = Math.floor(n / 3), a.face.materialIndex = r.materialIndex, t.push(a))
                                            }
                                        } else {
                                            for (let n = Math.max(0, d.start), r = Math.min(o.count, d.start + d.count); n < r; n += 3) {
                                                a = checkBufferGeometryIntersection(this, i, e, ns, o, s, l, c, u, n, n + 1, n + 2), a && (a.faceIndex = Math.floor(n / 3), t.push(a))
                                            }
                                        }
                    } else if (n.isGeometry) {
                        const r = Array.isArray(i),
                            o = n.vertices,
                            s = n.faces;
                        let l;
                        const c = n.faceVertexUvs[0];
                        c.length > 0 && (l = c);
                        for (let n = 0, c = s.length; n < c; n++) {
                            const c = s[n],
                                u = r ? i[c.materialIndex] : i;
                            if (void 0 === u) continue;
                            const h = o[c.a],
                                d = o[c.b],
                                p = o[c.c];
                            if (a = checkIntersection(this, u, e, ns, h, d, p, gs), a) {
                                if (l && l[n]) {
                                    const e = l[n];
                                    ps.copy(e[0]), fs.copy(e[1]), ms.copy(e[2]), a.uv = Triangle.getUV(gs, h, d, p, ps, fs, ms, new Vector2)
                                }
                                a.face = c, a.faceIndex = n, t.push(a)
                            }
                        }
                    }
                }
            });
            class BoxBufferGeometry extends BufferGeometry {
                constructor(e = 1, t = 1, n = 1, i = 1, r = 1, a = 1) {
                    function buildPlane(e, t, n, i, r, a, p, f, m, g, y) {
                        const x = a / m,
                            _ = p / g,
                            b = a / 2,
                            M = p / 2,
                            S = f / 2,
                            A = m + 1,
                            w = g + 1;
                        let T = 0,
                            L = 0;
                        const C = new Vector3;
                        for (let a = 0; a < w; a++) {
                            const o = a * _ - M;
                            for (let s = 0; s < A; s++) {
                                const h = s * x - b;
                                C[e] = h * i, C[t] = o * r, C[n] = S, l.push(C.x, C.y, C.z), C[e] = 0, C[t] = 0, C[n] = f > 0 ? 1 : -1, c.push(C.x, C.y, C.z), u.push(s / m), u.push(1 - a / g), T += 1
                            }
                        }
                        for (let e = 0; e < g; e++)
                            for (let t = 0; t < m; t++) {
                                const n = h + t + A * e,
                                    i = h + t + A * (e + 1),
                                    r = h + (t + 1) + A * (e + 1),
                                    a = h + (t + 1) + A * e;
                                s.push(n, i, a), s.push(i, r, a), L += 6
                            }
                        o.addGroup(d, L, y), d += L, h += T
                    }
                    super(), this.type = "BoxBufferGeometry", this.parameters = {
                        width: e,
                        height: t,
                        depth: n,
                        widthSegments: i,
                        heightSegments: r,
                        depthSegments: a
                    };
                    const o = this;
                    i = Math.floor(i), r = Math.floor(r);
                    const s = [],
                        l = [],
                        c = [],
                        u = [];
                    let h = 0,
                        d = 0;
                    buildPlane("z", "y", "x", -1, -1, n, t, e, a = Math.floor(a), r, 0), buildPlane("z", "y", "x", 1, -1, n, t, -e, a, r, 1), buildPlane("x", "z", "y", 1, 1, e, n, t, i, a, 2), buildPlane("x", "z", "y", 1, -1, e, n, -t, i, a, 3), buildPlane("x", "y", "z", 1, -1, e, t, n, i, r, 4), buildPlane("x", "y", "z", -1, -1, e, t, -n, i, r, 5), this.setIndex(s), this.setAttribute("position", new Float32BufferAttribute(l, 3)), this.setAttribute("normal", new Float32BufferAttribute(c, 3)), this.setAttribute("uv", new Float32BufferAttribute(u, 2))
                }
            }
            const ys = {
                clone: cloneUniforms,
                merge: mergeUniforms
            };
            n = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", i = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", ShaderMaterial.prototype = Object.create(Material.prototype), ShaderMaterial.prototype.constructor = ShaderMaterial, ShaderMaterial.prototype.isShaderMaterial = !0, ShaderMaterial.prototype.copy = function(e) {
                return Material.prototype.copy.call(this, e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = cloneUniforms(e.uniforms), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.lights = e.lights, this.clipping = e.clipping, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this.extensions = Object.assign({}, e.extensions), this.glslVersion = e.glslVersion, this
            }, ShaderMaterial.prototype.toJSON = function(e) {
                const t = Material.prototype.toJSON.call(this, e);
                t.glslVersion = this.glslVersion, t.uniforms = {};
                for (const n in this.uniforms) {
                    const i = this.uniforms[n].value;
                    i && i.isTexture ? t.uniforms[n] = {
                        type: "t",
                        value: i.toJSON(e).uuid
                    } : i && i.isColor ? t.uniforms[n] = {
                        type: "c",
                        value: i.getHex()
                    } : i && i.isVector2 ? t.uniforms[n] = {
                        type: "v2",
                        value: i.toArray()
                    } : i && i.isVector3 ? t.uniforms[n] = {
                        type: "v3",
                        value: i.toArray()
                    } : i && i.isVector4 ? t.uniforms[n] = {
                        type: "v4",
                        value: i.toArray()
                    } : i && i.isMatrix3 ? t.uniforms[n] = {
                        type: "m3",
                        value: i.toArray()
                    } : i && i.isMatrix4 ? t.uniforms[n] = {
                        type: "m4",
                        value: i.toArray()
                    } : t.uniforms[n] = {
                        value: i
                    }
                }
                Object.keys(this.defines).length > 0 && (t.defines = this.defines), t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader;
                const n = {};
                for (const e in this.extensions) !0 === this.extensions[e] && (n[e] = !0);
                return Object.keys(n).length > 0 && (t.extensions = n), t
            }, Camera.prototype = Object.assign(Object.create(Object3D.prototype), {
                constructor: Camera,
                isCamera: !0,
                copy: function(e, t) {
                    return Object3D.prototype.copy.call(this, e, t), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this
                },
                getWorldDirection: function(e) {
                    void 0 === e && (e = new Vector3), this.updateWorldMatrix(!0, !1);
                    const t = this.matrixWorld.elements;
                    return e.set(-t[8], -t[9], -t[10]).normalize()
                },
                updateMatrixWorld: function(e) {
                    Object3D.prototype.updateMatrixWorld.call(this, e), this.matrixWorldInverse.copy(this.matrixWorld).invert()
                },
                updateWorldMatrix: function(e, t) {
                    Object3D.prototype.updateWorldMatrix.call(this, e, t), this.matrixWorldInverse.copy(this.matrixWorld).invert()
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                }
            }), PerspectiveCamera.prototype = Object.assign(Object.create(Camera.prototype), {
                constructor: PerspectiveCamera,
                isPerspectiveCamera: !0,
                copy: function(e, t) {
                    return Camera.prototype.copy.call(this, e, t), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = null === e.view ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this
                },
                setFocalLength: function(e) {
                    const t = .5 * this.getFilmHeight() / e;
                    this.fov = 2 * Fa.RAD2DEG * Math.atan(t), this.updateProjectionMatrix()
                },
                getFocalLength: function() {
                    const e = Math.tan(.5 * Fa.DEG2RAD * this.fov);
                    return .5 * this.getFilmHeight() / e
                },
                getEffectiveFOV: function() {
                    return 2 * Fa.RAD2DEG * Math.atan(Math.tan(.5 * Fa.DEG2RAD * this.fov) / this.zoom)
                },
                getFilmWidth: function() {
                    return this.filmGauge * Math.min(this.aspect, 1)
                },
                getFilmHeight: function() {
                    return this.filmGauge / Math.max(this.aspect, 1)
                },
                setViewOffset: function(e, t, n, i, r, a) {
                    this.aspect = e / t, null === this.view && (this.view = {
                        enabled: !0,
                        fullWidth: 1,
                        fullHeight: 1,
                        offsetX: 0,
                        offsetY: 0,
                        width: 1,
                        height: 1
                    }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = i, this.view.width = r, this.view.height = a, this.updateProjectionMatrix()
                },
                clearViewOffset: function() {
                    null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
                },
                updateProjectionMatrix: function() {
                    const e = this.near;
                    let t = e * Math.tan(.5 * Fa.DEG2RAD * this.fov) / this.zoom,
                        n = 2 * t,
                        i = this.aspect * n,
                        r = -.5 * i;
                    const a = this.view;
                    if (null !== this.view && this.view.enabled) {
                        const e = a.fullWidth,
                            o = a.fullHeight;
                        r += a.offsetX * i / e, t -= a.offsetY * n / o, i *= a.width / e, n *= a.height / o
                    }
                    const o = this.filmOffset;
                    0 !== o && (r += e * o / this.getFilmWidth()), this.projectionMatrix.makePerspective(r, r + i, t, t - n, e, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
                },
                toJSON: function(e) {
                    const t = Object3D.prototype.toJSON.call(this, e);
                    return t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, null !== this.view && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t
                }
            });
            const xs = 90;
            CubeCamera.prototype = Object.create(Object3D.prototype), CubeCamera.prototype.constructor = CubeCamera, CubeTexture.prototype = Object.create(Texture.prototype), CubeTexture.prototype.constructor = CubeTexture, CubeTexture.prototype.isCubeTexture = !0, Object.defineProperty(CubeTexture.prototype, "images", {
                get: function() {
                    return this.image
                },
                set: function(e) {
                    this.image = e
                }
            }), WebGLCubeRenderTarget.prototype = Object.create(WebGLRenderTarget.prototype), WebGLCubeRenderTarget.prototype.constructor = WebGLCubeRenderTarget, WebGLCubeRenderTarget.prototype.isWebGLCubeRenderTarget = !0, WebGLCubeRenderTarget.prototype.fromEquirectangularTexture = function(e, t) {
                this.texture.type = t.type, this.texture.format = Oi, this.texture.encoding = t.encoding, this.texture.generateMipmaps = t.generateMipmaps, this.texture.minFilter = t.minFilter, this.texture.magFilter = t.magFilter;
                const n = {
                        uniforms: {
                            tEquirect: {
                                value: null
                            }
                        },
                        vertexShader: "\n\n\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t#include <begin_vertex>\n\t\t\t\t#include <project_vertex>\n\n\t\t\t}\n\t\t",
                        fragmentShader: "\n\n\t\t\tuniform sampler2D tEquirect;\n\n\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t}\n\t\t"
                    },
                    i = new BoxBufferGeometry(5, 5, 5),
                    r = new ShaderMaterial({
                        name: "CubemapFromEquirect",
                        uniforms: cloneUniforms(n.uniforms),
                        vertexShader: n.vertexShader,
                        fragmentShader: n.fragmentShader,
                        side: un,
                        blending: fn
                    });
                r.uniforms.tEquirect.value = t;
                const a = new Mesh(i, r),
                    o = t.minFilter;
                t.minFilter === vi && (t.minFilter = fi);
                return new CubeCamera(1, 10, this).update(e, a), t.minFilter = o, a.geometry.dispose(), a.material.dispose(), this
            }, WebGLCubeRenderTarget.prototype.clear = function(e, t, n, i) {
                const r = e.getRenderTarget();
                for (let r = 0; r < 6; r++) e.setRenderTarget(this, r), e.clear(t, n, i);
                e.setRenderTarget(r)
            }, DataTexture.prototype = Object.create(Texture.prototype), DataTexture.prototype.constructor = DataTexture, DataTexture.prototype.isDataTexture = !0;
            const _s = new Sphere,
                bs = new Vector3;
            class Frustum {
                constructor(e, t, n, i, r, a) {
                    this.planes = [void 0 !== e ? e : new Plane, void 0 !== t ? t : new Plane, void 0 !== n ? n : new Plane, void 0 !== i ? i : new Plane, void 0 !== r ? r : new Plane, void 0 !== a ? a : new Plane]
                }
                set(e, t, n, i, r, a) {
                    const o = this.planes;
                    return o[0].copy(e), o[1].copy(t), o[2].copy(n), o[3].copy(i), o[4].copy(r), o[5].copy(a), this
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                copy(e) {
                    const t = this.planes;
                    for (let n = 0; n < 6; n++) t[n].copy(e.planes[n]);
                    return this
                }
                setFromProjectionMatrix(e) {
                    const t = this.planes,
                        n = e.elements,
                        i = n[0],
                        r = n[1],
                        a = n[2],
                        o = n[3],
                        s = n[4],
                        l = n[5],
                        c = n[6],
                        u = n[7],
                        h = n[8],
                        d = n[9],
                        p = n[10],
                        f = n[11],
                        m = n[12],
                        g = n[13],
                        y = n[14],
                        x = n[15];
                    return t[0].setComponents(o - i, u - s, f - h, x - m).normalize(), t[1].setComponents(o + i, u + s, f + h, x + m).normalize(), t[2].setComponents(o + r, u + l, f + d, x + g).normalize(), t[3].setComponents(o - r, u - l, f - d, x - g).normalize(), t[4].setComponents(o - a, u - c, f - p, x - y).normalize(), t[5].setComponents(o + a, u + c, f + p, x + y).normalize(), this
                }
                intersectsObject(e) {
                    const t = e.geometry;
                    return null === t.boundingSphere && t.computeBoundingSphere(), _s.copy(t.boundingSphere).applyMatrix4(e.matrixWorld), this.intersectsSphere(_s)
                }
                intersectsSprite(e) {
                    return _s.center.set(0, 0, 0), _s.radius = .7071067811865476, _s.applyMatrix4(e.matrixWorld), this.intersectsSphere(_s)
                }
                intersectsSphere(e) {
                    const t = this.planes,
                        n = e.center,
                        i = -e.radius;
                    for (let e = 0; e < 6; e++) {
                        if (t[e].distanceToPoint(n) < i) return !1
                    }
                    return !0
                }
                intersectsBox(e) {
                    const t = this.planes;
                    for (let n = 0; n < 6; n++) {
                        const i = t[n];
                        if (bs.x = i.normal.x > 0 ? e.max.x : e.min.x, bs.y = i.normal.y > 0 ? e.max.y : e.min.y, bs.z = i.normal.z > 0 ? e.max.z : e.min.z, i.distanceToPoint(bs) < 0) return !1
                    }
                    return !0
                }
                containsPoint(e) {
                    const t = this.planes;
                    for (let n = 0; n < 6; n++)
                        if (t[n].distanceToPoint(e) < 0) return !1;
                    return !0
                }
            }
            class PlaneBufferGeometry extends BufferGeometry {
                constructor(e = 1, t = 1, n = 1, i = 1) {
                    super(), this.type = "PlaneBufferGeometry", this.parameters = {
                        width: e,
                        height: t,
                        widthSegments: n,
                        heightSegments: i
                    };
                    const r = e / 2,
                        a = t / 2,
                        o = Math.floor(n),
                        s = Math.floor(i),
                        l = o + 1,
                        c = s + 1,
                        u = e / o,
                        h = t / s,
                        d = [],
                        p = [],
                        f = [],
                        m = [];
                    for (let e = 0; e < c; e++) {
                        const t = e * h - a;
                        for (let n = 0; n < l; n++) {
                            const i = n * u - r;
                            p.push(i, -t, 0), f.push(0, 0, 1), m.push(n / o), m.push(1 - e / s)
                        }
                    }
                    for (let e = 0; e < s; e++)
                        for (let t = 0; t < o; t++) {
                            const n = t + l * e,
                                i = t + l * (e + 1),
                                r = t + 1 + l * (e + 1),
                                a = t + 1 + l * e;
                            d.push(n, i, a), d.push(i, r, a)
                        }
                    this.setIndex(d), this.setAttribute("position", new Float32BufferAttribute(p, 3)), this.setAttribute("normal", new Float32BufferAttribute(f, 3)), this.setAttribute("uv", new Float32BufferAttribute(m, 2))
                }
            }
            const Ms = {
                    alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",
                    alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
                    alphatest_fragment: "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif",
                    aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif",
                    aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
                    begin_vertex: "vec3 transformed = vec3( position );",
                    beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
                    bsdfs: "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif",
                    bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
                    clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
                    clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
                    clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",
                    clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",
                    color_fragment: "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif",
                    color_pars_fragment: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
                    color_pars_vertex: "#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",
                    color_vertex: "#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor.xyz *= color.xyz;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",
                    common: "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}",
                    cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_maxMipLevel 8.0\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_maxTileSize 256.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n\t\tvec2 f = fract( uv );\n\t\tuv += 0.5 - f;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tif ( mipInt < cubeUV_maxMipLevel ) {\n\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t}\n\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\t\tuv *= texelSize;\n\t\tvec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x += texelSize;\n\t\tvec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.y += texelSize;\n\t\tvec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x -= texelSize;\n\t\tvec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tvec3 tm = mix( tl, tr, f.x );\n\t\tvec3 bm = mix( bl, br, f.x );\n\t\treturn mix( tm, bm, f.y );\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",
                    defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
                    displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
                    displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",
                    emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
                    emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
                    encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
                    encodings_pars_fragment: "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}",
                    envmap_fragment: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
                    envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
                    envmap_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
                    envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
                    envmap_physical_pars_fragment: "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif",
                    envmap_vertex: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
                    fog_vertex: "#ifdef USE_FOG\n\tfogDepth = - mvPosition.z;\n#endif",
                    fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif",
                    fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
                    fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
                    gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}",
                    lightmap_fragment: "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif",
                    lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
                    lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif",
                    lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif",
                    lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",
                    lights_toon_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)",
                    lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
                    lights_phong_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",
                    lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif",
                    lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat specularRoughness;\n\tvec3 specularColor;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
                    lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
                    lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif",
                    lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",
                    logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
                    logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
                    logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
                    logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",
                    map_fragment: "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif",
                    map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
                    map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
                    map_particle_pars_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
                    metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
                    metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
                    morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif",
                    morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\t\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\t\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",
                    morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif",
                    normal_fragment_begin: "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\tbitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;",
                    normal_fragment_maps: "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif",
                    normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\tvec3 N = normalize( surf_norm );\n\t\tmat3 tsn = mat3( S, T, N );\n\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif",
                    clearcoat_normal_fragment_begin: "#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",
                    clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN );\n\t#endif\n#endif",
                    clearcoat_pars_fragment: "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif",
                    packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",
                    premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
                    project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
                    dithering_fragment: "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
                    dithering_pars_fragment: "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
                    roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
                    roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
                    shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
                    shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
                    shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif",
                    shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",
                    skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
                    skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif",
                    skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
                    skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
                    specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
                    specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
                    tonemapping_fragment: "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
                    tonemapping_pars_fragment: "#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",
                    transmissionmap_fragment: "#ifdef USE_TRANSMISSIONMAP\n\ttotalTransmission *= texture2D( transmissionMap, vUv ).r;\n#endif",
                    transmissionmap_pars_fragment: "#ifdef USE_TRANSMISSIONMAP\n\tuniform sampler2D transmissionMap;\n#endif",
                    uv_pars_fragment: "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif",
                    uv_pars_vertex: "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif",
                    uv_vertex: "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
                    uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
                    uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif",
                    uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif",
                    worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
                    background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
                    background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
                    cube_frag: "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
                    cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
                    depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",
                    depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",
                    distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
                    distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
                    equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
                    equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
                    linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
                    linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
                    meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                    meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
                    meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                    meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                    meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                    meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
                    meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                    meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                    meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                    meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                    meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define TRANSMISSION\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSMISSION\n\tuniform float transmission;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <transmissionmap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#ifdef TRANSMISSION\n\t\tfloat totalTransmission = transmission;\n\t#endif\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <transmissionmap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#ifdef TRANSMISSION\n\t\tdiffuseColor.a *= mix( saturate( 1. - totalTransmission + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) ), 1.0, metalness );\n\t#endif\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                    meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                    normal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}",
                    normal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
                    points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
                    points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
                    shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
                    shadow_vert: "#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                    sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
                    sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}"
                },
                Ss = {
                    common: {
                        diffuse: {
                            value: new Color(15658734)
                        },
                        opacity: {
                            value: 1
                        },
                        map: {
                            value: null
                        },
                        uvTransform: {
                            value: new Matrix3
                        },
                        uv2Transform: {
                            value: new Matrix3
                        },
                        alphaMap: {
                            value: null
                        }
                    },
                    specularmap: {
                        specularMap: {
                            value: null
                        }
                    },
                    envmap: {
                        envMap: {
                            value: null
                        },
                        flipEnvMap: {
                            value: -1
                        },
                        reflectivity: {
                            value: 1
                        },
                        refractionRatio: {
                            value: .98
                        },
                        maxMipLevel: {
                            value: 0
                        }
                    },
                    aomap: {
                        aoMap: {
                            value: null
                        },
                        aoMapIntensity: {
                            value: 1
                        }
                    },
                    lightmap: {
                        lightMap: {
                            value: null
                        },
                        lightMapIntensity: {
                            value: 1
                        }
                    },
                    emissivemap: {
                        emissiveMap: {
                            value: null
                        }
                    },
                    bumpmap: {
                        bumpMap: {
                            value: null
                        },
                        bumpScale: {
                            value: 1
                        }
                    },
                    normalmap: {
                        normalMap: {
                            value: null
                        },
                        normalScale: {
                            value: new Vector2(1, 1)
                        }
                    },
                    displacementmap: {
                        displacementMap: {
                            value: null
                        },
                        displacementScale: {
                            value: 1
                        },
                        displacementBias: {
                            value: 0
                        }
                    },
                    roughnessmap: {
                        roughnessMap: {
                            value: null
                        }
                    },
                    metalnessmap: {
                        metalnessMap: {
                            value: null
                        }
                    },
                    gradientmap: {
                        gradientMap: {
                            value: null
                        }
                    },
                    fog: {
                        fogDensity: {
                            value: 25e-5
                        },
                        fogNear: {
                            value: 1
                        },
                        fogFar: {
                            value: 2e3
                        },
                        fogColor: {
                            value: new Color(16777215)
                        }
                    },
                    lights: {
                        ambientLightColor: {
                            value: []
                        },
                        lightProbe: {
                            value: []
                        },
                        directionalLights: {
                            value: [],
                            properties: {
                                direction: {},
                                color: {}
                            }
                        },
                        directionalLightShadows: {
                            value: [],
                            properties: {
                                shadowBias: {},
                                shadowNormalBias: {},
                                shadowRadius: {},
                                shadowMapSize: {}
                            }
                        },
                        directionalShadowMap: {
                            value: []
                        },
                        directionalShadowMatrix: {
                            value: []
                        },
                        spotLights: {
                            value: [],
                            properties: {
                                color: {},
                                position: {},
                                direction: {},
                                distance: {},
                                coneCos: {},
                                penumbraCos: {},
                                decay: {}
                            }
                        },
                        spotLightShadows: {
                            value: [],
                            properties: {
                                shadowBias: {},
                                shadowNormalBias: {},
                                shadowRadius: {},
                                shadowMapSize: {}
                            }
                        },
                        spotShadowMap: {
                            value: []
                        },
                        spotShadowMatrix: {
                            value: []
                        },
                        pointLights: {
                            value: [],
                            properties: {
                                color: {},
                                position: {},
                                decay: {},
                                distance: {}
                            }
                        },
                        pointLightShadows: {
                            value: [],
                            properties: {
                                shadowBias: {},
                                shadowNormalBias: {},
                                shadowRadius: {},
                                shadowMapSize: {},
                                shadowCameraNear: {},
                                shadowCameraFar: {}
                            }
                        },
                        pointShadowMap: {
                            value: []
                        },
                        pointShadowMatrix: {
                            value: []
                        },
                        hemisphereLights: {
                            value: [],
                            properties: {
                                direction: {},
                                skyColor: {},
                                groundColor: {}
                            }
                        },
                        rectAreaLights: {
                            value: [],
                            properties: {
                                color: {},
                                position: {},
                                width: {},
                                height: {}
                            }
                        },
                        ltc_1: {
                            value: null
                        },
                        ltc_2: {
                            value: null
                        }
                    },
                    points: {
                        diffuse: {
                            value: new Color(15658734)
                        },
                        opacity: {
                            value: 1
                        },
                        size: {
                            value: 1
                        },
                        scale: {
                            value: 1
                        },
                        map: {
                            value: null
                        },
                        alphaMap: {
                            value: null
                        },
                        uvTransform: {
                            value: new Matrix3
                        }
                    },
                    sprite: {
                        diffuse: {
                            value: new Color(15658734)
                        },
                        opacity: {
                            value: 1
                        },
                        center: {
                            value: new Vector2(.5, .5)
                        },
                        rotation: {
                            value: 0
                        },
                        map: {
                            value: null
                        },
                        alphaMap: {
                            value: null
                        },
                        uvTransform: {
                            value: new Matrix3
                        }
                    }
                },
                As = {
                    basic: {
                        uniforms: mergeUniforms([Ss.common, Ss.specularmap, Ss.envmap, Ss.aomap, Ss.lightmap, Ss.fog]),
                        vertexShader: Ms.meshbasic_vert,
                        fragmentShader: Ms.meshbasic_frag
                    },
                    lambert: {
                        uniforms: mergeUniforms([Ss.common, Ss.specularmap, Ss.envmap, Ss.aomap, Ss.lightmap, Ss.emissivemap, Ss.fog, Ss.lights, {
                            emissive: {
                                value: new Color(0)
                            }
                        }]),
                        vertexShader: Ms.meshlambert_vert,
                        fragmentShader: Ms.meshlambert_frag
                    },
                    phong: {
                        uniforms: mergeUniforms([Ss.common, Ss.specularmap, Ss.envmap, Ss.aomap, Ss.lightmap, Ss.emissivemap, Ss.bumpmap, Ss.normalmap, Ss.displacementmap, Ss.fog, Ss.lights, {
                            emissive: {
                                value: new Color(0)
                            },
                            specular: {
                                value: new Color(1118481)
                            },
                            shininess: {
                                value: 30
                            }
                        }]),
                        vertexShader: Ms.meshphong_vert,
                        fragmentShader: Ms.meshphong_frag
                    },
                    standard: {
                        uniforms: mergeUniforms([Ss.common, Ss.envmap, Ss.aomap, Ss.lightmap, Ss.emissivemap, Ss.bumpmap, Ss.normalmap, Ss.displacementmap, Ss.roughnessmap, Ss.metalnessmap, Ss.fog, Ss.lights, {
                            emissive: {
                                value: new Color(0)
                            },
                            roughness: {
                                value: 1
                            },
                            metalness: {
                                value: 0
                            },
                            envMapIntensity: {
                                value: 1
                            }
                        }]),
                        vertexShader: Ms.meshphysical_vert,
                        fragmentShader: Ms.meshphysical_frag
                    },
                    toon: {
                        uniforms: mergeUniforms([Ss.common, Ss.aomap, Ss.lightmap, Ss.emissivemap, Ss.bumpmap, Ss.normalmap, Ss.displacementmap, Ss.gradientmap, Ss.fog, Ss.lights, {
                            emissive: {
                                value: new Color(0)
                            }
                        }]),
                        vertexShader: Ms.meshtoon_vert,
                        fragmentShader: Ms.meshtoon_frag
                    },
                    matcap: {
                        uniforms: mergeUniforms([Ss.common, Ss.bumpmap, Ss.normalmap, Ss.displacementmap, Ss.fog, {
                            matcap: {
                                value: null
                            }
                        }]),
                        vertexShader: Ms.meshmatcap_vert,
                        fragmentShader: Ms.meshmatcap_frag
                    },
                    points: {
                        uniforms: mergeUniforms([Ss.points, Ss.fog]),
                        vertexShader: Ms.points_vert,
                        fragmentShader: Ms.points_frag
                    },
                    dashed: {
                        uniforms: mergeUniforms([Ss.common, Ss.fog, {
                            scale: {
                                value: 1
                            },
                            dashSize: {
                                value: 1
                            },
                            totalSize: {
                                value: 2
                            }
                        }]),
                        vertexShader: Ms.linedashed_vert,
                        fragmentShader: Ms.linedashed_frag
                    },
                    depth: {
                        uniforms: mergeUniforms([Ss.common, Ss.displacementmap]),
                        vertexShader: Ms.depth_vert,
                        fragmentShader: Ms.depth_frag
                    },
                    normal: {
                        uniforms: mergeUniforms([Ss.common, Ss.bumpmap, Ss.normalmap, Ss.displacementmap, {
                            opacity: {
                                value: 1
                            }
                        }]),
                        vertexShader: Ms.normal_vert,
                        fragmentShader: Ms.normal_frag
                    },
                    sprite: {
                        uniforms: mergeUniforms([Ss.sprite, Ss.fog]),
                        vertexShader: Ms.sprite_vert,
                        fragmentShader: Ms.sprite_frag
                    },
                    background: {
                        uniforms: {
                            uvTransform: {
                                value: new Matrix3
                            },
                            t2D: {
                                value: null
                            }
                        },
                        vertexShader: Ms.background_vert,
                        fragmentShader: Ms.background_frag
                    },
                    cube: {
                        uniforms: mergeUniforms([Ss.envmap, {
                            opacity: {
                                value: 1
                            }
                        }]),
                        vertexShader: Ms.cube_vert,
                        fragmentShader: Ms.cube_frag
                    },
                    equirect: {
                        uniforms: {
                            tEquirect: {
                                value: null
                            }
                        },
                        vertexShader: Ms.equirect_vert,
                        fragmentShader: Ms.equirect_frag
                    },
                    distanceRGBA: {
                        uniforms: mergeUniforms([Ss.common, Ss.displacementmap, {
                            referencePosition: {
                                value: new Vector3
                            },
                            nearDistance: {
                                value: 1
                            },
                            farDistance: {
                                value: 1e3
                            }
                        }]),
                        vertexShader: Ms.distanceRGBA_vert,
                        fragmentShader: Ms.distanceRGBA_frag
                    },
                    shadow: {
                        uniforms: mergeUniforms([Ss.lights, Ss.fog, {
                            color: {
                                value: new Color(0)
                            },
                            opacity: {
                                value: 1
                            }
                        }]),
                        vertexShader: Ms.shadow_vert,
                        fragmentShader: Ms.shadow_frag
                    }
                };
            As.physical = {
                uniforms: mergeUniforms([As.standard.uniforms, {
                    clearcoat: {
                        value: 0
                    },
                    clearcoatMap: {
                        value: null
                    },
                    clearcoatRoughness: {
                        value: 0
                    },
                    clearcoatRoughnessMap: {
                        value: null
                    },
                    clearcoatNormalScale: {
                        value: new Vector2(1, 1)
                    },
                    clearcoatNormalMap: {
                        value: null
                    },
                    sheen: {
                        value: new Color(0)
                    },
                    transmission: {
                        value: 0
                    },
                    transmissionMap: {
                        value: null
                    }
                }]),
                vertexShader: Ms.meshphysical_vert,
                fragmentShader: Ms.meshphysical_frag
            }, DataTexture2DArray.prototype = Object.create(Texture.prototype), DataTexture2DArray.prototype.constructor = DataTexture2DArray, DataTexture2DArray.prototype.isDataTexture2DArray = !0, DataTexture3D.prototype = Object.create(Texture.prototype), DataTexture3D.prototype.constructor = DataTexture3D, DataTexture3D.prototype.isDataTexture3D = !0;
            const ws = new Texture,
                Ts = new DataTexture2DArray,
                Ls = new DataTexture3D,
                Cs = new CubeTexture,
                Ps = [],
                Es = [],
                Is = new Float32Array(16),
                Fs = new Float32Array(9),
                Os = new Float32Array(4);
            PureArrayUniform.prototype.updateCache = function(e) {
                const t = this.cache;
                e instanceof Float32Array && t.length !== e.length && (this.cache = new Float32Array(e.length)), copyArray(t, e)
            }, StructuredUniform.prototype.setValue = function(e, t, n) {
                const i = this.seq;
                for (let r = 0, a = i.length; r !== a; ++r) {
                    const a = i[r];
                    a.setValue(e, t[a.id], n)
                }
            };
            const Bs = /(\w+)(\])?(\[|\.)?/g;
            WebGLUniforms.prototype.setValue = function(e, t, n, i) {
                const r = this.map[t];
                void 0 !== r && r.setValue(e, n, i)
            }, WebGLUniforms.prototype.setOptional = function(e, t, n) {
                const i = t[n];
                void 0 !== i && this.setValue(e, n, i)
            }, WebGLUniforms.upload = function(e, t, n, i) {
                for (let r = 0, a = t.length; r !== a; ++r) {
                    const a = t[r],
                        o = n[a.id];
                    !1 !== o.needsUpdate && a.setValue(e, o.value, i)
                }
            }, WebGLUniforms.seqWithValue = function(e, t) {
                const n = [];
                for (let i = 0, r = e.length; i !== r; ++i) {
                    const r = e[i];
                    r.id in t && n.push(r)
                }
                return n
            };
            let Rs = 0;
            const Ns = /^[ \t]*#include +<([\w\d./]+)>/gm,
                Ds = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
                Vs = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
            let Us = 0;
            MeshDepthMaterial.prototype = Object.create(Material.prototype), MeshDepthMaterial.prototype.constructor = MeshDepthMaterial, MeshDepthMaterial.prototype.isMeshDepthMaterial = !0, MeshDepthMaterial.prototype.copy = function(e) {
                return Material.prototype.copy.call(this, e), this.depthPacking = e.depthPacking, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this
            }, MeshDistanceMaterial.prototype = Object.create(Material.prototype), MeshDistanceMaterial.prototype.constructor = MeshDistanceMaterial, MeshDistanceMaterial.prototype.isMeshDistanceMaterial = !0, MeshDistanceMaterial.prototype.copy = function(e) {
                return Material.prototype.copy.call(this, e), this.referencePosition.copy(e.referencePosition), this.nearDistance = e.nearDistance, this.farDistance = e.farDistance, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this
            }, r = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );\n\tfor ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean * HALF_SAMPLE_RATE;\n\tsquared_mean = squared_mean * HALF_SAMPLE_RATE;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}", a = "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}", ArrayCamera.prototype = Object.assign(Object.create(PerspectiveCamera.prototype), {
                constructor: ArrayCamera,
                isArrayCamera: !0
            }), Group.prototype = Object.assign(Object.create(Object3D.prototype), {
                constructor: Group,
                isGroup: !0
            }), Object.assign(WebXRController.prototype, {
                constructor: WebXRController,
                getHandSpace: function() {
                    if (null === this._hand && (this._hand = new Group, this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = [], this._hand.inputState = {
                            pinching: !1
                        }, window.XRHand))
                        for (let e = 0; e <= window.XRHand.LITTLE_PHALANX_TIP; e++) {
                            const e = new Group;
                            e.matrixAutoUpdate = !1, e.visible = !1, this._hand.joints.push(e), this._hand.add(e)
                        }
                    return this._hand
                },
                getTargetRaySpace: function() {
                    return null === this._targetRay && (this._targetRay = new Group, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1), this._targetRay
                },
                getGripSpace: function() {
                    return null === this._grip && (this._grip = new Group, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1), this._grip
                },
                dispatchEvent: function(e) {
                    return null !== this._targetRay && this._targetRay.dispatchEvent(e), null !== this._grip && this._grip.dispatchEvent(e), null !== this._hand && this._hand.dispatchEvent(e), this
                },
                disconnect: function(e) {
                    return this.dispatchEvent({
                        type: "disconnected",
                        data: e
                    }), null !== this._targetRay && (this._targetRay.visible = !1), null !== this._grip && (this._grip.visible = !1), null !== this._hand && (this._hand.visible = !1), this
                },
                update: function(e, t, n) {
                    let i = null,
                        r = null,
                        a = null;
                    const o = this._targetRay,
                        s = this._grip,
                        l = this._hand;
                    if (e && "visible-blurred" !== t.session.visibilityState)
                        if (l && e.hand) {
                            a = !0;
                            for (let i = 0; i <= window.XRHand.LITTLE_PHALANX_TIP; i++)
                                if (e.hand[i]) {
                                    const r = t.getJointPose(e.hand[i], n),
                                        a = l.joints[i];
                                    null !== r && (a.matrix.fromArray(r.transform.matrix), a.matrix.decompose(a.position, a.rotation, a.scale), a.jointRadius = r.radius), a.visible = null !== r;
                                    const o = l.joints[window.XRHand.INDEX_PHALANX_TIP],
                                        s = l.joints[window.XRHand.THUMB_PHALANX_TIP],
                                        c = o.position.distanceTo(s.position),
                                        u = .02,
                                        h = .005;
                                    l.inputState.pinching && c > u + h ? (l.inputState.pinching = !1, this.dispatchEvent({
                                        type: "pinchend",
                                        handedness: e.handedness,
                                        target: this
                                    })) : !l.inputState.pinching && c <= u - h && (l.inputState.pinching = !0, this.dispatchEvent({
                                        type: "pinchstart",
                                        handedness: e.handedness,
                                        target: this
                                    }))
                                }
                        } else null !== o && (i = t.getPose(e.targetRaySpace, n), null !== i && (o.matrix.fromArray(i.transform.matrix), o.matrix.decompose(o.position, o.rotation, o.scale))), null !== s && e.gripSpace && (r = t.getPose(e.gripSpace, n), null !== r && (s.matrix.fromArray(r.transform.matrix), s.matrix.decompose(s.position, s.rotation, s.scale)));
                    return null !== o && (o.visible = null !== i), null !== s && (s.visible = null !== r), null !== l && (l.visible = null !== a), this
                }
            }), Object.assign(WebXRManager.prototype, EventDispatcher.prototype), WebGL1Renderer.prototype = Object.assign(Object.create(WebGLRenderer.prototype), {
                constructor: WebGL1Renderer,
                isWebGL1Renderer: !0
            });
            class FogExp2 {
                constructor(e, t) {
                    Object.defineProperty(this, "isFogExp2", {
                        value: !0
                    }), this.name = "", this.color = new Color(e), this.density = void 0 !== t ? t : 25e-5
                }
                clone() {
                    return new FogExp2(this.color, this.density)
                }
                toJSON() {
                    return {
                        type: "FogExp2",
                        color: this.color.getHex(),
                        density: this.density
                    }
                }
            }
            class Fog {
                constructor(e, t, n) {
                    Object.defineProperty(this, "isFog", {
                        value: !0
                    }), this.name = "", this.color = new Color(e), this.near = void 0 !== t ? t : 1, this.far = void 0 !== n ? n : 1e3
                }
                clone() {
                    return new Fog(this.color, this.near, this.far)
                }
                toJSON() {
                    return {
                        type: "Fog",
                        color: this.color.getHex(),
                        near: this.near,
                        far: this.far
                    }
                }
            }
            class Scene extends Object3D {
                constructor() {
                    super(), Object.defineProperty(this, "isScene", {
                        value: !0
                    }), this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.overrideMaterial = null, this.autoUpdate = !0, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
                        detail: this
                    }))
                }
                copy(e, t) {
                    return super.copy(e, t), null !== e.background && (this.background = e.background.clone()), null !== e.environment && (this.environment = e.environment.clone()), null !== e.fog && (this.fog = e.fog.clone()), null !== e.overrideMaterial && (this.overrideMaterial = e.overrideMaterial.clone()), this.autoUpdate = e.autoUpdate, this.matrixAutoUpdate = e.matrixAutoUpdate, this
                }
                toJSON(e) {
                    const t = super.toJSON(e);
                    return null !== this.background && (t.object.background = this.background.toJSON(e)), null !== this.environment && (t.object.environment = this.environment.toJSON(e)), null !== this.fog && (t.object.fog = this.fog.toJSON()), t
                }
            }
            Object.defineProperty(InterleavedBuffer.prototype, "needsUpdate", {
                set: function(e) {
                    !0 === e && this.version++
                }
            }), Object.assign(InterleavedBuffer.prototype, {
                isInterleavedBuffer: !0,
                onUploadCallback: function() {},
                setUsage: function(e) {
                    return this.usage = e, this
                },
                copy: function(e) {
                    return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.usage = e.usage, this
                },
                copyAt: function(e, t, n) {
                    e *= this.stride, n *= t.stride;
                    for (let i = 0, r = this.stride; i < r; i++) this.array[e + i] = t.array[n + i];
                    return this
                },
                set: function(e, t = 0) {
                    return this.array.set(e, t), this
                },
                clone: function(e) {
                    void 0 === e.arrayBuffers && (e.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = Fa.generateUUID()), void 0 === e.arrayBuffers[this.array.buffer._uuid] && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
                    const t = new InterleavedBuffer(new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]), this.stride);
                    return t.setUsage(this.usage), t
                },
                onUpload: function(e) {
                    return this.onUploadCallback = e, this
                },
                toJSON: function(e) {
                    return void 0 === e.arrayBuffers && (e.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = Fa.generateUUID()), void 0 === e.arrayBuffers[this.array.buffer._uuid] && (e.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer))), {
                        uuid: this.uuid,
                        buffer: this.array.buffer._uuid,
                        type: this.array.constructor.name,
                        stride: this.stride
                    }
                }
            });
            const zs = new Vector3;
            let Gs;
            Object.defineProperties(InterleavedBufferAttribute.prototype, {
                count: {
                    get: function() {
                        return this.data.count
                    }
                },
                array: {
                    get: function() {
                        return this.data.array
                    }
                },
                needsUpdate: {
                    set: function(e) {
                        this.data.needsUpdate = e
                    }
                }
            }), Object.assign(InterleavedBufferAttribute.prototype, {
                isInterleavedBufferAttribute: !0,
                applyMatrix4: function(e) {
                    for (let t = 0, n = this.data.count; t < n; t++) zs.x = this.getX(t), zs.y = this.getY(t), zs.z = this.getZ(t), zs.applyMatrix4(e), this.setXYZ(t, zs.x, zs.y, zs.z);
                    return this
                },
                setX: function(e, t) {
                    return this.data.array[e * this.data.stride + this.offset] = t, this
                },
                setY: function(e, t) {
                    return this.data.array[e * this.data.stride + this.offset + 1] = t, this
                },
                setZ: function(e, t) {
                    return this.data.array[e * this.data.stride + this.offset + 2] = t, this
                },
                setW: function(e, t) {
                    return this.data.array[e * this.data.stride + this.offset + 3] = t, this
                },
                getX: function(e) {
                    return this.data.array[e * this.data.stride + this.offset]
                },
                getY: function(e) {
                    return this.data.array[e * this.data.stride + this.offset + 1]
                },
                getZ: function(e) {
                    return this.data.array[e * this.data.stride + this.offset + 2]
                },
                getW: function(e) {
                    return this.data.array[e * this.data.stride + this.offset + 3]
                },
                setXY: function(e, t, n) {
                    return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = n, this
                },
                setXYZ: function(e, t, n, i) {
                    return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = i, this
                },
                setXYZW: function(e, t, n, i, r) {
                    return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = i, this.data.array[e + 3] = r, this
                },
                clone: function(e) {
                    if (void 0 === e) {
                        const e = [];
                        for (let t = 0; t < this.count; t++) {
                            const n = t * this.data.stride + this.offset;
                            for (let t = 0; t < this.itemSize; t++) e.push(this.data.array[n + t])
                        }
                        return new BufferAttribute(new this.array.constructor(e), this.itemSize, this.normalized)
                    }
                    return void 0 === e.interleavedBuffers && (e.interleavedBuffers = {}), void 0 === e.interleavedBuffers[this.data.uuid] && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)), new InterleavedBufferAttribute(e.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized)
                },
                toJSON: function(e) {
                    if (void 0 === e) {
                        const e = [];
                        for (let t = 0; t < this.count; t++) {
                            const n = t * this.data.stride + this.offset;
                            for (let t = 0; t < this.itemSize; t++) e.push(this.data.array[n + t])
                        }
                        return {
                            itemSize: this.itemSize,
                            type: this.array.constructor.name,
                            array: e,
                            normalized: this.normalized
                        }
                    }
                    return void 0 === e.interleavedBuffers && (e.interleavedBuffers = {}), void 0 === e.interleavedBuffers[this.data.uuid] && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)), {
                        isInterleavedBufferAttribute: !0,
                        itemSize: this.itemSize,
                        data: this.data.uuid,
                        offset: this.offset,
                        normalized: this.normalized
                    }
                }
            }), SpriteMaterial.prototype = Object.create(Material.prototype), SpriteMaterial.prototype.constructor = SpriteMaterial, SpriteMaterial.prototype.isSpriteMaterial = !0, SpriteMaterial.prototype.copy = function(e) {
                return Material.prototype.copy.call(this, e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.rotation = e.rotation, this.sizeAttenuation = e.sizeAttenuation, this
            };
            const ks = new Vector3,
                js = new Vector3,
                Ws = new Vector3,
                Hs = new Vector2,
                Xs = new Vector2,
                Ys = new Matrix4,
                qs = new Vector3,
                Qs = new Vector3,
                Js = new Vector3,
                Zs = new Vector2,
                Ks = new Vector2,
                $s = new Vector2;
            Sprite.prototype = Object.assign(Object.create(Object3D.prototype), {
                constructor: Sprite,
                isSprite: !0,
                raycast: function(e, t) {
                    e.camera, js.setFromMatrixScale(this.matrixWorld), Ys.copy(e.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse, this.matrixWorld), Ws.setFromMatrixPosition(this.modelViewMatrix), e.camera.isPerspectiveCamera && !1 === this.material.sizeAttenuation && js.multiplyScalar(-Ws.z);
                    const n = this.material.rotation;
                    let i, r;
                    0 !== n && (r = Math.cos(n), i = Math.sin(n));
                    const a = this.center;
                    transformVertex(qs.set(-.5, -.5, 0), Ws, a, js, i, r), transformVertex(Qs.set(.5, -.5, 0), Ws, a, js, i, r), transformVertex(Js.set(.5, .5, 0), Ws, a, js, i, r), Zs.set(0, 0), Ks.set(1, 0), $s.set(1, 1);
                    let o = e.ray.intersectTriangle(qs, Qs, Js, !1, ks);
                    if (null === o && (transformVertex(Qs.set(-.5, .5, 0), Ws, a, js, i, r), Ks.set(0, 1), o = e.ray.intersectTriangle(qs, Js, Qs, !1, ks), null === o)) return;
                    const s = e.ray.origin.distanceTo(ks);
                    s < e.near || s > e.far || t.push({
                        distance: s,
                        point: ks.clone(),
                        uv: Triangle.getUV(ks, qs, Qs, Js, Zs, Ks, $s, new Vector2),
                        face: null,
                        object: this
                    })
                },
                copy: function(e) {
                    return Object3D.prototype.copy.call(this, e), void 0 !== e.center && this.center.copy(e.center), this.material = e.material, this
                }
            });
            const el = new Vector3,
                tl = new Vector3;
            LOD.prototype = Object.assign(Object.create(Object3D.prototype), {
                constructor: LOD,
                isLOD: !0,
                copy: function(e) {
                    Object3D.prototype.copy.call(this, e, !1);
                    const t = e.levels;
                    for (let e = 0, n = t.length; e < n; e++) {
                        const n = t[e];
                        this.addLevel(n.object.clone(), n.distance)
                    }
                    return this.autoUpdate = e.autoUpdate, this
                },
                addLevel: function(e, t = 0) {
                    t = Math.abs(t);
                    const n = this.levels;
                    let i;
                    for (i = 0; i < n.length && !(t < n[i].distance); i++);
                    return n.splice(i, 0, {
                        distance: t,
                        object: e
                    }), this.add(e), this
                },
                getCurrentLevel: function() {
                    return this._currentLevel
                },
                getObjectForDistance: function(e) {
                    const t = this.levels;
                    if (t.length > 0) {
                        let n, i;
                        for (n = 1, i = t.length; n < i && !(e < t[n].distance); n++);
                        return t[n - 1].object
                    }
                    return null
                },
                raycast: function(e, t) {
                    if (this.levels.length > 0) {
                        el.setFromMatrixPosition(this.matrixWorld);
                        const n = e.ray.origin.distanceTo(el);
                        this.getObjectForDistance(n).raycast(e, t)
                    }
                },
                update: function(e) {
                    const t = this.levels;
                    if (t.length > 1) {
                        el.setFromMatrixPosition(e.matrixWorld), tl.setFromMatrixPosition(this.matrixWorld);
                        const n = el.distanceTo(tl) / e.zoom;
                        let i, r;
                        for (t[0].object.visible = !0, i = 1, r = t.length; i < r && n >= t[i].distance; i++) t[i - 1].object.visible = !1, t[i].object.visible = !0;
                        for (this._currentLevel = i - 1; i < r; i++) t[i].object.visible = !1
                    }
                },
                toJSON: function(e) {
                    const t = Object3D.prototype.toJSON.call(this, e);
                    !1 === this.autoUpdate && (t.object.autoUpdate = !1), t.object.levels = [];
                    const n = this.levels;
                    for (let e = 0, i = n.length; e < i; e++) {
                        const i = n[e];
                        t.object.levels.push({
                            object: i.object.uuid,
                            distance: i.distance
                        })
                    }
                    return t
                }
            });
            const nl = new Vector3,
                il = new Vector4,
                rl = new Vector4,
                al = new Vector3,
                ol = new Matrix4;
            SkinnedMesh.prototype = Object.assign(Object.create(Mesh.prototype), {
                constructor: SkinnedMesh,
                isSkinnedMesh: !0,
                copy: function(e) {
                    return Mesh.prototype.copy.call(this, e), this.bindMode = e.bindMode, this.bindMatrix.copy(e.bindMatrix), this.bindMatrixInverse.copy(e.bindMatrixInverse), this.skeleton = e.skeleton, this
                },
                bind: function(e, t) {
                    this.skeleton = e, void 0 === t && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), t = this.matrixWorld), this.bindMatrix.copy(t), this.bindMatrixInverse.copy(t).invert()
                },
                pose: function() {
                    this.skeleton.pose()
                },
                normalizeSkinWeights: function() {
                    const e = new Vector4,
                        t = this.geometry.attributes.skinWeight;
                    for (let n = 0, i = t.count; n < i; n++) {
                        e.x = t.getX(n), e.y = t.getY(n), e.z = t.getZ(n), e.w = t.getW(n);
                        const i = 1 / e.manhattanLength();
                        i !== 1 / 0 ? e.multiplyScalar(i) : e.set(1, 0, 0, 0), t.setXYZW(n, e.x, e.y, e.z, e.w)
                    }
                },
                updateMatrixWorld: function(e) {
                    Mesh.prototype.updateMatrixWorld.call(this, e), "attached" === this.bindMode ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : "detached" === this.bindMode && this.bindMatrixInverse.copy(this.bindMatrix).invert()
                },
                boneTransform: function(e, t) {
                    const n = this.skeleton,
                        i = this.geometry;
                    il.fromBufferAttribute(i.attributes.skinIndex, e), rl.fromBufferAttribute(i.attributes.skinWeight, e), nl.fromBufferAttribute(i.attributes.position, e).applyMatrix4(this.bindMatrix), t.set(0, 0, 0);
                    for (let e = 0; e < 4; e++) {
                        const i = rl.getComponent(e);
                        if (0 !== i) {
                            const r = il.getComponent(e);
                            ol.multiplyMatrices(n.bones[r].matrixWorld, n.boneInverses[r]), t.addScaledVector(al.copy(nl).applyMatrix4(ol), i)
                        }
                    }
                    return t.applyMatrix4(this.bindMatrixInverse)
                }
            }), Bone.prototype = Object.assign(Object.create(Object3D.prototype), {
                constructor: Bone,
                isBone: !0
            });
            const sl = new Matrix4,
                ll = new Matrix4;
            Object.assign(Skeleton.prototype, {
                init: function() {
                    const e = this.bones,
                        t = this.boneInverses;
                    if (this.boneMatrices = new Float32Array(16 * e.length), 0 === t.length) this.calculateInverses();
                    else if (e.length !== t.length) {
                        this.boneInverses = [];
                        for (let e = 0, t = this.bones.length; e < t; e++) this.boneInverses.push(new Matrix4)
                    }
                },
                calculateInverses: function() {
                    this.boneInverses.length = 0;
                    for (let e = 0, t = this.bones.length; e < t; e++) {
                        const t = new Matrix4;
                        this.bones[e] && t.copy(this.bones[e].matrixWorld).invert(), this.boneInverses.push(t)
                    }
                },
                pose: function() {
                    for (let e = 0, t = this.bones.length; e < t; e++) {
                        const t = this.bones[e];
                        t && t.matrixWorld.copy(this.boneInverses[e]).invert()
                    }
                    for (let e = 0, t = this.bones.length; e < t; e++) {
                        const t = this.bones[e];
                        t && (t.parent && t.parent.isBone ? (t.matrix.copy(t.parent.matrixWorld).invert(), t.matrix.multiply(t.matrixWorld)) : t.matrix.copy(t.matrixWorld), t.matrix.decompose(t.position, t.quaternion, t.scale))
                    }
                },
                update: function() {
                    const e = this.bones,
                        t = this.boneInverses,
                        n = this.boneMatrices,
                        i = this.boneTexture;
                    for (let i = 0, r = e.length; i < r; i++) {
                        const r = e[i] ? e[i].matrixWorld : ll;
                        sl.multiplyMatrices(r, t[i]), sl.toArray(n, 16 * i)
                    }
                    null !== i && (i.needsUpdate = !0)
                },
                clone: function() {
                    return new Skeleton(this.bones, this.boneInverses)
                },
                getBoneByName: function(e) {
                    for (let t = 0, n = this.bones.length; t < n; t++) {
                        const n = this.bones[t];
                        if (n.name === e) return n
                    }
                },
                dispose: function() {
                    null !== this.boneTexture && (this.boneTexture.dispose(), this.boneTexture = null)
                },
                fromJSON: function(e, t) {
                    this.uuid = e.uuid;
                    for (let n = 0, i = e.bones.length; n < i; n++) {
                        let i = t[e.bones[n]];
                        void 0 === i && (i = new Bone), this.bones.push(i), this.boneInverses.push((new Matrix4).fromArray(e.boneInverses[n]))
                    }
                    return this.init(), this
                },
                toJSON: function() {
                    const e = {
                        metadata: {
                            version: 4.5,
                            type: "Skeleton",
                            generator: "Skeleton.toJSON"
                        },
                        bones: [],
                        boneInverses: []
                    };
                    e.uuid = this.uuid;
                    const t = this.bones,
                        n = this.boneInverses;
                    for (let i = 0, r = t.length; i < r; i++) {
                        const r = t[i];
                        e.bones.push(r.uuid);
                        const a = n[i];
                        e.boneInverses.push(a.toArray())
                    }
                    return e
                }
            });
            const cl = new Matrix4,
                ul = new Matrix4,
                hl = [],
                dl = new Mesh;
            InstancedMesh.prototype = Object.assign(Object.create(Mesh.prototype), {
                constructor: InstancedMesh,
                isInstancedMesh: !0,
                copy: function(e) {
                    return Mesh.prototype.copy.call(this, e), this.instanceMatrix.copy(e.instanceMatrix), this.count = e.count, this
                },
                getColorAt: function(e, t) {
                    t.fromArray(this.instanceColor.array, 3 * e)
                },
                getMatrixAt: function(e, t) {
                    t.fromArray(this.instanceMatrix.array, 16 * e)
                },
                raycast: function(e, t) {
                    const n = this.matrixWorld,
                        i = this.count;
                    if (dl.geometry = this.geometry, dl.material = this.material, void 0 !== dl.material)
                        for (let r = 0; r < i; r++) {
                            this.getMatrixAt(r, cl), ul.multiplyMatrices(n, cl), dl.matrixWorld = ul, dl.raycast(e, hl);
                            for (let e = 0, n = hl.length; e < n; e++) {
                                const n = hl[e];
                                n.instanceId = r, n.object = this, t.push(n)
                            }
                            hl.length = 0
                        }
                },
                setColorAt: function(e, t) {
                    null === this.instanceColor && (this.instanceColor = new BufferAttribute(new Float32Array(3 * this.count), 3)), t.toArray(this.instanceColor.array, 3 * e)
                },
                setMatrixAt: function(e, t) {
                    t.toArray(this.instanceMatrix.array, 16 * e)
                },
                updateMorphTargets: function() {},
                dispose: function() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            }), LineBasicMaterial.prototype = Object.create(Material.prototype), LineBasicMaterial.prototype.constructor = LineBasicMaterial, LineBasicMaterial.prototype.isLineBasicMaterial = !0, LineBasicMaterial.prototype.copy = function(e) {
                return Material.prototype.copy.call(this, e), this.color.copy(e.color), this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this.morphTargets = e.morphTargets, this
            };
            const pl = new Vector3,
                fl = new Vector3,
                ml = new Matrix4,
                gl = new Ray,
                vl = new Sphere;
            Line.prototype = Object.assign(Object.create(Object3D.prototype), {
                constructor: Line,
                isLine: !0,
                copy: function(e) {
                    return Object3D.prototype.copy.call(this, e), this.material = e.material, this.geometry = e.geometry, this
                },
                computeLineDistances: function() {
                    const e = this.geometry;
                    if (e.isBufferGeometry) {
                        if (null === e.index) {
                            const t = e.attributes.position,
                                n = [0];
                            for (let e = 1, i = t.count; e < i; e++) pl.fromBufferAttribute(t, e - 1), fl.fromBufferAttribute(t, e), n[e] = n[e - 1], n[e] += pl.distanceTo(fl);
                            e.setAttribute("lineDistance", new Float32BufferAttribute(n, 1))
                        }
                    } else if (e.isGeometry) {
                        const t = e.vertices,
                            n = e.lineDistances;
                        n[0] = 0;
                        for (let e = 1, i = t.length; e < i; e++) n[e] = n[e - 1], n[e] += t[e - 1].distanceTo(t[e])
                    }
                    return this
                },
                raycast: function(e, t) {
                    const n = this.geometry,
                        i = this.matrixWorld,
                        r = e.params.Line.threshold;
                    if (null === n.boundingSphere && n.computeBoundingSphere(), vl.copy(n.boundingSphere), vl.applyMatrix4(i), vl.radius += r, !1 === e.ray.intersectsSphere(vl)) return;
                    ml.copy(i).invert(), gl.copy(e.ray).applyMatrix4(ml);
                    const a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                        o = a * a,
                        s = new Vector3,
                        l = new Vector3,
                        c = new Vector3,
                        u = new Vector3,
                        h = this.isLineSegments ? 2 : 1;
                    if (n.isBufferGeometry) {
                        const i = n.index,
                            r = n.attributes.position;
                        if (null !== i) {
                            const n = i.array;
                            for (let i = 0, a = n.length - 1; i < a; i += h) {
                                const a = n[i],
                                    h = n[i + 1];
                                s.fromBufferAttribute(r, a), l.fromBufferAttribute(r, h);
                                if (gl.distanceSqToSegment(s, l, u, c) > o) continue;
                                u.applyMatrix4(this.matrixWorld);
                                const d = e.ray.origin.distanceTo(u);
                                d < e.near || d > e.far || t.push({
                                    distance: d,
                                    point: c.clone().applyMatrix4(this.matrixWorld),
                                    index: i,
                                    face: null,
                                    faceIndex: null,
                                    object: this
                                })
                            }
                        } else
                            for (let n = 0, i = r.count - 1; n < i; n += h) {
                                s.fromBufferAttribute(r, n), l.fromBufferAttribute(r, n + 1);
                                if (gl.distanceSqToSegment(s, l, u, c) > o) continue;
                                u.applyMatrix4(this.matrixWorld);
                                const i = e.ray.origin.distanceTo(u);
                                i < e.near || i > e.far || t.push({
                                    distance: i,
                                    point: c.clone().applyMatrix4(this.matrixWorld),
                                    index: n,
                                    face: null,
                                    faceIndex: null,
                                    object: this
                                })
                            }
                    } else if (n.isGeometry) {
                        const i = n.vertices,
                            r = i.length;
                        for (let n = 0; n < r - 1; n += h) {
                            if (gl.distanceSqToSegment(i[n], i[n + 1], u, c) > o) continue;
                            u.applyMatrix4(this.matrixWorld);
                            const r = e.ray.origin.distanceTo(u);
                            r < e.near || r > e.far || t.push({
                                distance: r,
                                point: c.clone().applyMatrix4(this.matrixWorld),
                                index: n,
                                face: null,
                                faceIndex: null,
                                object: this
                            })
                        }
                    }
                },
                updateMorphTargets: function() {
                    const e = this.geometry;
                    if (e.isBufferGeometry) {
                        const t = e.morphAttributes,
                            n = Object.keys(t);
                        if (n.length > 0) {
                            const e = t[n[0]];
                            if (void 0 !== e) {
                                this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                                for (let t = 0, n = e.length; t < n; t++) {
                                    const n = e[t].name || t + "";
                                    this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = t
                                }
                            }
                        }
                    } else {
                        const t = e.morphTargets;
                        void 0 !== t && t.length
                    }
                }
            });
            const yl = new Vector3,
                xl = new Vector3;
            LineSegments.prototype = Object.assign(Object.create(Line.prototype), {
                constructor: LineSegments,
                isLineSegments: !0,
                computeLineDistances: function() {
                    const e = this.geometry;
                    if (e.isBufferGeometry) {
                        if (null === e.index) {
                            const t = e.attributes.position,
                                n = [];
                            for (let e = 0, i = t.count; e < i; e += 2) yl.fromBufferAttribute(t, e), xl.fromBufferAttribute(t, e + 1), n[e] = 0 === e ? 0 : n[e - 1], n[e + 1] = n[e] + yl.distanceTo(xl);
                            e.setAttribute("lineDistance", new Float32BufferAttribute(n, 1))
                        }
                    } else if (e.isGeometry) {
                        const t = e.vertices,
                            n = e.lineDistances;
                        for (let e = 0, i = t.length; e < i; e += 2) yl.copy(t[e]), xl.copy(t[e + 1]), n[e] = 0 === e ? 0 : n[e - 1], n[e + 1] = n[e] + yl.distanceTo(xl)
                    }
                    return this
                }
            }), LineLoop.prototype = Object.assign(Object.create(Line.prototype), {
                constructor: LineLoop,
                isLineLoop: !0
            }), PointsMaterial.prototype = Object.create(Material.prototype), PointsMaterial.prototype.constructor = PointsMaterial, PointsMaterial.prototype.isPointsMaterial = !0, PointsMaterial.prototype.copy = function(e) {
                return Material.prototype.copy.call(this, e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this.morphTargets = e.morphTargets, this
            };
            const _l = new Matrix4,
                bl = new Ray,
                Ml = new Sphere,
                Sl = new Vector3;
            Points.prototype = Object.assign(Object.create(Object3D.prototype), {
                constructor: Points,
                isPoints: !0,
                copy: function(e) {
                    return Object3D.prototype.copy.call(this, e), this.material = e.material, this.geometry = e.geometry, this
                },
                raycast: function(e, t) {
                    const n = this.geometry,
                        i = this.matrixWorld,
                        r = e.params.Points.threshold;
                    if (null === n.boundingSphere && n.computeBoundingSphere(), Ml.copy(n.boundingSphere), Ml.applyMatrix4(i), Ml.radius += r, !1 === e.ray.intersectsSphere(Ml)) return;
                    _l.copy(i).invert(), bl.copy(e.ray).applyMatrix4(_l);
                    const a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                        o = a * a;
                    if (n.isBufferGeometry) {
                        const r = n.index,
                            a = n.attributes.position;
                        if (null !== r) {
                            const n = r.array;
                            for (let r = 0, s = n.length; r < s; r++) {
                                const s = n[r];
                                Sl.fromBufferAttribute(a, s), testPoint(Sl, s, o, i, e, t, this)
                            }
                        } else
                            for (let n = 0, r = a.count; n < r; n++) Sl.fromBufferAttribute(a, n), testPoint(Sl, n, o, i, e, t, this)
                    } else {
                        const r = n.vertices;
                        for (let n = 0, a = r.length; n < a; n++) testPoint(r[n], n, o, i, e, t, this)
                    }
                },
                updateMorphTargets: function() {
                    const e = this.geometry;
                    if (e.isBufferGeometry) {
                        const t = e.morphAttributes,
                            n = Object.keys(t);
                        if (n.length > 0) {
                            const e = t[n[0]];
                            if (void 0 !== e) {
                                this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                                for (let t = 0, n = e.length; t < n; t++) {
                                    const n = e[t].name || t + "";
                                    this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = t
                                }
                            }
                        }
                    } else {
                        const t = e.morphTargets;
                        void 0 !== t && t.length
                    }
                }
            }), VideoTexture.prototype = Object.assign(Object.create(Texture.prototype), {
                constructor: VideoTexture,
                clone: function() {
                    return new this.constructor(this.image).copy(this)
                },
                isVideoTexture: !0,
                update: function() {
                    const e = this.image;
                    !1 === "requestVideoFrameCallback" in e && e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
                }
            }), CompressedTexture.prototype = Object.create(Texture.prototype), CompressedTexture.prototype.constructor = CompressedTexture, CompressedTexture.prototype.isCompressedTexture = !0, CanvasTexture.prototype = Object.create(Texture.prototype), CanvasTexture.prototype.constructor = CanvasTexture, CanvasTexture.prototype.isCanvasTexture = !0, DepthTexture.prototype = Object.create(Texture.prototype), DepthTexture.prototype.constructor = DepthTexture, DepthTexture.prototype.isDepthTexture = !0;
            let Al = 0;
            const wl = new Matrix4,
                Tl = new Object3D,
                Ll = new Vector3;
            Geometry.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
                constructor: Geometry,
                isGeometry: !0,
                applyMatrix4: function(e) {
                    const t = (new Matrix3).getNormalMatrix(e);
                    for (let t = 0, n = this.vertices.length; t < n; t++) {
                        this.vertices[t].applyMatrix4(e)
                    }
                    for (let e = 0, n = this.faces.length; e < n; e++) {
                        const n = this.faces[e];
                        n.normal.applyMatrix3(t).normalize();
                        for (let e = 0, i = n.vertexNormals.length; e < i; e++) n.vertexNormals[e].applyMatrix3(t).normalize()
                    }
                    return null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this.verticesNeedUpdate = !0, this.normalsNeedUpdate = !0, this
                },
                rotateX: function(e) {
                    return wl.makeRotationX(e), this.applyMatrix4(wl), this
                },
                rotateY: function(e) {
                    return wl.makeRotationY(e), this.applyMatrix4(wl), this
                },
                rotateZ: function(e) {
                    return wl.makeRotationZ(e), this.applyMatrix4(wl), this
                },
                translate: function(e, t, n) {
                    return wl.makeTranslation(e, t, n), this.applyMatrix4(wl), this
                },
                scale: function(e, t, n) {
                    return wl.makeScale(e, t, n), this.applyMatrix4(wl), this
                },
                lookAt: function(e) {
                    return Tl.lookAt(e), Tl.updateMatrix(), this.applyMatrix4(Tl.matrix), this
                },
                fromBufferGeometry: function(e) {
                    function addFace(e, n, i, r) {
                        const c = void 0 === o ? [] : [t.colors[e].clone(), t.colors[n].clone(), t.colors[i].clone()],
                            u = void 0 === a ? [] : [(new Vector3).fromBufferAttribute(a, e), (new Vector3).fromBufferAttribute(a, n), (new Vector3).fromBufferAttribute(a, i)],
                            h = new Face3(e, n, i, u, c, r);
                        t.faces.push(h), void 0 !== s && t.faceVertexUvs[0].push([(new Vector2).fromBufferAttribute(s, e), (new Vector2).fromBufferAttribute(s, n), (new Vector2).fromBufferAttribute(s, i)]), void 0 !== l && t.faceVertexUvs[1].push([(new Vector2).fromBufferAttribute(l, e), (new Vector2).fromBufferAttribute(l, n), (new Vector2).fromBufferAttribute(l, i)])
                    }
                    const t = this,
                        n = null !== e.index ? e.index : void 0,
                        i = e.attributes;
                    if (void 0 === i.position) return this;
                    const r = i.position,
                        a = i.normal,
                        o = i.color,
                        s = i.uv,
                        l = i.uv2;
                    void 0 !== l && (this.faceVertexUvs[1] = []);
                    for (let e = 0; e < r.count; e++) t.vertices.push((new Vector3).fromBufferAttribute(r, e)), void 0 !== o && t.colors.push((new Color).fromBufferAttribute(o, e));
                    const c = e.groups;
                    if (c.length > 0)
                        for (let e = 0; e < c.length; e++) {
                            const t = c[e],
                                i = t.start;
                            for (let e = i, r = i + t.count; e < r; e += 3) void 0 !== n ? addFace(n.getX(e), n.getX(e + 1), n.getX(e + 2), t.materialIndex) : addFace(e, e + 1, e + 2, t.materialIndex)
                        } else if (void 0 !== n)
                            for (let e = 0; e < n.count; e += 3) addFace(n.getX(e), n.getX(e + 1), n.getX(e + 2));
                        else
                            for (let e = 0; e < r.count; e += 3) addFace(e, e + 1, e + 2);
                    return this.computeFaceNormals(), null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()), null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), this
                },
                center: function() {
                    return this.computeBoundingBox(), this.boundingBox.getCenter(Ll).negate(), this.translate(Ll.x, Ll.y, Ll.z), this
                },
                normalize: function() {
                    this.computeBoundingSphere();
                    const e = this.boundingSphere.center,
                        t = this.boundingSphere.radius,
                        n = 0 === t ? 1 : 1 / t,
                        i = new Matrix4;
                    return i.set(n, 0, 0, -n * e.x, 0, n, 0, -n * e.y, 0, 0, n, -n * e.z, 0, 0, 0, 1), this.applyMatrix4(i), this
                },
                computeFaceNormals: function() {
                    const e = new Vector3,
                        t = new Vector3;
                    for (let n = 0, i = this.faces.length; n < i; n++) {
                        const i = this.faces[n],
                            r = this.vertices[i.a],
                            a = this.vertices[i.b],
                            o = this.vertices[i.c];
                        e.subVectors(o, a), t.subVectors(r, a), e.cross(t), e.normalize(), i.normal.copy(e)
                    }
                },
                computeVertexNormals: function(e = !0) {
                    const t = Array(this.vertices.length);
                    for (let e = 0, n = this.vertices.length; e < n; e++) t[e] = new Vector3;
                    if (e) {
                        const e = new Vector3,
                            n = new Vector3;
                        for (let i = 0, r = this.faces.length; i < r; i++) {
                            const r = this.faces[i],
                                a = this.vertices[r.a],
                                o = this.vertices[r.b],
                                s = this.vertices[r.c];
                            e.subVectors(s, o), n.subVectors(a, o), e.cross(n), t[r.a].add(e), t[r.b].add(e), t[r.c].add(e)
                        }
                    } else {
                        this.computeFaceNormals();
                        for (let e = 0, n = this.faces.length; e < n; e++) {
                            const n = this.faces[e];
                            t[n.a].add(n.normal), t[n.b].add(n.normal), t[n.c].add(n.normal)
                        }
                    }
                    for (let e = 0, n = this.vertices.length; e < n; e++) t[e].normalize();
                    for (let e = 0, n = this.faces.length; e < n; e++) {
                        const n = this.faces[e],
                            i = n.vertexNormals;
                        3 === i.length ? (i[0].copy(t[n.a]), i[1].copy(t[n.b]), i[2].copy(t[n.c])) : (i[0] = t[n.a].clone(), i[1] = t[n.b].clone(), i[2] = t[n.c].clone())
                    }
                    this.faces.length > 0 && (this.normalsNeedUpdate = !0)
                },
                computeFlatVertexNormals: function() {
                    this.computeFaceNormals();
                    for (let e = 0, t = this.faces.length; e < t; e++) {
                        const t = this.faces[e],
                            n = t.vertexNormals;
                        3 === n.length ? (n[0].copy(t.normal), n[1].copy(t.normal), n[2].copy(t.normal)) : (n[0] = t.normal.clone(), n[1] = t.normal.clone(), n[2] = t.normal.clone())
                    }
                    this.faces.length > 0 && (this.normalsNeedUpdate = !0)
                },
                computeMorphNormals: function() {
                    for (let e = 0, t = this.faces.length; e < t; e++) {
                        const t = this.faces[e];
                        t.__originalFaceNormal ? t.__originalFaceNormal.copy(t.normal) : t.__originalFaceNormal = t.normal.clone(), t.__originalVertexNormals || (t.__originalVertexNormals = []);
                        for (let e = 0, n = t.vertexNormals.length; e < n; e++) t.__originalVertexNormals[e] ? t.__originalVertexNormals[e].copy(t.vertexNormals[e]) : t.__originalVertexNormals[e] = t.vertexNormals[e].clone()
                    }
                    const e = new Geometry;
                    e.faces = this.faces;
                    for (let t = 0, n = this.morphTargets.length; t < n; t++) {
                        if (!this.morphNormals[t]) {
                            this.morphNormals[t] = {}, this.morphNormals[t].faceNormals = [], this.morphNormals[t].vertexNormals = [];
                            const e = this.morphNormals[t].faceNormals,
                                n = this.morphNormals[t].vertexNormals;
                            for (let t = 0, i = this.faces.length; t < i; t++) {
                                const t = new Vector3,
                                    i = {
                                        a: new Vector3,
                                        b: new Vector3,
                                        c: new Vector3
                                    };
                                e.push(t), n.push(i)
                            }
                        }
                        const n = this.morphNormals[t];
                        e.vertices = this.morphTargets[t].vertices, e.computeFaceNormals(), e.computeVertexNormals();
                        for (let e = 0, t = this.faces.length; e < t; e++) {
                            const t = this.faces[e],
                                i = n.faceNormals[e],
                                r = n.vertexNormals[e];
                            i.copy(t.normal), r.a.copy(t.vertexNormals[0]), r.b.copy(t.vertexNormals[1]), r.c.copy(t.vertexNormals[2])
                        }
                    }
                    for (let e = 0, t = this.faces.length; e < t; e++) {
                        const t = this.faces[e];
                        t.normal = t.__originalFaceNormal, t.vertexNormals = t.__originalVertexNormals
                    }
                },
                computeBoundingBox: function() {
                    null === this.boundingBox && (this.boundingBox = new Box3), this.boundingBox.setFromPoints(this.vertices)
                },
                computeBoundingSphere: function() {
                    null === this.boundingSphere && (this.boundingSphere = new Sphere), this.boundingSphere.setFromPoints(this.vertices)
                },
                merge: function(e, t, n = 0) {
                    if (!e || !e.isGeometry) return;
                    let i;
                    const r = this.vertices.length,
                        a = this.vertices,
                        o = e.vertices,
                        s = this.faces,
                        l = e.faces,
                        c = this.colors,
                        u = e.colors;
                    void 0 !== t && (i = (new Matrix3).getNormalMatrix(t));
                    for (let e = 0, n = o.length; e < n; e++) {
                        const n = o[e].clone();
                        void 0 !== t && n.applyMatrix4(t), a.push(n)
                    }
                    for (let e = 0, t = u.length; e < t; e++) c.push(u[e].clone());
                    for (let e = 0, t = l.length; e < t; e++) {
                        const t = l[e];
                        let a, o;
                        const c = t.vertexNormals,
                            u = t.vertexColors,
                            h = new Face3(t.a + r, t.b + r, t.c + r);
                        h.normal.copy(t.normal), void 0 !== i && h.normal.applyMatrix3(i).normalize();
                        for (let e = 0, t = c.length; e < t; e++) a = c[e].clone(), void 0 !== i && a.applyMatrix3(i).normalize(), h.vertexNormals.push(a);
                        h.color.copy(t.color);
                        for (let e = 0, t = u.length; e < t; e++) o = u[e], h.vertexColors.push(o.clone());
                        h.materialIndex = t.materialIndex + n, s.push(h)
                    }
                    for (let t = 0, n = e.faceVertexUvs.length; t < n; t++) {
                        const n = e.faceVertexUvs[t];
                        void 0 === this.faceVertexUvs[t] && (this.faceVertexUvs[t] = []);
                        for (let e = 0, i = n.length; e < i; e++) {
                            const i = n[e],
                                r = [];
                            for (let e = 0, t = i.length; e < t; e++) r.push(i[e].clone());
                            this.faceVertexUvs[t].push(r)
                        }
                    }
                },
                mergeMesh: function(e) {
                    e && e.isMesh && (e.matrixAutoUpdate && e.updateMatrix(), this.merge(e.geometry, e.matrix))
                },
                mergeVertices: function(e = 4) {
                    const t = {},
                        n = [],
                        i = [],
                        r = Math.pow(10, e);
                    for (let e = 0, a = this.vertices.length; e < a; e++) {
                        const a = this.vertices[e],
                            o = Math.round(a.x * r) + "_" + Math.round(a.y * r) + "_" + Math.round(a.z * r);
                        void 0 === t[o] ? (t[o] = e, n.push(this.vertices[e]), i[e] = n.length - 1) : i[e] = i[t[o]]
                    }
                    const a = [];
                    for (let e = 0, t = this.faces.length; e < t; e++) {
                        const t = this.faces[e];
                        t.a = i[t.a], t.b = i[t.b], t.c = i[t.c];
                        const n = [t.a, t.b, t.c];
                        for (let t = 0; t < 3; t++)
                            if (n[t] === n[(t + 1) % 3]) {
                                a.push(e);
                                break
                            }
                    }
                    for (let e = a.length - 1; e >= 0; e--) {
                        const t = a[e];
                        this.faces.splice(t, 1);
                        for (let e = 0, n = this.faceVertexUvs.length; e < n; e++) this.faceVertexUvs[e].splice(t, 1)
                    }
                    const o = this.vertices.length - n.length;
                    return this.vertices = n, o
                },
                setFromPoints: function(e) {
                    this.vertices = [];
                    for (let t = 0, n = e.length; t < n; t++) {
                        const n = e[t];
                        this.vertices.push(new Vector3(n.x, n.y, n.z || 0))
                    }
                    return this
                },
                sortFacesByMaterialIndex: function() {
                    const e = this.faces,
                        t = e.length;
                    for (let n = 0; n < t; n++) e[n]._id = n;
                    e.sort((function materialIndexSort(e, t) {
                        return e.materialIndex - t.materialIndex
                    }));
                    const n = this.faceVertexUvs[0],
                        i = this.faceVertexUvs[1];
                    let r, a;
                    n && n.length === t && (r = []), i && i.length === t && (a = []);
                    for (let o = 0; o < t; o++) {
                        const t = e[o]._id;
                        r && r.push(n[t]), a && a.push(i[t])
                    }
                    r && (this.faceVertexUvs[0] = r), a && (this.faceVertexUvs[1] = a)
                },
                toJSON: function() {
                    function setBit(e, t, n) {
                        return n ? e | 1 << t : e & ~(1 << t)
                    }

                    function getNormalIndex(e) {
                        const t = e.x.toString() + e.y.toString() + e.z.toString();
                        return void 0 !== r[t] || (r[t] = i.length / 3, i.push(e.x, e.y, e.z)), r[t]
                    }

                    function getColorIndex(e) {
                        const t = e.r.toString() + e.g.toString() + e.b.toString();
                        return void 0 !== o[t] || (o[t] = a.length, a.push(e.getHex())), o[t]
                    }

                    function getUvIndex(e) {
                        const t = e.x.toString() + e.y.toString();
                        return void 0 !== l[t] || (l[t] = s.length / 2, s.push(e.x, e.y)), l[t]
                    }
                    const e = {
                        metadata: {
                            version: 4.5,
                            type: "Geometry",
                            generator: "Geometry.toJSON"
                        }
                    };
                    if (e.uuid = this.uuid, e.type = this.type, "" !== this.name && (e.name = this.name), void 0 !== this.parameters) {
                        const t = this.parameters;
                        for (const n in t) void 0 !== t[n] && (e[n] = t[n]);
                        return e
                    }
                    const t = [];
                    for (let e = 0; e < this.vertices.length; e++) {
                        const n = this.vertices[e];
                        t.push(n.x, n.y, n.z)
                    }
                    const n = [],
                        i = [],
                        r = {},
                        a = [],
                        o = {},
                        s = [],
                        l = {};
                    for (let e = 0; e < this.faces.length; e++) {
                        const t = this.faces[e],
                            i = !0,
                            r = !1,
                            a = void 0 !== this.faceVertexUvs[0][e],
                            o = t.normal.length() > 0,
                            s = t.vertexNormals.length > 0,
                            l = 1 !== t.color.r || 1 !== t.color.g || 1 !== t.color.b,
                            c = t.vertexColors.length > 0;
                        let u = 0;
                        if (u = setBit(u, 0, 0), u = setBit(u, 1, i), u = setBit(u, 2, r), u = setBit(u, 3, a), u = setBit(u, 4, o), u = setBit(u, 5, s), u = setBit(u, 6, l), u = setBit(u, 7, c), n.push(u), n.push(t.a, t.b, t.c), n.push(t.materialIndex), a) {
                            const t = this.faceVertexUvs[0][e];
                            n.push(getUvIndex(t[0]), getUvIndex(t[1]), getUvIndex(t[2]))
                        }
                        if (o && n.push(getNormalIndex(t.normal)), s) {
                            const e = t.vertexNormals;
                            n.push(getNormalIndex(e[0]), getNormalIndex(e[1]), getNormalIndex(e[2]))
                        }
                        if (l && n.push(getColorIndex(t.color)), c) {
                            const e = t.vertexColors;
                            n.push(getColorIndex(e[0]), getColorIndex(e[1]), getColorIndex(e[2]))
                        }
                    }
                    return e.data = {}, e.data.vertices = t, e.data.normals = i, a.length > 0 && (e.data.colors = a), s.length > 0 && (e.data.uvs = [s]), e.data.faces = n, e
                },
                clone: function() {
                    return (new Geometry).copy(this)
                },
                copy: function(e) {
                    this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [
                        []
                    ], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.name = e.name;
                    const t = e.vertices;
                    for (let e = 0, n = t.length; e < n; e++) this.vertices.push(t[e].clone());
                    const n = e.colors;
                    for (let e = 0, t = n.length; e < t; e++) this.colors.push(n[e].clone());
                    const i = e.faces;
                    for (let e = 0, t = i.length; e < t; e++) this.faces.push(i[e].clone());
                    for (let t = 0, n = e.faceVertexUvs.length; t < n; t++) {
                        const n = e.faceVertexUvs[t];
                        void 0 === this.faceVertexUvs[t] && (this.faceVertexUvs[t] = []);
                        for (let e = 0, i = n.length; e < i; e++) {
                            const i = n[e],
                                r = [];
                            for (let e = 0, t = i.length; e < t; e++) {
                                const t = i[e];
                                r.push(t.clone())
                            }
                            this.faceVertexUvs[t].push(r)
                        }
                    }
                    const r = e.morphTargets;
                    for (let e = 0, t = r.length; e < t; e++) {
                        const t = {};
                        if (t.name = r[e].name, void 0 !== r[e].vertices) {
                            t.vertices = [];
                            for (let n = 0, i = r[e].vertices.length; n < i; n++) t.vertices.push(r[e].vertices[n].clone())
                        }
                        if (void 0 !== r[e].normals) {
                            t.normals = [];
                            for (let n = 0, i = r[e].normals.length; n < i; n++) t.normals.push(r[e].normals[n].clone())
                        }
                        this.morphTargets.push(t)
                    }
                    const a = e.morphNormals;
                    for (let e = 0, t = a.length; e < t; e++) {
                        const t = {};
                        if (void 0 !== a[e].vertexNormals) {
                            t.vertexNormals = [];
                            for (let n = 0, i = a[e].vertexNormals.length; n < i; n++) {
                                const i = a[e].vertexNormals[n],
                                    r = {};
                                r.a = i.a.clone(), r.b = i.b.clone(), r.c = i.c.clone(), t.vertexNormals.push(r)
                            }
                        }
                        if (void 0 !== a[e].faceNormals) {
                            t.faceNormals = [];
                            for (let n = 0, i = a[e].faceNormals.length; n < i; n++) t.faceNormals.push(a[e].faceNormals[n].clone())
                        }
                        this.morphNormals.push(t)
                    }
                    const o = e.skinWeights;
                    for (let e = 0, t = o.length; e < t; e++) this.skinWeights.push(o[e].clone());
                    const s = e.skinIndices;
                    for (let e = 0, t = s.length; e < t; e++) this.skinIndices.push(s[e].clone());
                    const l = e.lineDistances;
                    for (let e = 0, t = l.length; e < t; e++) this.lineDistances.push(l[e]);
                    const c = e.boundingBox;
                    null !== c && (this.boundingBox = c.clone());
                    const u = e.boundingSphere;
                    return null !== u && (this.boundingSphere = u.clone()), this.elementsNeedUpdate = e.elementsNeedUpdate, this.verticesNeedUpdate = e.verticesNeedUpdate, this.uvsNeedUpdate = e.uvsNeedUpdate, this.normalsNeedUpdate = e.normalsNeedUpdate, this.colorsNeedUpdate = e.colorsNeedUpdate, this.lineDistancesNeedUpdate = e.lineDistancesNeedUpdate, this.groupsNeedUpdate = e.groupsNeedUpdate, this
                },
                dispose: function() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            });
            class BoxGeometry extends Geometry {
                constructor(e, t, n, i, r, a) {
                    super(), this.type = "BoxGeometry", this.parameters = {
                        width: e,
                        height: t,
                        depth: n,
                        widthSegments: i,
                        heightSegments: r,
                        depthSegments: a
                    }, this.fromBufferGeometry(new BoxBufferGeometry(e, t, n, i, r, a)), this.mergeVertices()
                }
            }
            class CircleBufferGeometry extends BufferGeometry {
                constructor(e = 1, t = 8, n = 0, i = 2 * Math.PI) {
                    super(), this.type = "CircleBufferGeometry", this.parameters = {
                        radius: e,
                        segments: t,
                        thetaStart: n,
                        thetaLength: i
                    }, t = Math.max(3, t);
                    const r = [],
                        a = [],
                        o = [],
                        s = [],
                        l = new Vector3,
                        c = new Vector2;
                    a.push(0, 0, 0), o.push(0, 0, 1), s.push(.5, .5);
                    for (let r = 0, u = 3; r <= t; r++, u += 3) {
                        const h = n + r / t * i;
                        l.x = e * Math.cos(h), l.y = e * Math.sin(h), a.push(l.x, l.y, l.z), o.push(0, 0, 1), c.x = (a[u] / e + 1) / 2, c.y = (a[u + 1] / e + 1) / 2, s.push(c.x, c.y)
                    }
                    for (let e = 1; e <= t; e++) r.push(e, e + 1, 0);
                    this.setIndex(r), this.setAttribute("position", new Float32BufferAttribute(a, 3)), this.setAttribute("normal", new Float32BufferAttribute(o, 3)), this.setAttribute("uv", new Float32BufferAttribute(s, 2))
                }
            }
            class CircleGeometry extends Geometry {
                constructor(e, t, n, i) {
                    super(), this.type = "CircleGeometry", this.parameters = {
                        radius: e,
                        segments: t,
                        thetaStart: n,
                        thetaLength: i
                    }, this.fromBufferGeometry(new CircleBufferGeometry(e, t, n, i)), this.mergeVertices()
                }
            }
            class CylinderBufferGeometry extends BufferGeometry {
                constructor(e = 1, t = 1, n = 1, i = 8, r = 1, a = !1, o = 0, s = 2 * Math.PI) {
                    function generateCap(n) {
                        const r = p,
                            a = new Vector2,
                            f = new Vector3;
                        let y = 0;
                        const x = !0 === n ? e : t,
                            _ = !0 === n ? 1 : -1;
                        for (let e = 1; e <= i; e++) u.push(0, m * _, 0), h.push(0, _, 0), d.push(.5, .5), p++;
                        const b = p;
                        for (let e = 0; e <= i; e++) {
                            const t = e / i * s + o,
                                n = Math.cos(t),
                                r = Math.sin(t);
                            f.x = x * r, f.y = m * _, f.z = x * n, u.push(f.x, f.y, f.z), h.push(0, _, 0), a.x = .5 * n + .5, a.y = .5 * r * _ + .5, d.push(a.x, a.y), p++
                        }
                        for (let e = 0; e < i; e++) {
                            const t = r + e,
                                i = b + e;
                            !0 === n ? c.push(i, i + 1, t) : c.push(i + 1, i, t), y += 3
                        }
                        l.addGroup(g, y, !0 === n ? 1 : 2), g += y
                    }
                    super(), this.type = "CylinderBufferGeometry", this.parameters = {
                        radiusTop: e,
                        radiusBottom: t,
                        height: n,
                        radialSegments: i,
                        heightSegments: r,
                        openEnded: a,
                        thetaStart: o,
                        thetaLength: s
                    };
                    const l = this;
                    i = Math.floor(i), r = Math.floor(r);
                    const c = [],
                        u = [],
                        h = [],
                        d = [];
                    let p = 0;
                    const f = [],
                        m = n / 2;
                    let g = 0;
                    ! function generateTorso() {
                        const a = new Vector3,
                            y = new Vector3;
                        let x = 0;
                        const _ = (t - e) / n;
                        for (let l = 0; l <= r; l++) {
                            const c = [],
                                g = l / r,
                                x = g * (t - e) + e;
                            for (let e = 0; e <= i; e++) {
                                const t = e / i,
                                    r = t * s + o,
                                    l = Math.sin(r),
                                    f = Math.cos(r);
                                y.x = x * l, y.y = -g * n + m, y.z = x * f, u.push(y.x, y.y, y.z), a.set(l, _, f).normalize(), h.push(a.x, a.y, a.z), d.push(t, 1 - g), c.push(p++)
                            }
                            f.push(c)
                        }
                        for (let e = 0; e < i; e++)
                            for (let t = 0; t < r; t++) {
                                const n = f[t][e],
                                    i = f[t + 1][e],
                                    r = f[t + 1][e + 1],
                                    a = f[t][e + 1];
                                c.push(n, i, a), c.push(i, r, a), x += 6
                            }
                        l.addGroup(g, x, 0), g += x
                    }(), !1 === a && (e > 0 && generateCap(!0), t > 0 && generateCap(!1)), this.setIndex(c), this.setAttribute("position", new Float32BufferAttribute(u, 3)), this.setAttribute("normal", new Float32BufferAttribute(h, 3)), this.setAttribute("uv", new Float32BufferAttribute(d, 2))
                }
            }
            class CylinderGeometry extends Geometry {
                constructor(e, t, n, i, r, a, o, s) {
                    super(), this.type = "CylinderGeometry", this.parameters = {
                        radiusTop: e,
                        radiusBottom: t,
                        height: n,
                        radialSegments: i,
                        heightSegments: r,
                        openEnded: a,
                        thetaStart: o,
                        thetaLength: s
                    }, this.fromBufferGeometry(new CylinderBufferGeometry(e, t, n, i, r, a, o, s)), this.mergeVertices()
                }
            }
            class ConeGeometry extends CylinderGeometry {
                constructor(e, t, n, i, r, a, o) {
                    super(0, e, t, n, i, r, a, o), this.type = "ConeGeometry", this.parameters = {
                        radius: e,
                        height: t,
                        radialSegments: n,
                        heightSegments: i,
                        openEnded: r,
                        thetaStart: a,
                        thetaLength: o
                    }
                }
            }
            class ConeBufferGeometry extends CylinderBufferGeometry {
                constructor(e = 1, t = 1, n = 8, i = 1, r = !1, a = 0, o = 2 * Math.PI) {
                    super(0, e, t, n, i, r, a, o), this.type = "ConeBufferGeometry", this.parameters = {
                        radius: e,
                        height: t,
                        radialSegments: n,
                        heightSegments: i,
                        openEnded: r,
                        thetaStart: a,
                        thetaLength: o
                    }
                }
            }
            class PolyhedronBufferGeometry extends BufferGeometry {
                constructor(e, t, n = 1, i = 0) {
                    function subdivideFace(e, t, n, i) {
                        const r = i + 1,
                            a = [];
                        for (let i = 0; i <= r; i++) {
                            a[i] = [];
                            const o = e.clone().lerp(n, i / r),
                                s = t.clone().lerp(n, i / r),
                                l = r - i;
                            for (let e = 0; e <= l; e++) a[i][e] = 0 === e && i === r ? o : o.clone().lerp(s, e / l)
                        }
                        for (let e = 0; e < r; e++)
                            for (let t = 0; t < 2 * (r - e) - 1; t++) {
                                const n = Math.floor(t / 2);
                                t % 2 == 0 ? (pushVertex(a[e][n + 1]), pushVertex(a[e + 1][n]), pushVertex(a[e][n])) : (pushVertex(a[e][n + 1]), pushVertex(a[e + 1][n + 1]), pushVertex(a[e + 1][n]))
                            }
                    }

                    function pushVertex(e) {
                        r.push(e.x, e.y, e.z)
                    }

                    function getVertexByIndex(t, n) {
                        const i = 3 * t;
                        n.x = e[i + 0], n.y = e[i + 1], n.z = e[i + 2]
                    }

                    function correctUV(e, t, n, i) {
                        i < 0 && 1 === e.x && (a[t] = e.x - 1), 0 === n.x && 0 === n.z && (a[t] = i / 2 / Math.PI + .5)
                    }

                    function azimuth(e) {
                        return Math.atan2(e.z, -e.x)
                    }
                    super(), this.type = "PolyhedronBufferGeometry", this.parameters = {
                        vertices: e,
                        indices: t,
                        radius: n,
                        detail: i
                    };
                    const r = [],
                        a = [];
                    ! function subdivide(e) {
                        const n = new Vector3,
                            i = new Vector3,
                            r = new Vector3;
                        for (let a = 0; a < t.length; a += 3) getVertexByIndex(t[a + 0], n), getVertexByIndex(t[a + 1], i), getVertexByIndex(t[a + 2], r), subdivideFace(n, i, r, e)
                    }(i),
                    function applyRadius(e) {
                        const t = new Vector3;
                        for (let n = 0; n < r.length; n += 3) t.x = r[n + 0], t.y = r[n + 1], t.z = r[n + 2], t.normalize().multiplyScalar(e), r[n + 0] = t.x, r[n + 1] = t.y, r[n + 2] = t.z
                    }(n),
                    function generateUVs() {
                        const e = new Vector3;
                        for (let n = 0; n < r.length; n += 3) {
                            e.x = r[n + 0], e.y = r[n + 1], e.z = r[n + 2];
                            const i = azimuth(e) / 2 / Math.PI + .5,
                                o = Math.atan2(-(t = e).y, Math.sqrt(t.x * t.x + t.z * t.z)) / Math.PI + .5;
                            a.push(i, 1 - o)
                        }
                        var t;
                        ! function correctUVs() {
                            const e = new Vector3,
                                t = new Vector3,
                                n = new Vector3,
                                i = new Vector3,
                                o = new Vector2,
                                s = new Vector2,
                                l = new Vector2;
                            for (let c = 0, u = 0; c < r.length; c += 9, u += 6) {
                                e.set(r[c + 0], r[c + 1], r[c + 2]), t.set(r[c + 3], r[c + 4], r[c + 5]), n.set(r[c + 6], r[c + 7], r[c + 8]), o.set(a[u + 0], a[u + 1]), s.set(a[u + 2], a[u + 3]), l.set(a[u + 4], a[u + 5]), i.copy(e).add(t).add(n).divideScalar(3);
                                const h = azimuth(i);
                                correctUV(o, u + 0, e, h), correctUV(s, u + 2, t, h), correctUV(l, u + 4, n, h)
                            }
                        }(),
                        function correctSeam() {
                            for (let e = 0; e < a.length; e += 6) {
                                const t = a[e + 0],
                                    n = a[e + 2],
                                    i = a[e + 4],
                                    r = Math.max(t, n, i),
                                    o = Math.min(t, n, i);
                                r > .9 && o < .1 && (t < .2 && (a[e + 0] += 1), n < .2 && (a[e + 2] += 1), i < .2 && (a[e + 4] += 1))
                            }
                        }()
                    }(), this.setAttribute("position", new Float32BufferAttribute(r, 3)), this.setAttribute("normal", new Float32BufferAttribute(r.slice(), 3)), this.setAttribute("uv", new Float32BufferAttribute(a, 2)), 0 === i ? this.computeVertexNormals() : this.normalizeNormals()
                }
            }
            class DodecahedronBufferGeometry extends PolyhedronBufferGeometry {
                constructor(e = 1, t = 0) {
                    const n = 1.618033988749895,
                        i = 1 / n;
                    super([-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -i, -n, 0, -i, n, 0, i, -n, 0, i, n, -i, -n, 0, -i, n, 0, i, -n, 0, i, n, 0, -n, 0, -i, n, 0, -i, -n, 0, i, n, 0, i], [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], e, t), this.type = "DodecahedronBufferGeometry", this.parameters = {
                        radius: e,
                        detail: t
                    }
                }
            }
            class DodecahedronGeometry extends Geometry {
                constructor(e, t) {
                    super(), this.type = "DodecahedronGeometry", this.parameters = {
                        radius: e,
                        detail: t
                    }, this.fromBufferGeometry(new DodecahedronBufferGeometry(e, t)), this.mergeVertices()
                }
            }
            const Cl = new Vector3,
                Pl = new Vector3,
                El = new Vector3,
                Il = new Triangle;
            class EdgesGeometry extends BufferGeometry {
                constructor(e, t) {
                    super(), this.type = "EdgesGeometry", this.parameters = {
                        thresholdAngle: t
                    }, t = void 0 !== t ? t : 1, e.isGeometry && (e = (new BufferGeometry).fromGeometry(e));
                    const n = 1e4,
                        i = Math.cos(Fa.DEG2RAD * t),
                        r = e.getIndex(),
                        a = e.getAttribute("position"),
                        o = r ? r.count : a.count,
                        s = [0, 0, 0],
                        l = ["a", "b", "c"],
                        c = [, , , ],
                        u = {},
                        h = [];
                    for (let e = 0; e < o; e += 3) {
                        r ? (s[0] = r.getX(e), s[1] = r.getX(e + 1), s[2] = r.getX(e + 2)) : (s[0] = e, s[1] = e + 1, s[2] = e + 2);
                        const {
                            a: t,
                            b: o,
                            c: d
                        } = Il;
                        if (t.fromBufferAttribute(a, s[0]), o.fromBufferAttribute(a, s[1]), d.fromBufferAttribute(a, s[2]), Il.getNormal(El), c[0] = `${Math.round(t.x*n)},${Math.round(t.y*n)},${Math.round(t.z*n)}`, c[1] = `${Math.round(o.x*n)},${Math.round(o.y*n)},${Math.round(o.z*n)}`, c[2] = `${Math.round(d.x*n)},${Math.round(d.y*n)},${Math.round(d.z*n)}`, c[0] !== c[1] && c[1] !== c[2] && c[2] !== c[0])
                            for (let e = 0; e < 3; e++) {
                                const t = (e + 1) % 3,
                                    n = c[e],
                                    r = c[t],
                                    a = Il[l[e]],
                                    o = Il[l[t]],
                                    d = `${n}_${r}`,
                                    p = `${r}_${n}`;
                                p in u && u[p] ? (El.dot(u[p].normal) <= i && (h.push(a.x, a.y, a.z), h.push(o.x, o.y, o.z)), u[p] = null) : d in u || (u[d] = {
                                    index0: s[e],
                                    index1: s[t],
                                    normal: El.clone()
                                })
                            }
                    }
                    for (const e in u)
                        if (u[e]) {
                            const {
                                index0: t,
                                index1: n
                            } = u[e];
                            Cl.fromBufferAttribute(a, t), Pl.fromBufferAttribute(a, n), h.push(Cl.x, Cl.y, Cl.z), h.push(Pl.x, Pl.y, Pl.z)
                        }
                    this.setAttribute("position", new Float32BufferAttribute(h, 3))
                }
            }
            const Earcut_triangulate = function(e, t, n) {
                    n = n || 2;
                    const i = t && t.length,
                        r = i ? t[0] * n : e.length;
                    let a = linkedList(e, 0, r, n, !0);
                    const o = [];
                    if (!a || a.next === a.prev) return o;
                    let s, l, c, u, h, d, p;
                    if (i && (a = function eliminateHoles(e, t, n, i) {
                            const r = [];
                            let a, o, s, l, c;
                            for (a = 0, o = t.length; a < o; a++) s = t[a] * i, l = a < o - 1 ? t[a + 1] * i : e.length, c = linkedList(e, s, l, i, !1), c === c.next && (c.steiner = !0), r.push(getLeftmost(c));
                            for (r.sort(compareX), a = 0; a < r.length; a++) eliminateHole(r[a], n), n = filterPoints(n, n.next);
                            return n
                        }(e, t, a, n)), e.length > 80 * n) {
                        s = c = e[0], l = u = e[1];
                        for (let t = n; t < r; t += n) h = e[t], d = e[t + 1], h < s && (s = h), d < l && (l = d), h > c && (c = h), d > u && (u = d);
                        p = Math.max(c - s, u - l), p = 0 !== p ? 1 / p : 0
                    }
                    return earcutLinked(a, o, n, s, l, p), o
                },
                Fl = {
                    area: function(e) {
                        const t = e.length;
                        let n = 0;
                        for (let i = t - 1, r = 0; r < t; i = r++) n += e[i].x * e[r].y - e[r].x * e[i].y;
                        return .5 * n
                    },
                    isClockWise: function(e) {
                        return Fl.area(e) < 0
                    },
                    triangulateShape: function(e, t) {
                        const n = [],
                            i = [],
                            r = [];
                        removeDupEndPts(e), addContour(n, e);
                        let a = e.length;
                        t.forEach(removeDupEndPts);
                        for (let e = 0; e < t.length; e++) i.push(a), a += t[e].length, addContour(n, t[e]);
                        const o = Earcut_triangulate(n, i);
                        for (let e = 0; e < o.length; e += 3) r.push(o.slice(e, e + 3));
                        return r
                    }
                };
            class ExtrudeBufferGeometry extends BufferGeometry {
                constructor(e, t) {
                    function addShape(e) {
                        function scalePt2(e, t, n) {
                            return t.clone().multiplyScalar(n).add(e)
                        }

                        function getBevelVec(e, t, n) {
                            let i, r, a;
                            const o = e.x - t.x,
                                s = e.y - t.y,
                                l = n.x - e.x,
                                c = n.y - e.y,
                                u = o * o + s * s;
                            if (Math.abs(o * c - s * l) > Number.EPSILON) {
                                const h = Math.sqrt(u),
                                    d = Math.sqrt(l * l + c * c),
                                    p = t.x - s / h,
                                    f = t.y + o / h,
                                    m = ((n.x - c / d - p) * c - (n.y + l / d - f) * l) / (o * c - s * l);
                                i = p + o * m - e.x, r = f + s * m - e.y;
                                const g = i * i + r * r;
                                if (g <= 2) return new Vector2(i, r);
                                a = Math.sqrt(g / 2)
                            } else {
                                let e = !1;
                                o > Number.EPSILON ? l > Number.EPSILON && (e = !0) : o < -Number.EPSILON ? l < -Number.EPSILON && (e = !0) : Math.sign(s) === Math.sign(c) && (e = !0), e ? (i = -s, r = o, a = Math.sqrt(u)) : (i = o, r = s, a = Math.sqrt(u / 2))
                            }
                            return new Vector2(i / a, r / a)
                        }

                        function sidewalls(e, t) {
                            let n = e.length;
                            for (; --n >= 0;) {
                                const i = n;
                                let r = n - 1;
                                r < 0 && (r = e.length - 1);
                                for (let e = 0, n = s + 2 * p; e < n; e++) {
                                    const n = C * e,
                                        a = C * (e + 1);
                                    f4(t + i + n, t + r + n, t + r + a, t + i + a)
                                }
                            }
                        }

                        function v(e, t, n) {
                            a.push(e), a.push(t), a.push(n)
                        }

                        function f3(e, t, r) {
                            addVertex(e), addVertex(t), addVertex(r);
                            const a = i.length / 3,
                                o = m.generateTopUV(n, i, a - 3, a - 2, a - 1);
                            addUV(o[0]), addUV(o[1]), addUV(o[2])
                        }

                        function f4(e, t, r, a) {
                            addVertex(e), addVertex(t), addVertex(a), addVertex(t), addVertex(r), addVertex(a);
                            const o = i.length / 3,
                                s = m.generateSideWallUV(n, i, o - 6, o - 3, o - 2, o - 1);
                            addUV(s[0]), addUV(s[1]), addUV(s[3]), addUV(s[1]), addUV(s[2]), addUV(s[3])
                        }

                        function addVertex(e) {
                            i.push(a[3 * e + 0]), i.push(a[3 * e + 1]), i.push(a[3 * e + 2])
                        }

                        function addUV(e) {
                            r.push(e.x), r.push(e.y)
                        }
                        const a = [],
                            o = void 0 !== t.curveSegments ? t.curveSegments : 12,
                            s = void 0 !== t.steps ? t.steps : 1;
                        let l = void 0 !== t.depth ? t.depth : 100,
                            c = void 0 === t.bevelEnabled || t.bevelEnabled,
                            u = void 0 !== t.bevelThickness ? t.bevelThickness : 6,
                            h = void 0 !== t.bevelSize ? t.bevelSize : u - 2,
                            d = void 0 !== t.bevelOffset ? t.bevelOffset : 0,
                            p = void 0 !== t.bevelSegments ? t.bevelSegments : 3;
                        const f = t.extrudePath,
                            m = void 0 !== t.UVGenerator ? t.UVGenerator : Ol;
                        void 0 !== t.amount && (l = t.amount);
                        let g, y, x, _, b, M = !1;
                        f && (g = f.getSpacedPoints(s), M = !0, c = !1, y = f.computeFrenetFrames(s, !1), x = new Vector3, _ = new Vector3, b = new Vector3), c || (p = 0, u = 0, h = 0, d = 0);
                        const S = e.extractPoints(o);
                        let A = S.shape;
                        const w = S.holes;
                        if (!Fl.isClockWise(A)) {
                            A = A.reverse();
                            for (let e = 0, t = w.length; e < t; e++) {
                                const t = w[e];
                                Fl.isClockWise(t) && (w[e] = t.reverse())
                            }
                        }
                        const T = Fl.triangulateShape(A, w),
                            L = A;
                        for (let e = 0, t = w.length; e < t; e++) {
                            const t = w[e];
                            A = A.concat(t)
                        }
                        const C = A.length,
                            P = T.length,
                            E = [];
                        for (let e = 0, t = L.length, n = t - 1, i = e + 1; e < t; e++, n++, i++) n === t && (n = 0), i === t && (i = 0), E[e] = getBevelVec(L[e], L[n], L[i]);
                        const I = [];
                        let F, O = E.concat();
                        for (let e = 0, t = w.length; e < t; e++) {
                            const t = w[e];
                            F = [];
                            for (let e = 0, n = t.length, i = n - 1, r = e + 1; e < n; e++, i++, r++) i === n && (i = 0), r === n && (r = 0), F[e] = getBevelVec(t[e], t[i], t[r]);
                            I.push(F), O = O.concat(F)
                        }
                        for (let e = 0; e < p; e++) {
                            const t = e / p,
                                n = u * Math.cos(t * Math.PI / 2),
                                i = h * Math.sin(t * Math.PI / 2) + d;
                            for (let e = 0, t = L.length; e < t; e++) {
                                const t = scalePt2(L[e], E[e], i);
                                v(t.x, t.y, -n)
                            }
                            for (let e = 0, t = w.length; e < t; e++) {
                                const t = w[e];
                                F = I[e];
                                for (let e = 0, r = t.length; e < r; e++) {
                                    const r = scalePt2(t[e], F[e], i);
                                    v(r.x, r.y, -n)
                                }
                            }
                        }
                        const B = h + d;
                        for (let e = 0; e < C; e++) {
                            const t = c ? scalePt2(A[e], O[e], B) : A[e];
                            M ? (_.copy(y.normals[0]).multiplyScalar(t.x), x.copy(y.binormals[0]).multiplyScalar(t.y), b.copy(g[0]).add(_).add(x), v(b.x, b.y, b.z)) : v(t.x, t.y, 0)
                        }
                        for (let e = 1; e <= s; e++)
                            for (let t = 0; t < C; t++) {
                                const n = c ? scalePt2(A[t], O[t], B) : A[t];
                                M ? (_.copy(y.normals[e]).multiplyScalar(n.x), x.copy(y.binormals[e]).multiplyScalar(n.y), b.copy(g[e]).add(_).add(x), v(b.x, b.y, b.z)) : v(n.x, n.y, l / s * e)
                            }
                        for (let e = p - 1; e >= 0; e--) {
                            const t = e / p,
                                n = u * Math.cos(t * Math.PI / 2),
                                i = h * Math.sin(t * Math.PI / 2) + d;
                            for (let e = 0, t = L.length; e < t; e++) {
                                const t = scalePt2(L[e], E[e], i);
                                v(t.x, t.y, l + n)
                            }
                            for (let e = 0, t = w.length; e < t; e++) {
                                const t = w[e];
                                F = I[e];
                                for (let e = 0, r = t.length; e < r; e++) {
                                    const r = scalePt2(t[e], F[e], i);
                                    M ? v(r.x, r.y + g[s - 1].y, g[s - 1].x + n) : v(r.x, r.y, l + n)
                                }
                            }
                        }! function buildLidFaces() {
                            const e = i.length / 3;
                            if (c) {
                                let e = 0,
                                    t = C * e;
                                for (let e = 0; e < P; e++) {
                                    const n = T[e];
                                    f3(n[2] + t, n[1] + t, n[0] + t)
                                }
                                e = s + 2 * p, t = C * e;
                                for (let e = 0; e < P; e++) {
                                    const n = T[e];
                                    f3(n[0] + t, n[1] + t, n[2] + t)
                                }
                            } else {
                                for (let e = 0; e < P; e++) {
                                    const t = T[e];
                                    f3(t[2], t[1], t[0])
                                }
                                for (let e = 0; e < P; e++) {
                                    const t = T[e];
                                    f3(t[0] + C * s, t[1] + C * s, t[2] + C * s)
                                }
                            }
                            n.addGroup(e, i.length / 3 - e, 0)
                        }(),
                        function buildSideFaces() {
                            const e = i.length / 3;
                            let t = 0;
                            sidewalls(L, t), t += L.length;
                            for (let e = 0, n = w.length; e < n; e++) {
                                const n = w[e];
                                sidewalls(n, t), t += n.length
                            }
                            n.addGroup(e, i.length / 3 - e, 1)
                        }()
                    }
                    super(), this.type = "ExtrudeBufferGeometry", this.parameters = {
                        shapes: e,
                        options: t
                    };
                    const n = this,
                        i = [],
                        r = [];
                    for (let t = 0, n = (e = Array.isArray(e) ? e : [e]).length; t < n; t++) {
                        addShape(e[t])
                    }
                    this.setAttribute("position", new Float32BufferAttribute(i, 3)), this.setAttribute("uv", new Float32BufferAttribute(r, 2)), this.computeVertexNormals()
                }
                toJSON() {
                    const e = BufferGeometry.prototype.toJSON.call(this);
                    return function toJSON(e, t, n) {
                        if (n.shapes = [], Array.isArray(e))
                            for (let t = 0, i = e.length; t < i; t++) {
                                const i = e[t];
                                n.shapes.push(i.uuid)
                            } else n.shapes.push(e.uuid);
                        return void 0 !== t.extrudePath && (n.options.extrudePath = t.extrudePath.toJSON()), n
                    }(this.parameters.shapes, this.parameters.options, e)
                }
            }
            const Ol = {
                generateTopUV: function(e, t, n, i, r) {
                    const a = t[3 * n],
                        o = t[3 * n + 1],
                        s = t[3 * i],
                        l = t[3 * i + 1],
                        c = t[3 * r],
                        u = t[3 * r + 1];
                    return [new Vector2(a, o), new Vector2(s, l), new Vector2(c, u)]
                },
                generateSideWallUV: function(e, t, n, i, r, a) {
                    const o = t[3 * n],
                        s = t[3 * n + 1],
                        l = t[3 * n + 2],
                        c = t[3 * i],
                        u = t[3 * i + 1],
                        h = t[3 * i + 2],
                        d = t[3 * r],
                        p = t[3 * r + 1],
                        f = t[3 * r + 2],
                        m = t[3 * a],
                        g = t[3 * a + 1],
                        y = t[3 * a + 2];
                    return Math.abs(s - u) < .01 ? [new Vector2(o, 1 - l), new Vector2(c, 1 - h), new Vector2(d, 1 - f), new Vector2(m, 1 - y)] : [new Vector2(s, 1 - l), new Vector2(u, 1 - h), new Vector2(p, 1 - f), new Vector2(g, 1 - y)]
                }
            };
            class ExtrudeGeometry extends Geometry {
                constructor(e, t) {
                    super(), this.type = "ExtrudeGeometry", this.parameters = {
                        shapes: e,
                        options: t
                    }, this.fromBufferGeometry(new ExtrudeBufferGeometry(e, t)), this.mergeVertices()
                }
                toJSON() {
                    const e = super.toJSON();
                    return function toJSON$1(e, t, n) {
                        if (n.shapes = [], Array.isArray(e))
                            for (let t = 0, i = e.length; t < i; t++) {
                                const i = e[t];
                                n.shapes.push(i.uuid)
                            } else n.shapes.push(e.uuid);
                        return void 0 !== t.extrudePath && (n.options.extrudePath = t.extrudePath.toJSON()), n
                    }(this.parameters.shapes, this.parameters.options, e)
                }
            }
            class IcosahedronBufferGeometry extends PolyhedronBufferGeometry {
                constructor(e = 1, t = 0) {
                    const n = 1.618033988749895;
                    super([-1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, 0, 0, -1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, n, 0, -1, n, 0, 1, -n, 0, -1, -n, 0, 1], [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], e, t), this.type = "IcosahedronBufferGeometry", this.parameters = {
                        radius: e,
                        detail: t
                    }
                }
            }
            class IcosahedronGeometry extends Geometry {
                constructor(e, t) {
                    super(), this.type = "IcosahedronGeometry", this.parameters = {
                        radius: e,
                        detail: t
                    }, this.fromBufferGeometry(new IcosahedronBufferGeometry(e, t)), this.mergeVertices()
                }
            }
            class LatheBufferGeometry extends BufferGeometry {
                constructor(e, t = 12, n = 0, i = 2 * Math.PI) {
                    super(), this.type = "LatheBufferGeometry", this.parameters = {
                        points: e,
                        segments: t,
                        phiStart: n,
                        phiLength: i
                    }, t = Math.floor(t), i = Fa.clamp(i, 0, 2 * Math.PI);
                    const r = [],
                        a = [],
                        o = [],
                        s = 1 / t,
                        l = new Vector3,
                        c = new Vector2;
                    for (let r = 0; r <= t; r++) {
                        const u = n + r * s * i,
                            h = Math.sin(u),
                            d = Math.cos(u);
                        for (let n = 0; n <= e.length - 1; n++) l.x = e[n].x * h, l.y = e[n].y, l.z = e[n].x * d, a.push(l.x, l.y, l.z), c.x = r / t, c.y = n / (e.length - 1), o.push(c.x, c.y)
                    }
                    for (let n = 0; n < t; n++)
                        for (let t = 0; t < e.length - 1; t++) {
                            const i = t + n * e.length,
                                a = i,
                                o = i + e.length,
                                s = i + e.length + 1,
                                l = i + 1;
                            r.push(a, o, l), r.push(o, s, l)
                        }
                    if (this.setIndex(r), this.setAttribute("position", new Float32BufferAttribute(a, 3)), this.setAttribute("uv", new Float32BufferAttribute(o, 2)), this.computeVertexNormals(), i === 2 * Math.PI) {
                        const n = this.attributes.normal.array,
                            i = new Vector3,
                            r = new Vector3,
                            a = new Vector3,
                            o = t * e.length * 3;
                        for (let t = 0, s = 0; t < e.length; t++, s += 3) i.x = n[s + 0], i.y = n[s + 1], i.z = n[s + 2], r.x = n[o + s + 0], r.y = n[o + s + 1], r.z = n[o + s + 2], a.addVectors(i, r).normalize(), n[s + 0] = n[o + s + 0] = a.x, n[s + 1] = n[o + s + 1] = a.y, n[s + 2] = n[o + s + 2] = a.z
                    }
                }
            }
            class LatheGeometry extends Geometry {
                constructor(e, t, n, i) {
                    super(), this.type = "LatheGeometry", this.parameters = {
                        points: e,
                        segments: t,
                        phiStart: n,
                        phiLength: i
                    }, this.fromBufferGeometry(new LatheBufferGeometry(e, t, n, i)), this.mergeVertices()
                }
            }
            class OctahedronBufferGeometry extends PolyhedronBufferGeometry {
                constructor(e = 1, t = 0) {
                    super([1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], e, t), this.type = "OctahedronBufferGeometry", this.parameters = {
                        radius: e,
                        detail: t
                    }
                }
            }
            class OctahedronGeometry extends Geometry {
                constructor(e, t) {
                    super(), this.type = "OctahedronGeometry", this.parameters = {
                        radius: e,
                        detail: t
                    }, this.fromBufferGeometry(new OctahedronBufferGeometry(e, t)), this.mergeVertices()
                }
            }
            ParametricBufferGeometry.prototype = Object.create(BufferGeometry.prototype), ParametricBufferGeometry.prototype.constructor = ParametricBufferGeometry, ParametricGeometry.prototype = Object.create(Geometry.prototype), ParametricGeometry.prototype.constructor = ParametricGeometry;
            class PlaneGeometry extends Geometry {
                constructor(e, t, n, i) {
                    super(), this.type = "PlaneGeometry", this.parameters = {
                        width: e,
                        height: t,
                        widthSegments: n,
                        heightSegments: i
                    }, this.fromBufferGeometry(new PlaneBufferGeometry(e, t, n, i)), this.mergeVertices()
                }
            }
            class PolyhedronGeometry extends Geometry {
                constructor(e, t, n, i) {
                    super(), this.type = "PolyhedronGeometry", this.parameters = {
                        vertices: e,
                        indices: t,
                        radius: n,
                        detail: i
                    }, this.fromBufferGeometry(new PolyhedronBufferGeometry(e, t, n, i)), this.mergeVertices()
                }
            }
            class RingBufferGeometry extends BufferGeometry {
                constructor(e = .5, t = 1, n = 8, i = 1, r = 0, a = 2 * Math.PI) {
                    super(), this.type = "RingBufferGeometry", this.parameters = {
                        innerRadius: e,
                        outerRadius: t,
                        thetaSegments: n,
                        phiSegments: i,
                        thetaStart: r,
                        thetaLength: a
                    }, n = Math.max(3, n);
                    const o = [],
                        s = [],
                        l = [],
                        c = [];
                    let u = e;
                    const h = (t - e) / (i = Math.max(1, i)),
                        d = new Vector3,
                        p = new Vector2;
                    for (let e = 0; e <= i; e++) {
                        for (let e = 0; e <= n; e++) {
                            const i = r + e / n * a;
                            d.x = u * Math.cos(i), d.y = u * Math.sin(i), s.push(d.x, d.y, d.z), l.push(0, 0, 1), p.x = (d.x / t + 1) / 2, p.y = (d.y / t + 1) / 2, c.push(p.x, p.y)
                        }
                        u += h
                    }
                    for (let e = 0; e < i; e++) {
                        const t = e * (n + 1);
                        for (let e = 0; e < n; e++) {
                            const i = e + t,
                                r = i,
                                a = i + n + 1,
                                s = i + n + 2,
                                l = i + 1;
                            o.push(r, a, l), o.push(a, s, l)
                        }
                    }
                    this.setIndex(o), this.setAttribute("position", new Float32BufferAttribute(s, 3)), this.setAttribute("normal", new Float32BufferAttribute(l, 3)), this.setAttribute("uv", new Float32BufferAttribute(c, 2))
                }
            }
            class RingGeometry extends Geometry {
                constructor(e, t, n, i, r, a) {
                    super(), this.type = "RingGeometry", this.parameters = {
                        innerRadius: e,
                        outerRadius: t,
                        thetaSegments: n,
                        phiSegments: i,
                        thetaStart: r,
                        thetaLength: a
                    }, this.fromBufferGeometry(new RingBufferGeometry(e, t, n, i, r, a)), this.mergeVertices()
                }
            }
            class ShapeBufferGeometry extends BufferGeometry {
                constructor(e, t = 12) {
                    function addShape(e) {
                        const o = i.length / 3,
                            l = e.extractPoints(t);
                        let c = l.shape;
                        const u = l.holes;
                        !1 === Fl.isClockWise(c) && (c = c.reverse());
                        for (let e = 0, t = u.length; e < t; e++) {
                            const t = u[e];
                            !0 === Fl.isClockWise(t) && (u[e] = t.reverse())
                        }
                        const h = Fl.triangulateShape(c, u);
                        for (let e = 0, t = u.length; e < t; e++) {
                            const t = u[e];
                            c = c.concat(t)
                        }
                        for (let e = 0, t = c.length; e < t; e++) {
                            const t = c[e];
                            i.push(t.x, t.y, 0), r.push(0, 0, 1), a.push(t.x, t.y)
                        }
                        for (let e = 0, t = h.length; e < t; e++) {
                            const t = h[e],
                                i = t[0] + o,
                                r = t[1] + o,
                                a = t[2] + o;
                            n.push(i, r, a), s += 3
                        }
                    }
                    super(), this.type = "ShapeBufferGeometry", this.parameters = {
                        shapes: e,
                        curveSegments: t
                    };
                    const n = [],
                        i = [],
                        r = [],
                        a = [];
                    let o = 0,
                        s = 0;
                    if (!1 === Array.isArray(e)) addShape(e);
                    else
                        for (let t = 0; t < e.length; t++) addShape(e[t]), this.addGroup(o, s, t), o += s, s = 0;
                    this.setIndex(n), this.setAttribute("position", new Float32BufferAttribute(i, 3)), this.setAttribute("normal", new Float32BufferAttribute(r, 3)), this.setAttribute("uv", new Float32BufferAttribute(a, 2))
                }
                toJSON() {
                    const e = BufferGeometry.prototype.toJSON.call(this);
                    return function toJSON$2(e, t) {
                        if (t.shapes = [], Array.isArray(e))
                            for (let n = 0, i = e.length; n < i; n++) {
                                const i = e[n];
                                t.shapes.push(i.uuid)
                            } else t.shapes.push(e.uuid);
                        return t
                    }(this.parameters.shapes, e)
                }
            }
            class ShapeGeometry extends Geometry {
                constructor(e, t) {
                    super(), this.type = "ShapeGeometry", "object" == typeof t && (t = t.curveSegments), this.parameters = {
                        shapes: e,
                        curveSegments: t
                    }, this.fromBufferGeometry(new ShapeBufferGeometry(e, t)), this.mergeVertices()
                }
                toJSON() {
                    const e = Geometry.prototype.toJSON.call(this);
                    return function toJSON$3(e, t) {
                        if (t.shapes = [], Array.isArray(e))
                            for (let n = 0, i = e.length; n < i; n++) {
                                const i = e[n];
                                t.shapes.push(i.uuid)
                            } else t.shapes.push(e.uuid);
                        return t
                    }(this.parameters.shapes, e)
                }
            }
            class SphereBufferGeometry extends BufferGeometry {
                constructor(e = 1, t = 8, n = 6, i = 0, r = 2 * Math.PI, a = 0, o = Math.PI) {
                    super(), this.type = "SphereBufferGeometry", this.parameters = {
                        radius: e,
                        widthSegments: t,
                        heightSegments: n,
                        phiStart: i,
                        phiLength: r,
                        thetaStart: a,
                        thetaLength: o
                    }, t = Math.max(3, Math.floor(t)), n = Math.max(2, Math.floor(n));
                    const s = Math.min(a + o, Math.PI);
                    let l = 0;
                    const c = [],
                        u = new Vector3,
                        h = new Vector3,
                        d = [],
                        p = [],
                        f = [],
                        m = [];
                    for (let d = 0; d <= n; d++) {
                        const g = [],
                            y = d / n;
                        let x = 0;
                        0 == d && 0 == a ? x = .5 / t : d == n && s == Math.PI && (x = -.5 / t);
                        for (let n = 0; n <= t; n++) {
                            const s = n / t;
                            u.x = -e * Math.cos(i + s * r) * Math.sin(a + y * o), u.y = e * Math.cos(a + y * o), u.z = e * Math.sin(i + s * r) * Math.sin(a + y * o), p.push(u.x, u.y, u.z), h.copy(u).normalize(), f.push(h.x, h.y, h.z), m.push(s + x, 1 - y), g.push(l++)
                        }
                        c.push(g)
                    }
                    for (let e = 0; e < n; e++)
                        for (let i = 0; i < t; i++) {
                            const t = c[e][i + 1],
                                r = c[e][i],
                                o = c[e + 1][i],
                                l = c[e + 1][i + 1];
                            (0 !== e || a > 0) && d.push(t, r, l), (e !== n - 1 || s < Math.PI) && d.push(r, o, l)
                        }
                    this.setIndex(d), this.setAttribute("position", new Float32BufferAttribute(p, 3)), this.setAttribute("normal", new Float32BufferAttribute(f, 3)), this.setAttribute("uv", new Float32BufferAttribute(m, 2))
                }
            }
            class SphereGeometry extends Geometry {
                constructor(e, t, n, i, r, a, o) {
                    super(), this.type = "SphereGeometry", this.parameters = {
                        radius: e,
                        widthSegments: t,
                        heightSegments: n,
                        phiStart: i,
                        phiLength: r,
                        thetaStart: a,
                        thetaLength: o
                    }, this.fromBufferGeometry(new SphereBufferGeometry(e, t, n, i, r, a, o)), this.mergeVertices()
                }
            }
            class TetrahedronBufferGeometry extends PolyhedronBufferGeometry {
                constructor(e = 1, t = 0) {
                    super([1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], e, t), this.type = "TetrahedronBufferGeometry", this.parameters = {
                        radius: e,
                        detail: t
                    }
                }
            }
            class TetrahedronGeometry extends Geometry {
                constructor(e, t) {
                    super(), this.type = "TetrahedronGeometry", this.parameters = {
                        radius: e,
                        detail: t
                    }, this.fromBufferGeometry(new TetrahedronBufferGeometry(e, t)), this.mergeVertices()
                }
            }
            class TextBufferGeometry extends ExtrudeBufferGeometry {
                constructor(e, t = {}) {
                    const n = t.font;
                    if (!n || !n.isFont) return new BufferGeometry;
                    const i = n.generateShapes(e, t.size);
                    t.depth = void 0 !== t.height ? t.height : 50, void 0 === t.bevelThickness && (t.bevelThickness = 10), void 0 === t.bevelSize && (t.bevelSize = 8), void 0 === t.bevelEnabled && (t.bevelEnabled = !1), super(i, t), this.type = "TextBufferGeometry"
                }
            }
            class TextGeometry extends Geometry {
                constructor(e, t) {
                    super(), this.type = "TextGeometry", this.parameters = {
                        text: e,
                        parameters: t
                    }, this.fromBufferGeometry(new TextBufferGeometry(e, t)), this.mergeVertices()
                }
            }
            class TorusBufferGeometry extends BufferGeometry {
                constructor(e = 1, t = .4, n = 8, i = 6, r = 2 * Math.PI) {
                    super(), this.type = "TorusBufferGeometry", this.parameters = {
                        radius: e,
                        tube: t,
                        radialSegments: n,
                        tubularSegments: i,
                        arc: r
                    }, n = Math.floor(n), i = Math.floor(i);
                    const a = [],
                        o = [],
                        s = [],
                        l = [],
                        c = new Vector3,
                        u = new Vector3,
                        h = new Vector3;
                    for (let a = 0; a <= n; a++)
                        for (let d = 0; d <= i; d++) {
                            const p = d / i * r,
                                f = a / n * Math.PI * 2;
                            u.x = (e + t * Math.cos(f)) * Math.cos(p), u.y = (e + t * Math.cos(f)) * Math.sin(p), u.z = t * Math.sin(f), o.push(u.x, u.y, u.z), c.x = e * Math.cos(p), c.y = e * Math.sin(p), h.subVectors(u, c).normalize(), s.push(h.x, h.y, h.z), l.push(d / i), l.push(a / n)
                        }
                    for (let e = 1; e <= n; e++)
                        for (let t = 1; t <= i; t++) {
                            const n = (i + 1) * e + t - 1,
                                r = (i + 1) * (e - 1) + t - 1,
                                o = (i + 1) * (e - 1) + t,
                                s = (i + 1) * e + t;
                            a.push(n, r, s), a.push(r, o, s)
                        }
                    this.setIndex(a), this.setAttribute("position", new Float32BufferAttribute(o, 3)), this.setAttribute("normal", new Float32BufferAttribute(s, 3)), this.setAttribute("uv", new Float32BufferAttribute(l, 2))
                }
            }
            class TorusGeometry extends Geometry {
                constructor(e, t, n, i, r) {
                    super(), this.type = "TorusGeometry", this.parameters = {
                        radius: e,
                        tube: t,
                        radialSegments: n,
                        tubularSegments: i,
                        arc: r
                    }, this.fromBufferGeometry(new TorusBufferGeometry(e, t, n, i, r)), this.mergeVertices()
                }
            }
            class TorusKnotBufferGeometry extends BufferGeometry {
                constructor(e = 1, t = .4, n = 64, i = 8, r = 2, a = 3) {
                    function calculatePositionOnCurve(e, t, n, i, r) {
                        const a = Math.cos(e),
                            o = Math.sin(e),
                            s = n / t * e,
                            l = Math.cos(s);
                        r.x = i * (2 + l) * .5 * a, r.y = i * (2 + l) * o * .5, r.z = i * Math.sin(s) * .5
                    }
                    super(), this.type = "TorusKnotBufferGeometry", this.parameters = {
                        radius: e,
                        tube: t,
                        tubularSegments: n,
                        radialSegments: i,
                        p: r,
                        q: a
                    }, n = Math.floor(n), i = Math.floor(i);
                    const o = [],
                        s = [],
                        l = [],
                        c = [],
                        u = new Vector3,
                        h = new Vector3,
                        d = new Vector3,
                        p = new Vector3,
                        f = new Vector3,
                        m = new Vector3,
                        g = new Vector3;
                    for (let o = 0; o <= n; ++o) {
                        const y = o / n * r * Math.PI * 2;
                        calculatePositionOnCurve(y, r, a, e, d), calculatePositionOnCurve(y + .01, r, a, e, p), m.subVectors(p, d), g.addVectors(p, d), f.crossVectors(m, g), g.crossVectors(f, m), f.normalize(), g.normalize();
                        for (let e = 0; e <= i; ++e) {
                            const r = e / i * Math.PI * 2,
                                a = -t * Math.cos(r),
                                p = t * Math.sin(r);
                            u.x = d.x + (a * g.x + p * f.x), u.y = d.y + (a * g.y + p * f.y), u.z = d.z + (a * g.z + p * f.z), s.push(u.x, u.y, u.z), h.subVectors(u, d).normalize(), l.push(h.x, h.y, h.z), c.push(o / n), c.push(e / i)
                        }
                    }
                    for (let e = 1; e <= n; e++)
                        for (let t = 1; t <= i; t++) {
                            const n = (i + 1) * (e - 1) + (t - 1),
                                r = (i + 1) * e + (t - 1),
                                a = (i + 1) * e + t,
                                s = (i + 1) * (e - 1) + t;
                            o.push(n, r, s), o.push(r, a, s)
                        }
                    this.setIndex(o), this.setAttribute("position", new Float32BufferAttribute(s, 3)), this.setAttribute("normal", new Float32BufferAttribute(l, 3)), this.setAttribute("uv", new Float32BufferAttribute(c, 2))
                }
            }
            class TorusKnotGeometry extends Geometry {
                constructor(e, t, n, i, r, a, o) {
                    super(), this.type = "TorusKnotGeometry", this.parameters = {
                        radius: e,
                        tube: t,
                        tubularSegments: n,
                        radialSegments: i,
                        p: r,
                        q: a
                    }, this.fromBufferGeometry(new TorusKnotBufferGeometry(e, t, n, i, r, a)), this.mergeVertices()
                }
            }
            class TubeBufferGeometry extends BufferGeometry {
                constructor(e, t = 64, n = 1, i = 8, r = !1) {
                    function generateSegment(r) {
                        c = e.getPointAt(r / t, c);
                        const l = a.normals[r],
                            d = a.binormals[r];
                        for (let e = 0; e <= i; e++) {
                            const t = e / i * Math.PI * 2,
                                r = Math.sin(t),
                                a = -Math.cos(t);
                            s.x = a * l.x + r * d.x, s.y = a * l.y + r * d.y, s.z = a * l.z + r * d.z, s.normalize(), h.push(s.x, s.y, s.z), o.x = c.x + n * s.x, o.y = c.y + n * s.y, o.z = c.z + n * s.z, u.push(o.x, o.y, o.z)
                        }
                    }
                    super(), this.type = "TubeBufferGeometry", this.parameters = {
                        path: e,
                        tubularSegments: t,
                        radius: n,
                        radialSegments: i,
                        closed: r
                    };
                    const a = e.computeFrenetFrames(t, r);
                    this.tangents = a.tangents, this.normals = a.normals, this.binormals = a.binormals;
                    const o = new Vector3,
                        s = new Vector3,
                        l = new Vector2;
                    let c = new Vector3;
                    const u = [],
                        h = [],
                        d = [],
                        p = [];
                    ! function generateBufferData() {
                        for (let e = 0; e < t; e++) generateSegment(e);
                        generateSegment(!1 === r ? t : 0),
                            function generateUVs() {
                                for (let e = 0; e <= t; e++)
                                    for (let n = 0; n <= i; n++) l.x = e / t, l.y = n / i, d.push(l.x, l.y)
                            }(),
                            function generateIndices() {
                                for (let e = 1; e <= t; e++)
                                    for (let t = 1; t <= i; t++) {
                                        const n = (i + 1) * (e - 1) + (t - 1),
                                            r = (i + 1) * e + (t - 1),
                                            a = (i + 1) * e + t,
                                            o = (i + 1) * (e - 1) + t;
                                        p.push(n, r, o), p.push(r, a, o)
                                    }
                            }()
                    }(), this.setIndex(p), this.setAttribute("position", new Float32BufferAttribute(u, 3)), this.setAttribute("normal", new Float32BufferAttribute(h, 3)), this.setAttribute("uv", new Float32BufferAttribute(d, 2))
                }
                toJSON() {
                    const e = BufferGeometry.prototype.toJSON.call(this);
                    return e.path = this.parameters.path.toJSON(), e
                }
            }
            class TubeGeometry extends Geometry {
                constructor(e, t, n, i, r, a) {
                    super(), this.type = "TubeGeometry", this.parameters = {
                        path: e,
                        tubularSegments: t,
                        radius: n,
                        radialSegments: i,
                        closed: r
                    };
                    const o = new TubeBufferGeometry(e, t, n, i, r);
                    this.tangents = o.tangents, this.normals = o.normals, this.binormals = o.binormals, this.fromBufferGeometry(o), this.mergeVertices()
                }
            }
            class WireframeGeometry extends BufferGeometry {
                constructor(e) {
                    super(), this.type = "WireframeGeometry";
                    const t = [],
                        n = [0, 0],
                        i = {},
                        r = ["a", "b", "c"];
                    if (e && e.isGeometry) {
                        const a = e.faces;
                        for (let e = 0, t = a.length; e < t; e++) {
                            const t = a[e];
                            for (let e = 0; e < 3; e++) {
                                const a = t[r[e]],
                                    o = t[r[(e + 1) % 3]];
                                n[0] = Math.min(a, o), n[1] = Math.max(a, o);
                                const s = n[0] + "," + n[1];
                                void 0 === i[s] && (i[s] = {
                                    index1: n[0],
                                    index2: n[1]
                                })
                            }
                        }
                        for (const n in i) {
                            const r = i[n];
                            let a = e.vertices[r.index1];
                            t.push(a.x, a.y, a.z), a = e.vertices[r.index2], t.push(a.x, a.y, a.z)
                        }
                    } else if (e && e.isBufferGeometry) {
                        const r = new Vector3;
                        if (null !== e.index) {
                            const a = e.attributes.position,
                                o = e.index;
                            let s = e.groups;
                            0 === s.length && (s = [{
                                start: 0,
                                count: o.count,
                                materialIndex: 0
                            }]);
                            for (let e = 0, t = s.length; e < t; ++e) {
                                const t = s[e],
                                    r = t.start;
                                for (let e = r, a = r + t.count; e < a; e += 3)
                                    for (let t = 0; t < 3; t++) {
                                        const r = o.getX(e + t),
                                            a = o.getX(e + (t + 1) % 3);
                                        n[0] = Math.min(r, a), n[1] = Math.max(r, a);
                                        const s = n[0] + "," + n[1];
                                        void 0 === i[s] && (i[s] = {
                                            index1: n[0],
                                            index2: n[1]
                                        })
                                    }
                            }
                            for (const e in i) {
                                const n = i[e];
                                r.fromBufferAttribute(a, n.index1), t.push(r.x, r.y, r.z), r.fromBufferAttribute(a, n.index2), t.push(r.x, r.y, r.z)
                            }
                        } else {
                            const n = e.attributes.position;
                            for (let e = 0, i = n.count / 3; e < i; e++)
                                for (let i = 0; i < 3; i++) {
                                    const a = 3 * e + i;
                                    r.fromBufferAttribute(n, a), t.push(r.x, r.y, r.z);
                                    const o = 3 * e + (i + 1) % 3;
                                    r.fromBufferAttribute(n, o), t.push(r.x, r.y, r.z)
                                }
                        }
                    }
                    this.setAttribute("position", new Float32BufferAttribute(t, 3))
                }
            }
            o = Object.freeze({
                __proto__: null,
                BoxGeometry,
                BoxBufferGeometry,
                CircleGeometry,
                CircleBufferGeometry,
                ConeGeometry,
                ConeBufferGeometry,
                CylinderGeometry,
                CylinderBufferGeometry,
                DodecahedronGeometry,
                DodecahedronBufferGeometry,
                EdgesGeometry,
                ExtrudeGeometry,
                ExtrudeBufferGeometry,
                IcosahedronGeometry,
                IcosahedronBufferGeometry,
                LatheGeometry,
                LatheBufferGeometry,
                OctahedronGeometry,
                OctahedronBufferGeometry,
                ParametricGeometry,
                ParametricBufferGeometry,
                PlaneGeometry,
                PlaneBufferGeometry,
                PolyhedronGeometry,
                PolyhedronBufferGeometry,
                RingGeometry,
                RingBufferGeometry,
                ShapeGeometry,
                ShapeBufferGeometry,
                SphereGeometry,
                SphereBufferGeometry,
                TetrahedronGeometry,
                TetrahedronBufferGeometry,
                TextGeometry,
                TextBufferGeometry,
                TorusGeometry,
                TorusBufferGeometry,
                TorusKnotGeometry,
                TorusKnotBufferGeometry,
                TubeGeometry,
                TubeBufferGeometry,
                WireframeGeometry
            }), ShadowMaterial.prototype = Object.create(Material.prototype), ShadowMaterial.prototype.constructor = ShadowMaterial, ShadowMaterial.prototype.isShadowMaterial = !0, ShadowMaterial.prototype.copy = function(e) {
                return Material.prototype.copy.call(this, e), this.color.copy(e.color), this
            }, RawShaderMaterial.prototype = Object.create(ShaderMaterial.prototype), RawShaderMaterial.prototype.constructor = RawShaderMaterial, RawShaderMaterial.prototype.isRawShaderMaterial = !0, MeshStandardMaterial.prototype = Object.create(Material.prototype), MeshStandardMaterial.prototype.constructor = MeshStandardMaterial, MeshStandardMaterial.prototype.isMeshStandardMaterial = !0, MeshStandardMaterial.prototype.copy = function(e) {
                return Material.prototype.copy.call(this, e), this.defines = {
                    STANDARD: ""
                }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapIntensity = e.envMapIntensity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this.vertexTangents = e.vertexTangents, this
            }, MeshPhysicalMaterial.prototype = Object.create(MeshStandardMaterial.prototype), MeshPhysicalMaterial.prototype.constructor = MeshPhysicalMaterial, MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = !0, MeshPhysicalMaterial.prototype.copy = function(e) {
                return MeshStandardMaterial.prototype.copy.call(this, e), this.defines = {
                    STANDARD: "",
                    PHYSICAL: ""
                }, this.clearcoat = e.clearcoat, this.clearcoatMap = e.clearcoatMap, this.clearcoatRoughness = e.clearcoatRoughness, this.clearcoatRoughnessMap = e.clearcoatRoughnessMap, this.clearcoatNormalMap = e.clearcoatNormalMap, this.clearcoatNormalScale.copy(e.clearcoatNormalScale), this.reflectivity = e.reflectivity, e.sheen ? this.sheen = (this.sheen || new Color).copy(e.sheen) : this.sheen = null, this.transmission = e.transmission, this.transmissionMap = e.transmissionMap, this
            }, MeshPhongMaterial.prototype = Object.create(Material.prototype), MeshPhongMaterial.prototype.constructor = MeshPhongMaterial, MeshPhongMaterial.prototype.isMeshPhongMaterial = !0, MeshPhongMaterial.prototype.copy = function(e) {
                return Material.prototype.copy.call(this, e), this.color.copy(e.color), this.specular.copy(e.specular), this.shininess = e.shininess, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this
            }, MeshToonMaterial.prototype = Object.create(Material.prototype), MeshToonMaterial.prototype.constructor = MeshToonMaterial, MeshToonMaterial.prototype.isMeshToonMaterial = !0, MeshToonMaterial.prototype.copy = function(e) {
                return Material.prototype.copy.call(this, e), this.color.copy(e.color), this.map = e.map, this.gradientMap = e.gradientMap, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this
            }, MeshNormalMaterial.prototype = Object.create(Material.prototype), MeshNormalMaterial.prototype.constructor = MeshNormalMaterial, MeshNormalMaterial.prototype.isMeshNormalMaterial = !0, MeshNormalMaterial.prototype.copy = function(e) {
                return Material.prototype.copy.call(this, e), this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this
            }, MeshLambertMaterial.prototype = Object.create(Material.prototype), MeshLambertMaterial.prototype.constructor = MeshLambertMaterial, MeshLambertMaterial.prototype.isMeshLambertMaterial = !0, MeshLambertMaterial.prototype.copy = function(e) {
                return Material.prototype.copy.call(this, e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this
            }, MeshMatcapMaterial.prototype = Object.create(Material.prototype), MeshMatcapMaterial.prototype.constructor = MeshMatcapMaterial, MeshMatcapMaterial.prototype.isMeshMatcapMaterial = !0, MeshMatcapMaterial.prototype.copy = function(e) {
                return Material.prototype.copy.call(this, e), this.defines = {
                    MATCAP: ""
                }, this.color.copy(e.color), this.matcap = e.matcap, this.map = e.map, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this
            }, LineDashedMaterial.prototype = Object.create(LineBasicMaterial.prototype), LineDashedMaterial.prototype.constructor = LineDashedMaterial, LineDashedMaterial.prototype.isLineDashedMaterial = !0, LineDashedMaterial.prototype.copy = function(e) {
                return LineBasicMaterial.prototype.copy.call(this, e), this.scale = e.scale, this.dashSize = e.dashSize, this.gapSize = e.gapSize, this
            }, s = Object.freeze({
                __proto__: null,
                ShadowMaterial,
                SpriteMaterial,
                RawShaderMaterial,
                ShaderMaterial,
                PointsMaterial,
                MeshPhysicalMaterial,
                MeshStandardMaterial,
                MeshPhongMaterial,
                MeshToonMaterial,
                MeshNormalMaterial,
                MeshLambertMaterial,
                MeshDepthMaterial,
                MeshDistanceMaterial,
                MeshBasicMaterial,
                MeshMatcapMaterial,
                LineDashedMaterial,
                LineBasicMaterial,
                Material
            });
            const Bl = {
                arraySlice: function(e, t, n) {
                    return Bl.isTypedArray(e) ? new e.constructor(e.subarray(t, void 0 !== n ? n : e.length)) : e.slice(t, n)
                },
                convertArray: function(e, t, n) {
                    return !e || !n && e.constructor === t ? e : "number" == typeof t.BYTES_PER_ELEMENT ? new t(e) : Array.prototype.slice.call(e)
                },
                isTypedArray: function(e) {
                    return ArrayBuffer.isView(e) && !(e instanceof DataView)
                },
                getKeyframeOrder: function(e) {
                    const t = e.length,
                        n = Array(t);
                    for (let e = 0; e !== t; ++e) n[e] = e;
                    return n.sort((function compareTime(t, n) {
                        return e[t] - e[n]
                    })), n
                },
                sortedArray: function(e, t, n) {
                    const i = e.length,
                        r = new e.constructor(i);
                    for (let a = 0, o = 0; o !== i; ++a) {
                        const i = n[a] * t;
                        for (let n = 0; n !== t; ++n) r[o++] = e[i + n]
                    }
                    return r
                },
                flattenJSON: function(e, t, n, i) {
                    let r = 1,
                        a = e[0];
                    for (; void 0 !== a && void 0 === a[i];) a = e[r++];
                    if (void 0 === a) return;
                    let o = a[i];
                    if (void 0 !== o)
                        if (Array.isArray(o))
                            do {
                                o = a[i], void 0 !== o && (t.push(a.time), n.push.apply(n, o)), a = e[r++]
                            } while (void 0 !== a);
                        else if (void 0 !== o.toArray)
                        do {
                            o = a[i], void 0 !== o && (t.push(a.time), o.toArray(n, n.length)), a = e[r++]
                        } while (void 0 !== a);
                    else
                        do {
                            o = a[i], void 0 !== o && (t.push(a.time), n.push(o)), a = e[r++]
                        } while (void 0 !== a)
                },
                subclip: function(e, t, n, i, r = 30) {
                    const a = e.clone();
                    a.name = t;
                    const o = [];
                    for (let e = 0; e < a.tracks.length; ++e) {
                        const t = a.tracks[e],
                            s = t.getValueSize(),
                            l = [],
                            c = [];
                        for (let e = 0; e < t.times.length; ++e) {
                            const a = t.times[e] * r;
                            if (!(a < n || a >= i)) {
                                l.push(t.times[e]);
                                for (let n = 0; n < s; ++n) c.push(t.values[e * s + n])
                            }
                        }
                        0 !== l.length && (t.times = Bl.convertArray(l, t.times.constructor), t.values = Bl.convertArray(c, t.values.constructor), o.push(t))
                    }
                    a.tracks = o;
                    let s = 1 / 0;
                    for (let e = 0; e < a.tracks.length; ++e) s > a.tracks[e].times[0] && (s = a.tracks[e].times[0]);
                    for (let e = 0; e < a.tracks.length; ++e) a.tracks[e].shift(-1 * s);
                    return a.resetDuration(), a
                },
                makeClipAdditive: function(e, t = 0, n = e, i = 30) {
                    i <= 0 && (i = 30);
                    const r = n.tracks.length,
                        a = t / i;
                    for (let t = 0; t < r; ++t) {
                        const i = n.tracks[t],
                            r = i.ValueTypeName;
                        if ("bool" === r || "string" === r) continue;
                        const o = e.tracks.find((function(e) {
                            return e.name === i.name && e.ValueTypeName === r
                        }));
                        if (void 0 === o) continue;
                        let s = 0;
                        const l = i.getValueSize();
                        i.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (s = l / 3);
                        let c = 0;
                        const u = o.getValueSize();
                        o.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (c = u / 3);
                        const h = i.times.length - 1;
                        let d;
                        if (a <= i.times[0]) {
                            const e = s,
                                t = l - s;
                            d = Bl.arraySlice(i.values, e, t)
                        } else if (a >= i.times[h]) {
                            const e = h * l + s,
                                t = e + l - s;
                            d = Bl.arraySlice(i.values, e, t)
                        } else {
                            const e = i.createInterpolant(),
                                t = s,
                                n = l - s;
                            e.evaluate(a), d = Bl.arraySlice(e.resultBuffer, t, n)
                        }
                        if ("quaternion" === r) {
                            (new Quaternion).fromArray(d).normalize().conjugate().toArray(d)
                        }
                        const p = o.times.length;
                        for (let e = 0; e < p; ++e) {
                            const t = e * u + c;
                            if ("quaternion" === r) Quaternion.multiplyQuaternionsFlat(o.values, t, d, 0, o.values, t);
                            else {
                                const e = u - 2 * c;
                                for (let n = 0; n < e; ++n) o.values[t + n] -= d[n]
                            }
                        }
                    }
                    return e.blendMode = Gr, e
                }
            };
            Object.assign(Interpolant.prototype, {
                evaluate: function(e) {
                    const t = this.parameterPositions;
                    let n = this._cachedIndex,
                        i = t[n],
                        r = t[n - 1];
                    e: {
                        t: {
                            let a;n: {
                                i: if (!(e < i)) {
                                    for (let a = n + 2;;) {
                                        if (void 0 === i) {
                                            if (e < r) break i;
                                            return n = t.length, this._cachedIndex = n, this.afterEnd_(n - 1, e, r)
                                        }
                                        if (n === a) break;
                                        if (r = i, i = t[++n], e < i) break t
                                    }
                                    a = t.length;
                                    break n
                                }if (e >= r) break e; {
                                    const o = t[1];
                                    e < o && (n = 2, r = o);
                                    for (let a = n - 2;;) {
                                        if (void 0 === r) return this._cachedIndex = 0, this.beforeStart_(0, e, i);
                                        if (n === a) break;
                                        if (i = r, r = t[--n - 1], e >= r) break t
                                    }
                                    a = n, n = 0
                                }
                            }
                            for (; n < a;) {
                                const i = n + a >>> 1;
                                e < t[i] ? a = i : n = i + 1
                            }
                            if (i = t[n], r = t[n - 1], void 0 === r) return this._cachedIndex = 0, this.beforeStart_(0, e, i);
                            if (void 0 === i) return n = t.length, this._cachedIndex = n, this.afterEnd_(n - 1, r, e)
                        }
                        this._cachedIndex = n,
                        this.intervalChanged_(n, r, i)
                    }
                    return this.interpolate_(n, r, e, i)
                },
                settings: null,
                DefaultSettings_: {},
                getSettings_: function() {
                    return this.settings || this.DefaultSettings_
                },
                copySampleValue_: function(e) {
                    const t = this.resultBuffer,
                        n = this.sampleValues,
                        i = this.valueSize,
                        r = e * i;
                    for (let e = 0; e !== i; ++e) t[e] = n[r + e];
                    return t
                },
                interpolate_: function() {
                    throw Error("call to abstract method")
                },
                intervalChanged_: function() {}
            }), Object.assign(Interpolant.prototype, {
                beforeStart_: Interpolant.prototype.copySampleValue_,
                afterEnd_: Interpolant.prototype.copySampleValue_
            }), CubicInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
                constructor: CubicInterpolant,
                DefaultSettings_: {
                    endingStart: Dr,
                    endingEnd: Dr
                },
                intervalChanged_: function(e, t, n) {
                    const i = this.parameterPositions;
                    let r = e - 2,
                        a = e + 1,
                        o = i[r],
                        s = i[a];
                    if (void 0 === o) switch (this.getSettings_().endingStart) {
                        case Vr:
                            r = e, o = 2 * t - n;
                            break;
                        case Ur:
                            r = i.length - 2, o = t + i[r] - i[r + 1];
                            break;
                        default:
                            r = e, o = n
                    }
                    if (void 0 === s) switch (this.getSettings_().endingEnd) {
                        case Vr:
                            a = e, s = 2 * n - t;
                            break;
                        case Ur:
                            a = 1, s = n + i[1] - i[0];
                            break;
                        default:
                            a = e - 1, s = t
                    }
                    const l = .5 * (n - t),
                        c = this.valueSize;
                    this._weightPrev = l / (t - o), this._weightNext = l / (s - n), this._offsetPrev = r * c, this._offsetNext = a * c
                },
                interpolate_: function(e, t, n, i) {
                    const r = this.resultBuffer,
                        a = this.sampleValues,
                        o = this.valueSize,
                        s = e * o,
                        l = s - o,
                        c = this._offsetPrev,
                        u = this._offsetNext,
                        h = this._weightPrev,
                        d = this._weightNext,
                        p = (n - t) / (i - t),
                        f = p * p,
                        m = f * p,
                        g = -h * m + 2 * h * f - h * p,
                        y = (1 + h) * m + (-1.5 - 2 * h) * f + (-.5 + h) * p + 1,
                        x = (-1 - d) * m + (1.5 + d) * f + .5 * p,
                        _ = d * m - d * f;
                    for (let e = 0; e !== o; ++e) r[e] = g * a[c + e] + y * a[l + e] + x * a[s + e] + _ * a[u + e];
                    return r
                }
            }), LinearInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
                constructor: LinearInterpolant,
                interpolate_: function(e, t, n, i) {
                    const r = this.resultBuffer,
                        a = this.sampleValues,
                        o = this.valueSize,
                        s = e * o,
                        l = s - o,
                        c = (n - t) / (i - t),
                        u = 1 - c;
                    for (let e = 0; e !== o; ++e) r[e] = a[l + e] * u + a[s + e] * c;
                    return r
                }
            }), DiscreteInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
                constructor: DiscreteInterpolant,
                interpolate_: function(e) {
                    return this.copySampleValue_(e - 1)
                }
            }), Object.assign(KeyframeTrack, {
                toJSON: function(e) {
                    const t = e.constructor;
                    let n;
                    if (void 0 !== t.toJSON) n = t.toJSON(e);
                    else {
                        n = {
                            name: e.name,
                            times: Bl.convertArray(e.times, Array),
                            values: Bl.convertArray(e.values, Array)
                        };
                        const t = e.getInterpolation();
                        t !== e.DefaultInterpolation && (n.interpolation = t)
                    }
                    return n.type = e.ValueTypeName, n
                }
            }), Object.assign(KeyframeTrack.prototype, {
                constructor: KeyframeTrack,
                TimeBufferType: Float32Array,
                ValueBufferType: Float32Array,
                DefaultInterpolation: Rr,
                InterpolantFactoryMethodDiscrete: function(e) {
                    return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), e)
                },
                InterpolantFactoryMethodLinear: function(e) {
                    return new LinearInterpolant(this.times, this.values, this.getValueSize(), e)
                },
                InterpolantFactoryMethodSmooth: function(e) {
                    return new CubicInterpolant(this.times, this.values, this.getValueSize(), e)
                },
                setInterpolation: function(e) {
                    let t;
                    switch (e) {
                        case Br:
                            t = this.InterpolantFactoryMethodDiscrete;
                            break;
                        case Rr:
                            t = this.InterpolantFactoryMethodLinear;
                            break;
                        case Nr:
                            t = this.InterpolantFactoryMethodSmooth
                    }
                    if (void 0 === t) {
                        const t = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                        if (void 0 === this.createInterpolant) {
                            if (e === this.DefaultInterpolation) throw Error(t);
                            this.setInterpolation(this.DefaultInterpolation)
                        }
                        return this
                    }
                    return this.createInterpolant = t, this
                },
                getInterpolation: function() {
                    switch (this.createInterpolant) {
                        case this.InterpolantFactoryMethodDiscrete:
                            return Br;
                        case this.InterpolantFactoryMethodLinear:
                            return Rr;
                        case this.InterpolantFactoryMethodSmooth:
                            return Nr
                    }
                },
                getValueSize: function() {
                    return this.values.length / this.times.length
                },
                shift: function(e) {
                    if (0 !== e) {
                        const t = this.times;
                        for (let n = 0, i = t.length; n !== i; ++n) t[n] += e
                    }
                    return this
                },
                scale: function(e) {
                    if (1 !== e) {
                        const t = this.times;
                        for (let n = 0, i = t.length; n !== i; ++n) t[n] *= e
                    }
                    return this
                },
                trim: function(e, t) {
                    const n = this.times,
                        i = n.length;
                    let r = 0,
                        a = i - 1;
                    for (; r !== i && n[r] < e;) ++r;
                    for (; - 1 !== a && n[a] > t;) --a;
                    if (++a, 0 !== r || a !== i) {
                        r >= a && (a = Math.max(a, 1), r = a - 1);
                        const e = this.getValueSize();
                        this.times = Bl.arraySlice(n, r, a), this.values = Bl.arraySlice(this.values, r * e, a * e)
                    }
                    return this
                },
                validate: function() {
                    let e = !0;
                    const t = this.getValueSize();
                    t - Math.floor(t) != 0 && (e = !1);
                    const n = this.times,
                        i = this.values,
                        r = n.length;
                    0 === r && (e = !1);
                    let a = null;
                    for (let t = 0; t !== r; t++) {
                        const i = n[t];
                        if ("number" == typeof i && isNaN(i)) {
                            e = !1;
                            break
                        }
                        if (null !== a && a > i) {
                            e = !1;
                            break
                        }
                        a = i
                    }
                    if (void 0 !== i && Bl.isTypedArray(i))
                        for (let t = 0, n = i.length; t !== n; ++t) {
                            const n = i[t];
                            if (isNaN(n)) {
                                e = !1;
                                break
                            }
                        }
                    return e
                },
                optimize: function() {
                    const e = Bl.arraySlice(this.times),
                        t = Bl.arraySlice(this.values),
                        n = this.getValueSize(),
                        i = this.getInterpolation() === Nr,
                        r = e.length - 1;
                    let a = 1;
                    for (let o = 1; o < r; ++o) {
                        let r = !1;
                        const s = e[o];
                        if (s !== e[o + 1] && (1 !== o || s !== s[0]))
                            if (i) r = !0;
                            else {
                                const e = o * n,
                                    i = e - n,
                                    a = e + n;
                                for (let o = 0; o !== n; ++o) {
                                    const n = t[e + o];
                                    if (n !== t[i + o] || n !== t[a + o]) {
                                        r = !0;
                                        break
                                    }
                                }
                            }
                        if (r) {
                            if (o !== a) {
                                e[a] = e[o];
                                const i = o * n,
                                    r = a * n;
                                for (let e = 0; e !== n; ++e) t[r + e] = t[i + e]
                            }++a
                        }
                    }
                    if (r > 0) {
                        e[a] = e[r];
                        for (let e = r * n, i = a * n, o = 0; o !== n; ++o) t[i + o] = t[e + o];
                        ++a
                    }
                    return a !== e.length ? (this.times = Bl.arraySlice(e, 0, a), this.values = Bl.arraySlice(t, 0, a * n)) : (this.times = e, this.values = t), this
                },
                clone: function() {
                    const e = Bl.arraySlice(this.times, 0),
                        t = Bl.arraySlice(this.values, 0),
                        n = new(0, this.constructor)(this.name, e, t);
                    return n.createInterpolant = this.createInterpolant, n
                }
            }), BooleanKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
                constructor: BooleanKeyframeTrack,
                ValueTypeName: "bool",
                ValueBufferType: Array,
                DefaultInterpolation: Br,
                InterpolantFactoryMethodLinear: void 0,
                InterpolantFactoryMethodSmooth: void 0
            }), ColorKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
                constructor: ColorKeyframeTrack,
                ValueTypeName: "color"
            }), NumberKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
                constructor: NumberKeyframeTrack,
                ValueTypeName: "number"
            }), QuaternionLinearInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
                constructor: QuaternionLinearInterpolant,
                interpolate_: function(e, t, n, i) {
                    const r = this.resultBuffer,
                        a = this.sampleValues,
                        o = this.valueSize,
                        s = (n - t) / (i - t);
                    let l = e * o;
                    for (let e = l + o; l !== e; l += 4) Quaternion.slerpFlat(r, 0, a, l - o, a, l, s);
                    return r
                }
            }), QuaternionKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
                constructor: QuaternionKeyframeTrack,
                ValueTypeName: "quaternion",
                DefaultInterpolation: Rr,
                InterpolantFactoryMethodLinear: function(e) {
                    return new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), e)
                },
                InterpolantFactoryMethodSmooth: void 0
            }), StringKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
                constructor: StringKeyframeTrack,
                ValueTypeName: "string",
                ValueBufferType: Array,
                DefaultInterpolation: Br,
                InterpolantFactoryMethodLinear: void 0,
                InterpolantFactoryMethodSmooth: void 0
            }), VectorKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
                constructor: VectorKeyframeTrack,
                ValueTypeName: "vector"
            }), Object.assign(AnimationClip, {
                parse: function(e) {
                    const t = [],
                        n = e.tracks,
                        i = 1 / (e.fps || 1);
                    for (let e = 0, r = n.length; e !== r; ++e) t.push(parseKeyframeTrack(n[e]).scale(i));
                    const r = new AnimationClip(e.name, e.duration, t, e.blendMode);
                    return r.uuid = e.uuid, r
                },
                toJSON: function(e) {
                    const t = [],
                        n = e.tracks,
                        i = {
                            name: e.name,
                            duration: e.duration,
                            tracks: t,
                            uuid: e.uuid,
                            blendMode: e.blendMode
                        };
                    for (let e = 0, i = n.length; e !== i; ++e) t.push(KeyframeTrack.toJSON(n[e]));
                    return i
                },
                CreateFromMorphTargetSequence: function(e, t, n, i) {
                    const r = t.length,
                        a = [];
                    for (let e = 0; e < r; e++) {
                        let o = [],
                            s = [];
                        o.push((e + r - 1) % r, e, (e + 1) % r), s.push(0, 1, 0);
                        const l = Bl.getKeyframeOrder(o);
                        o = Bl.sortedArray(o, 1, l), s = Bl.sortedArray(s, 1, l), i || 0 !== o[0] || (o.push(r), s.push(s[0])), a.push(new NumberKeyframeTrack(".morphTargetInfluences[" + t[e].name + "]", o, s).scale(1 / n))
                    }
                    return new AnimationClip(e, -1, a)
                },
                findByName: function(e, t) {
                    let n = e;
                    if (!Array.isArray(e)) {
                        const t = e;
                        n = t.geometry && t.geometry.animations || t.animations
                    }
                    for (let e = 0; e < n.length; e++)
                        if (n[e].name === t) return n[e];
                    return null
                },
                CreateClipsFromMorphTargetSequences: function(e, t, n) {
                    const i = {},
                        r = /^([\w-]*?)([\d]+)$/;
                    for (let t = 0, n = e.length; t < n; t++) {
                        const n = e[t],
                            a = n.name.match(r);
                        if (a && a.length > 1) {
                            const e = a[1];
                            let t = i[e];
                            t || (i[e] = t = []), t.push(n)
                        }
                    }
                    const a = [];
                    for (const e in i) a.push(AnimationClip.CreateFromMorphTargetSequence(e, i[e], t, n));
                    return a
                },
                parseAnimation: function(e, t) {
                    if (!e) return null;
                    const addNonemptyTrack = function(e, t, n, i, r) {
                            if (0 !== n.length) {
                                const a = [],
                                    o = [];
                                Bl.flattenJSON(n, a, o, i), 0 !== a.length && r.push(new e(t, a, o))
                            }
                        },
                        n = [],
                        i = e.name || "default",
                        r = e.fps || 30,
                        a = e.blendMode;
                    let o = e.length || -1;
                    const s = e.hierarchy || [];
                    for (let e = 0; e < s.length; e++) {
                        const i = s[e].keys;
                        if (i && 0 !== i.length)
                            if (i[0].morphTargets) {
                                const e = {};
                                let t;
                                for (t = 0; t < i.length; t++)
                                    if (i[t].morphTargets)
                                        for (let n = 0; n < i[t].morphTargets.length; n++) e[i[t].morphTargets[n]] = -1;
                                for (const r in e) {
                                    const e = [],
                                        a = [];
                                    for (let n = 0; n !== i[t].morphTargets.length; ++n) {
                                        const n = i[t];
                                        e.push(n.time), a.push(n.morphTarget === r ? 1 : 0)
                                    }
                                    n.push(new NumberKeyframeTrack(".morphTargetInfluence[" + r + "]", e, a))
                                }
                                o = e.length * (r || 1)
                            } else {
                                const r = ".bones[" + t[e].name + "]";
                                addNonemptyTrack(VectorKeyframeTrack, r + ".position", i, "pos", n), addNonemptyTrack(QuaternionKeyframeTrack, r + ".quaternion", i, "rot", n), addNonemptyTrack(VectorKeyframeTrack, r + ".scale", i, "scl", n)
                            }
                    }
                    if (0 === n.length) return null;
                    return new AnimationClip(i, o, n, a)
                }
            }), Object.assign(AnimationClip.prototype, {
                resetDuration: function() {
                    let e = 0;
                    for (let t = 0, n = this.tracks.length; t !== n; ++t) {
                        const n = this.tracks[t];
                        e = Math.max(e, n.times[n.times.length - 1])
                    }
                    return this.duration = e, this
                },
                trim: function() {
                    for (let e = 0; e < this.tracks.length; e++) this.tracks[e].trim(0, this.duration);
                    return this
                },
                validate: function() {
                    let e = !0;
                    for (let t = 0; t < this.tracks.length; t++) e = e && this.tracks[t].validate();
                    return e
                },
                optimize: function() {
                    for (let e = 0; e < this.tracks.length; e++) this.tracks[e].optimize();
                    return this
                },
                clone: function() {
                    const e = [];
                    for (let t = 0; t < this.tracks.length; t++) e.push(this.tracks[t].clone());
                    return new AnimationClip(this.name, this.duration, e, this.blendMode)
                },
                toJSON: function() {
                    return AnimationClip.toJSON(this)
                }
            });
            const Rl = {
                    enabled: !1,
                    files: {},
                    add: function(e, t) {
                        !1 !== this.enabled && (this.files[e] = t)
                    },
                    get: function(e) {
                        if (!1 !== this.enabled) return this.files[e]
                    },
                    remove: function(e) {
                        delete this.files[e]
                    },
                    clear: function() {
                        this.files = {}
                    }
                },
                Nl = new LoadingManager;
            Object.assign(Loader.prototype, {
                load: function() {},
                loadAsync: function(e, t) {
                    const n = this;
                    return new Promise((function(i, r) {
                        n.load(e, i, t, r)
                    }))
                },
                parse: function() {},
                setCrossOrigin: function(e) {
                    return this.crossOrigin = e, this
                },
                setWithCredentials: function(e) {
                    return this.withCredentials = e, this
                },
                setPath: function(e) {
                    return this.path = e, this
                },
                setResourcePath: function(e) {
                    return this.resourcePath = e, this
                },
                setRequestHeader: function(e) {
                    return this.requestHeader = e, this
                }
            });
            const Dl = {};
            FileLoader.prototype = Object.assign(Object.create(Loader.prototype), {
                constructor: FileLoader,
                load: function(e, t, n, i) {
                    void 0 === e && (e = ""), void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e);
                    const r = this,
                        a = Rl.get(e);
                    if (void 0 !== a) return r.manager.itemStart(e), setTimeout((function() {
                        t && t(a), r.manager.itemEnd(e)
                    }), 0), a;
                    if (void 0 !== Dl[e]) return void Dl[e].push({
                        onLoad: t,
                        onProgress: n,
                        onError: i
                    });
                    const o = e.match(/^data:(.*?)(;base64)?,(.*)$/);
                    let s;
                    if (o) {
                        const n = o[1],
                            a = !!o[2];
                        let s = o[3];
                        s = decodeURIComponent(s), a && (s = atob(s));
                        try {
                            let i;
                            const a = (this.responseType || "").toLowerCase();
                            switch (a) {
                                case "arraybuffer":
                                case "blob":
                                    const e = new Uint8Array(s.length);
                                    for (let t = 0; t < s.length; t++) e[t] = s.charCodeAt(t);
                                    i = "blob" === a ? new Blob([e.buffer], {
                                        type: n
                                    }) : e.buffer;
                                    break;
                                case "document":
                                    const t = new DOMParser;
                                    i = t.parseFromString(s, n);
                                    break;
                                case "json":
                                    i = JSON.parse(s);
                                    break;
                                default:
                                    i = s
                            }
                            setTimeout((function() {
                                t && t(i), r.manager.itemEnd(e)
                            }), 0)
                        } catch (t) {
                            setTimeout((function() {
                                i && i(t), r.manager.itemError(e), r.manager.itemEnd(e)
                            }), 0)
                        }
                    } else {
                        Dl[e] = [], Dl[e].push({
                            onLoad: t,
                            onProgress: n,
                            onError: i
                        }), s = new XMLHttpRequest, s.open("GET", e, !0), s.addEventListener("load", (function(t) {
                            const n = this.response,
                                i = Dl[e];
                            if (delete Dl[e], 200 === this.status || 0 === this.status) {
                                this.status, Rl.add(e, n);
                                for (let e = 0, t = i.length; e < t; e++) {
                                    const t = i[e];
                                    t.onLoad && t.onLoad(n)
                                }
                                r.manager.itemEnd(e)
                            } else {
                                for (let e = 0, n = i.length; e < n; e++) {
                                    const n = i[e];
                                    n.onError && n.onError(t)
                                }
                                r.manager.itemError(e), r.manager.itemEnd(e)
                            }
                        }), !1), s.addEventListener("progress", (function(t) {
                            const n = Dl[e];
                            for (let e = 0, i = n.length; e < i; e++) {
                                const i = n[e];
                                i.onProgress && i.onProgress(t)
                            }
                        }), !1), s.addEventListener("error", (function(t) {
                            const n = Dl[e];
                            delete Dl[e];
                            for (let e = 0, i = n.length; e < i; e++) {
                                const i = n[e];
                                i.onError && i.onError(t)
                            }
                            r.manager.itemError(e), r.manager.itemEnd(e)
                        }), !1), s.addEventListener("abort", (function(t) {
                            const n = Dl[e];
                            delete Dl[e];
                            for (let e = 0, i = n.length; e < i; e++) {
                                const i = n[e];
                                i.onError && i.onError(t)
                            }
                            r.manager.itemError(e), r.manager.itemEnd(e)
                        }), !1), void 0 !== this.responseType && (s.responseType = this.responseType), void 0 !== this.withCredentials && (s.withCredentials = this.withCredentials), s.overrideMimeType && s.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain");
                        for (const e in this.requestHeader) s.setRequestHeader(e, this.requestHeader[e]);
                        s.send(null)
                    }
                    return r.manager.itemStart(e), s
                },
                setResponseType: function(e) {
                    return this.responseType = e, this
                },
                setMimeType: function(e) {
                    return this.mimeType = e, this
                }
            }), AnimationLoader.prototype = Object.assign(Object.create(Loader.prototype), {
                constructor: AnimationLoader,
                load: function(e, t, n, i) {
                    const r = this,
                        a = new FileLoader(r.manager);
                    a.setPath(r.path), a.setRequestHeader(r.requestHeader), a.setWithCredentials(r.withCredentials), a.load(e, (function(n) {
                        try {
                            t(r.parse(JSON.parse(n)))
                        } catch (t) {
                            i && i(t), r.manager.itemError(e)
                        }
                    }), n, i)
                },
                parse: function(e) {
                    const t = [];
                    for (let n = 0; n < e.length; n++) {
                        const i = AnimationClip.parse(e[n]);
                        t.push(i)
                    }
                    return t
                }
            }), CompressedTextureLoader.prototype = Object.assign(Object.create(Loader.prototype), {
                constructor: CompressedTextureLoader,
                load: function(e, t, n, i) {
                    function loadTexture(c) {
                        s.load(e[c], (function(e) {
                            const n = r.parse(e, !0);
                            a[c] = {
                                width: n.width,
                                height: n.height,
                                format: n.format,
                                mipmaps: n.mipmaps
                            }, l += 1, 6 === l && (1 === n.mipmapCount && (o.minFilter = fi), o.image = a, o.format = n.format, o.needsUpdate = !0, t && t(o))
                        }), n, i)
                    }
                    const r = this,
                        a = [],
                        o = new CompressedTexture,
                        s = new FileLoader(this.manager);
                    s.setPath(this.path), s.setResponseType("arraybuffer"), s.setRequestHeader(this.requestHeader), s.setWithCredentials(r.withCredentials);
                    let l = 0;
                    if (Array.isArray(e))
                        for (let t = 0, n = e.length; t < n; ++t) loadTexture(t);
                    else s.load(e, (function(e) {
                        const n = r.parse(e, !0);
                        if (n.isCubemap) {
                            const e = n.mipmaps.length / n.mipmapCount;
                            for (let t = 0; t < e; t++) {
                                a[t] = {
                                    mipmaps: []
                                };
                                for (let e = 0; e < n.mipmapCount; e++) a[t].mipmaps.push(n.mipmaps[t * n.mipmapCount + e]), a[t].format = n.format, a[t].width = n.width, a[t].height = n.height
                            }
                            o.image = a
                        } else o.image.width = n.width, o.image.height = n.height, o.mipmaps = n.mipmaps;
                        1 === n.mipmapCount && (o.minFilter = fi), o.format = n.format, o.needsUpdate = !0, t && t(o)
                    }), n, i);
                    return o
                }
            }), ImageLoader.prototype = Object.assign(Object.create(Loader.prototype), {
                constructor: ImageLoader,
                load: function(e, t, n, i) {
                    function onImageLoad() {
                        o.removeEventListener("load", onImageLoad, !1), o.removeEventListener("error", onImageError, !1), Rl.add(e, this), t && t(this), r.manager.itemEnd(e)
                    }

                    function onImageError(t) {
                        o.removeEventListener("load", onImageLoad, !1), o.removeEventListener("error", onImageError, !1), i && i(t), r.manager.itemError(e), r.manager.itemEnd(e)
                    }
                    void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e);
                    const r = this,
                        a = Rl.get(e);
                    if (void 0 !== a) return r.manager.itemStart(e), setTimeout((function() {
                        t && t(a), r.manager.itemEnd(e)
                    }), 0), a;
                    const o = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
                    return o.addEventListener("load", onImageLoad, !1), o.addEventListener("error", onImageError, !1), "data:" !== e.substr(0, 5) && void 0 !== this.crossOrigin && (o.crossOrigin = this.crossOrigin), r.manager.itemStart(e), o.src = e, o
                }
            }), CubeTextureLoader.prototype = Object.assign(Object.create(Loader.prototype), {
                constructor: CubeTextureLoader,
                load: function(e, t, n, i) {
                    function loadTexture(n) {
                        a.load(e[n], (function(e) {
                            r.images[n] = e, o++, 6 === o && (r.needsUpdate = !0, t && t(r))
                        }), void 0, i)
                    }
                    const r = new CubeTexture,
                        a = new ImageLoader(this.manager);
                    a.setCrossOrigin(this.crossOrigin), a.setPath(this.path);
                    let o = 0;
                    for (let t = 0; t < e.length; ++t) loadTexture(t);
                    return r
                }
            }), DataTextureLoader.prototype = Object.assign(Object.create(Loader.prototype), {
                constructor: DataTextureLoader,
                load: function(e, t, n, i) {
                    const r = this,
                        a = new DataTexture,
                        o = new FileLoader(this.manager);
                    return o.setResponseType("arraybuffer"), o.setRequestHeader(this.requestHeader), o.setPath(this.path), o.setWithCredentials(r.withCredentials), o.load(e, (function(e) {
                        const n = r.parse(e);
                        n && (void 0 !== n.image ? a.image = n.image : void 0 !== n.data && (a.image.width = n.width, a.image.height = n.height, a.image.data = n.data), a.wrapS = void 0 !== n.wrapS ? n.wrapS : si, a.wrapT = void 0 !== n.wrapT ? n.wrapT : si, a.magFilter = void 0 !== n.magFilter ? n.magFilter : fi, a.minFilter = void 0 !== n.minFilter ? n.minFilter : fi, a.anisotropy = void 0 !== n.anisotropy ? n.anisotropy : 1, void 0 !== n.format && (a.format = n.format), void 0 !== n.type && (a.type = n.type), void 0 !== n.mipmaps && (a.mipmaps = n.mipmaps, a.minFilter = vi), 1 === n.mipmapCount && (a.minFilter = fi), a.needsUpdate = !0, t && t(a, n))
                    }), n, i), a
                }
            }), TextureLoader.prototype = Object.assign(Object.create(Loader.prototype), {
                constructor: TextureLoader,
                load: function(e, t, n, i) {
                    const r = new Texture,
                        a = new ImageLoader(this.manager);
                    return a.setCrossOrigin(this.crossOrigin), a.setPath(this.path), a.load(e, (function(n) {
                        r.image = n;
                        const i = e.search(/\.jpe?g($|\?)/i) > 0 || 0 === e.search(/^data\:image\/jpeg/);
                        r.format = i ? Fi : Oi, r.needsUpdate = !0, void 0 !== t && t(r)
                    }), n, i), r
                }
            }), Object.assign(Curve.prototype, {
                getPoint: function() {
                    return null
                },
                getPointAt: function(e, t) {
                    const n = this.getUtoTmapping(e);
                    return this.getPoint(n, t)
                },
                getPoints: function(e = 5) {
                    const t = [];
                    for (let n = 0; n <= e; n++) t.push(this.getPoint(n / e));
                    return t
                },
                getSpacedPoints: function(e = 5) {
                    const t = [];
                    for (let n = 0; n <= e; n++) t.push(this.getPointAt(n / e));
                    return t
                },
                getLength: function() {
                    const e = this.getLengths();
                    return e[e.length - 1]
                },
                getLengths: function(e) {
                    if (void 0 === e && (e = this.arcLengthDivisions), this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate) return this.cacheArcLengths;
                    this.needsUpdate = !1;
                    const t = [];
                    let n, i = this.getPoint(0),
                        r = 0;
                    t.push(0);
                    for (let a = 1; a <= e; a++) n = this.getPoint(a / e), r += n.distanceTo(i), t.push(r), i = n;
                    return this.cacheArcLengths = t, t
                },
                updateArcLengths: function() {
                    this.needsUpdate = !0, this.getLengths()
                },
                getUtoTmapping: function(e, t) {
                    const n = this.getLengths();
                    let i = 0;
                    const r = n.length;
                    let a;
                    a = t || e * n[r - 1];
                    let o, s = 0,
                        l = r - 1;
                    for (; s <= l;)
                        if (i = Math.floor(s + (l - s) / 2), o = n[i] - a, o < 0) s = i + 1;
                        else {
                            if (!(o > 0)) {
                                l = i;
                                break
                            }
                            l = i - 1
                        }
                    if (i = l, n[i] === a) return i / (r - 1);
                    const c = n[i];
                    return (i + (a - c) / (n[i + 1] - c)) / (r - 1)
                },
                getTangent: function(e, t) {
                    const n = 1e-4;
                    let i = e - n,
                        r = e + n;
                    i < 0 && (i = 0), r > 1 && (r = 1);
                    const a = this.getPoint(i),
                        o = this.getPoint(r),
                        s = t || (a.isVector2 ? new Vector2 : new Vector3);
                    return s.copy(o).sub(a).normalize(), s
                },
                getTangentAt: function(e, t) {
                    const n = this.getUtoTmapping(e);
                    return this.getTangent(n, t)
                },
                computeFrenetFrames: function(e, t) {
                    const n = new Vector3,
                        i = [],
                        r = [],
                        a = [],
                        o = new Vector3,
                        s = new Matrix4;
                    for (let t = 0; t <= e; t++) {
                        const n = t / e;
                        i[t] = this.getTangentAt(n, new Vector3), i[t].normalize()
                    }
                    r[0] = new Vector3, a[0] = new Vector3;
                    let l = Number.MAX_VALUE;
                    const c = Math.abs(i[0].x),
                        u = Math.abs(i[0].y),
                        h = Math.abs(i[0].z);
                    c <= l && (l = c, n.set(1, 0, 0)), u <= l && (l = u, n.set(0, 1, 0)), h <= l && n.set(0, 0, 1), o.crossVectors(i[0], n).normalize(), r[0].crossVectors(i[0], o), a[0].crossVectors(i[0], r[0]);
                    for (let t = 1; t <= e; t++) {
                        if (r[t] = r[t - 1].clone(), a[t] = a[t - 1].clone(), o.crossVectors(i[t - 1], i[t]), o.length() > Number.EPSILON) {
                            o.normalize();
                            const e = Math.acos(Fa.clamp(i[t - 1].dot(i[t]), -1, 1));
                            r[t].applyMatrix4(s.makeRotationAxis(o, e))
                        }
                        a[t].crossVectors(i[t], r[t])
                    }
                    if (!0 === t) {
                        let t = Math.acos(Fa.clamp(r[0].dot(r[e]), -1, 1));
                        t /= e, i[0].dot(o.crossVectors(r[0], r[e])) > 0 && (t = -t);
                        for (let n = 1; n <= e; n++) r[n].applyMatrix4(s.makeRotationAxis(i[n], t * n)), a[n].crossVectors(i[n], r[n])
                    }
                    return {
                        tangents: i,
                        normals: r,
                        binormals: a
                    }
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(e) {
                    return this.arcLengthDivisions = e.arcLengthDivisions, this
                },
                toJSON: function() {
                    const e = {
                        metadata: {
                            version: 4.5,
                            type: "Curve",
                            generator: "Curve.toJSON"
                        }
                    };
                    return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e
                },
                fromJSON: function(e) {
                    return this.arcLengthDivisions = e.arcLengthDivisions, this
                }
            }), EllipseCurve.prototype = Object.create(Curve.prototype), EllipseCurve.prototype.constructor = EllipseCurve, EllipseCurve.prototype.isEllipseCurve = !0, EllipseCurve.prototype.getPoint = function(e, t) {
                const n = t || new Vector2,
                    i = 2 * Math.PI;
                let r = this.aEndAngle - this.aStartAngle;
                const a = Math.abs(r) < Number.EPSILON;
                for (; r < 0;) r += i;
                for (; r > i;) r -= i;
                r < Number.EPSILON && (r = a ? 0 : i), !0 !== this.aClockwise || a || (r === i ? r = -i : r -= i);
                const o = this.aStartAngle + e * r;
                let s = this.aX + this.xRadius * Math.cos(o),
                    l = this.aY + this.yRadius * Math.sin(o);
                if (0 !== this.aRotation) {
                    const e = Math.cos(this.aRotation),
                        t = Math.sin(this.aRotation),
                        n = s - this.aX,
                        i = l - this.aY;
                    s = n * e - i * t + this.aX, l = n * t + i * e + this.aY
                }
                return n.set(s, l)
            }, EllipseCurve.prototype.copy = function(e) {
                return Curve.prototype.copy.call(this, e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this
            }, EllipseCurve.prototype.toJSON = function() {
                const e = Curve.prototype.toJSON.call(this);
                return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e
            }, EllipseCurve.prototype.fromJSON = function(e) {
                return Curve.prototype.fromJSON.call(this, e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this
            }, ArcCurve.prototype = Object.create(EllipseCurve.prototype), ArcCurve.prototype.constructor = ArcCurve, ArcCurve.prototype.isArcCurve = !0;
            const Vl = new Vector3,
                Ul = new CubicPoly,
                zl = new CubicPoly,
                Gl = new CubicPoly;
            CatmullRomCurve3.prototype = Object.create(Curve.prototype), CatmullRomCurve3.prototype.constructor = CatmullRomCurve3, CatmullRomCurve3.prototype.isCatmullRomCurve3 = !0, CatmullRomCurve3.prototype.getPoint = function(e, t = new Vector3) {
                const n = t,
                    i = this.points,
                    r = i.length,
                    a = (r - (this.closed ? 0 : 1)) * e;
                let o, s, l = Math.floor(a),
                    c = a - l;
                this.closed ? l += l > 0 ? 0 : (Math.floor(Math.abs(l) / r) + 1) * r : 0 === c && l === r - 1 && (l = r - 2, c = 1), this.closed || l > 0 ? o = i[(l - 1) % r] : (Vl.subVectors(i[0], i[1]).add(i[0]), o = Vl);
                const u = i[l % r],
                    h = i[(l + 1) % r];
                if (this.closed || l + 2 < r ? s = i[(l + 2) % r] : (Vl.subVectors(i[r - 1], i[r - 2]).add(i[r - 1]), s = Vl), "centripetal" === this.curveType || "chordal" === this.curveType) {
                    const e = "chordal" === this.curveType ? .5 : .25;
                    let t = Math.pow(o.distanceToSquared(u), e),
                        n = Math.pow(u.distanceToSquared(h), e),
                        i = Math.pow(h.distanceToSquared(s), e);
                    n < 1e-4 && (n = 1), t < 1e-4 && (t = n), i < 1e-4 && (i = n), Ul.initNonuniformCatmullRom(o.x, u.x, h.x, s.x, t, n, i), zl.initNonuniformCatmullRom(o.y, u.y, h.y, s.y, t, n, i), Gl.initNonuniformCatmullRom(o.z, u.z, h.z, s.z, t, n, i)
                } else "catmullrom" === this.curveType && (Ul.initCatmullRom(o.x, u.x, h.x, s.x, this.tension), zl.initCatmullRom(o.y, u.y, h.y, s.y, this.tension), Gl.initCatmullRom(o.z, u.z, h.z, s.z, this.tension));
                return n.set(Ul.calc(c), zl.calc(c), Gl.calc(c)), n
            }, CatmullRomCurve3.prototype.copy = function(e) {
                Curve.prototype.copy.call(this, e), this.points = [];
                for (let t = 0, n = e.points.length; t < n; t++) {
                    const n = e.points[t];
                    this.points.push(n.clone())
                }
                return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this
            }, CatmullRomCurve3.prototype.toJSON = function() {
                const e = Curve.prototype.toJSON.call(this);
                e.points = [];
                for (let t = 0, n = this.points.length; t < n; t++) {
                    const n = this.points[t];
                    e.points.push(n.toArray())
                }
                return e.closed = this.closed, e.curveType = this.curveType, e.tension = this.tension, e
            }, CatmullRomCurve3.prototype.fromJSON = function(e) {
                Curve.prototype.fromJSON.call(this, e), this.points = [];
                for (let t = 0, n = e.points.length; t < n; t++) {
                    const n = e.points[t];
                    this.points.push((new Vector3).fromArray(n))
                }
                return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this
            }, CubicBezierCurve.prototype = Object.create(Curve.prototype), CubicBezierCurve.prototype.constructor = CubicBezierCurve, CubicBezierCurve.prototype.isCubicBezierCurve = !0, CubicBezierCurve.prototype.getPoint = function(e, t = new Vector2) {
                const n = t,
                    i = this.v0,
                    r = this.v1,
                    a = this.v2,
                    o = this.v3;
                return n.set(CubicBezier(e, i.x, r.x, a.x, o.x), CubicBezier(e, i.y, r.y, a.y, o.y)), n
            }, CubicBezierCurve.prototype.copy = function(e) {
                return Curve.prototype.copy.call(this, e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this
            }, CubicBezierCurve.prototype.toJSON = function() {
                const e = Curve.prototype.toJSON.call(this);
                return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e
            }, CubicBezierCurve.prototype.fromJSON = function(e) {
                return Curve.prototype.fromJSON.call(this, e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this
            }, CubicBezierCurve3.prototype = Object.create(Curve.prototype), CubicBezierCurve3.prototype.constructor = CubicBezierCurve3, CubicBezierCurve3.prototype.isCubicBezierCurve3 = !0, CubicBezierCurve3.prototype.getPoint = function(e, t = new Vector3) {
                const n = t,
                    i = this.v0,
                    r = this.v1,
                    a = this.v2,
                    o = this.v3;
                return n.set(CubicBezier(e, i.x, r.x, a.x, o.x), CubicBezier(e, i.y, r.y, a.y, o.y), CubicBezier(e, i.z, r.z, a.z, o.z)), n
            }, CubicBezierCurve3.prototype.copy = function(e) {
                return Curve.prototype.copy.call(this, e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this
            }, CubicBezierCurve3.prototype.toJSON = function() {
                const e = Curve.prototype.toJSON.call(this);
                return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e
            }, CubicBezierCurve3.prototype.fromJSON = function(e) {
                return Curve.prototype.fromJSON.call(this, e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this
            }, LineCurve.prototype = Object.create(Curve.prototype), LineCurve.prototype.constructor = LineCurve, LineCurve.prototype.isLineCurve = !0, LineCurve.prototype.getPoint = function(e, t = new Vector2) {
                const n = t;
                return 1 === e ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)), n
            }, LineCurve.prototype.getPointAt = function(e, t) {
                return this.getPoint(e, t)
            }, LineCurve.prototype.getTangent = function(e, t) {
                const n = t || new Vector2;
                return n.copy(this.v2).sub(this.v1).normalize(), n
            }, LineCurve.prototype.copy = function(e) {
                return Curve.prototype.copy.call(this, e), this.v1.copy(e.v1), this.v2.copy(e.v2), this
            }, LineCurve.prototype.toJSON = function() {
                const e = Curve.prototype.toJSON.call(this);
                return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
            }, LineCurve.prototype.fromJSON = function(e) {
                return Curve.prototype.fromJSON.call(this, e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
            }, LineCurve3.prototype = Object.create(Curve.prototype), LineCurve3.prototype.constructor = LineCurve3, LineCurve3.prototype.isLineCurve3 = !0, LineCurve3.prototype.getPoint = function(e, t = new Vector3) {
                const n = t;
                return 1 === e ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)), n
            }, LineCurve3.prototype.getPointAt = function(e, t) {
                return this.getPoint(e, t)
            }, LineCurve3.prototype.copy = function(e) {
                return Curve.prototype.copy.call(this, e), this.v1.copy(e.v1), this.v2.copy(e.v2), this
            }, LineCurve3.prototype.toJSON = function() {
                const e = Curve.prototype.toJSON.call(this);
                return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
            }, LineCurve3.prototype.fromJSON = function(e) {
                return Curve.prototype.fromJSON.call(this, e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
            }, QuadraticBezierCurve.prototype = Object.create(Curve.prototype), QuadraticBezierCurve.prototype.constructor = QuadraticBezierCurve, QuadraticBezierCurve.prototype.isQuadraticBezierCurve = !0, QuadraticBezierCurve.prototype.getPoint = function(e, t = new Vector2) {
                const n = t,
                    i = this.v0,
                    r = this.v1,
                    a = this.v2;
                return n.set(QuadraticBezier(e, i.x, r.x, a.x), QuadraticBezier(e, i.y, r.y, a.y)), n
            }, QuadraticBezierCurve.prototype.copy = function(e) {
                return Curve.prototype.copy.call(this, e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this
            }, QuadraticBezierCurve.prototype.toJSON = function() {
                const e = Curve.prototype.toJSON.call(this);
                return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
            }, QuadraticBezierCurve.prototype.fromJSON = function(e) {
                return Curve.prototype.fromJSON.call(this, e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
            }, QuadraticBezierCurve3.prototype = Object.create(Curve.prototype), QuadraticBezierCurve3.prototype.constructor = QuadraticBezierCurve3, QuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = !0, QuadraticBezierCurve3.prototype.getPoint = function(e, t = new Vector3) {
                const n = t,
                    i = this.v0,
                    r = this.v1,
                    a = this.v2;
                return n.set(QuadraticBezier(e, i.x, r.x, a.x), QuadraticBezier(e, i.y, r.y, a.y), QuadraticBezier(e, i.z, r.z, a.z)), n
            }, QuadraticBezierCurve3.prototype.copy = function(e) {
                return Curve.prototype.copy.call(this, e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this
            }, QuadraticBezierCurve3.prototype.toJSON = function() {
                const e = Curve.prototype.toJSON.call(this);
                return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
            }, QuadraticBezierCurve3.prototype.fromJSON = function(e) {
                return Curve.prototype.fromJSON.call(this, e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
            }, SplineCurve.prototype = Object.create(Curve.prototype), SplineCurve.prototype.constructor = SplineCurve, SplineCurve.prototype.isSplineCurve = !0, SplineCurve.prototype.getPoint = function(e, t = new Vector2) {
                const n = t,
                    i = this.points,
                    r = (i.length - 1) * e,
                    a = Math.floor(r),
                    o = r - a,
                    s = i[0 === a ? a : a - 1],
                    l = i[a],
                    c = i[a > i.length - 2 ? i.length - 1 : a + 1],
                    u = i[a > i.length - 3 ? i.length - 1 : a + 2];
                return n.set(CatmullRom(o, s.x, l.x, c.x, u.x), CatmullRom(o, s.y, l.y, c.y, u.y)), n
            }, SplineCurve.prototype.copy = function(e) {
                Curve.prototype.copy.call(this, e), this.points = [];
                for (let t = 0, n = e.points.length; t < n; t++) {
                    const n = e.points[t];
                    this.points.push(n.clone())
                }
                return this
            }, SplineCurve.prototype.toJSON = function() {
                const e = Curve.prototype.toJSON.call(this);
                e.points = [];
                for (let t = 0, n = this.points.length; t < n; t++) {
                    const n = this.points[t];
                    e.points.push(n.toArray())
                }
                return e
            }, SplineCurve.prototype.fromJSON = function(e) {
                Curve.prototype.fromJSON.call(this, e), this.points = [];
                for (let t = 0, n = e.points.length; t < n; t++) {
                    const n = e.points[t];
                    this.points.push((new Vector2).fromArray(n))
                }
                return this
            }, l = Object.freeze({
                __proto__: null,
                ArcCurve,
                CatmullRomCurve3,
                CubicBezierCurve,
                CubicBezierCurve3,
                EllipseCurve,
                LineCurve,
                LineCurve3,
                QuadraticBezierCurve,
                QuadraticBezierCurve3,
                SplineCurve
            }), CurvePath.prototype = Object.assign(Object.create(Curve.prototype), {
                constructor: CurvePath,
                add: function(e) {
                    this.curves.push(e)
                },
                closePath: function() {
                    const e = this.curves[0].getPoint(0),
                        t = this.curves[this.curves.length - 1].getPoint(1);
                    e.equals(t) || this.curves.push(new LineCurve(t, e))
                },
                getPoint: function(e) {
                    const t = e * this.getLength(),
                        n = this.getCurveLengths();
                    let i = 0;
                    for (; i < n.length;) {
                        if (n[i] >= t) {
                            const e = n[i] - t,
                                r = this.curves[i],
                                a = r.getLength(),
                                o = 0 === a ? 0 : 1 - e / a;
                            return r.getPointAt(o)
                        }
                        i++
                    }
                    return null
                },
                getLength: function() {
                    const e = this.getCurveLengths();
                    return e[e.length - 1]
                },
                updateArcLengths: function() {
                    this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths()
                },
                getCurveLengths: function() {
                    if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
                    const e = [];
                    let t = 0;
                    for (let n = 0, i = this.curves.length; n < i; n++) t += this.curves[n].getLength(), e.push(t);
                    return this.cacheLengths = e, e
                },
                getSpacedPoints: function(e = 40) {
                    const t = [];
                    for (let n = 0; n <= e; n++) t.push(this.getPoint(n / e));
                    return this.autoClose && t.push(t[0]), t
                },
                getPoints: function(e = 12) {
                    const t = [];
                    let n;
                    for (let i = 0, r = this.curves; i < r.length; i++) {
                        const a = r[i],
                            o = a && a.isEllipseCurve ? 2 * e : a && (a.isLineCurve || a.isLineCurve3) ? 1 : a && a.isSplineCurve ? e * a.points.length : e,
                            s = a.getPoints(o);
                        for (let e = 0; e < s.length; e++) {
                            const i = s[e];
                            n && n.equals(i) || (t.push(i), n = i)
                        }
                    }
                    return this.autoClose && t.length > 1 && !t[t.length - 1].equals(t[0]) && t.push(t[0]), t
                },
                copy: function(e) {
                    Curve.prototype.copy.call(this, e), this.curves = [];
                    for (let t = 0, n = e.curves.length; t < n; t++) {
                        const n = e.curves[t];
                        this.curves.push(n.clone())
                    }
                    return this.autoClose = e.autoClose, this
                },
                toJSON: function() {
                    const e = Curve.prototype.toJSON.call(this);
                    e.autoClose = this.autoClose, e.curves = [];
                    for (let t = 0, n = this.curves.length; t < n; t++) {
                        const n = this.curves[t];
                        e.curves.push(n.toJSON())
                    }
                    return e
                },
                fromJSON: function(e) {
                    Curve.prototype.fromJSON.call(this, e), this.autoClose = e.autoClose, this.curves = [];
                    for (let t = 0, n = e.curves.length; t < n; t++) {
                        const n = e.curves[t];
                        this.curves.push((new l[n.type]).fromJSON(n))
                    }
                    return this
                }
            }), Path.prototype = Object.assign(Object.create(CurvePath.prototype), {
                constructor: Path,
                setFromPoints: function(e) {
                    this.moveTo(e[0].x, e[0].y);
                    for (let t = 1, n = e.length; t < n; t++) this.lineTo(e[t].x, e[t].y);
                    return this
                },
                moveTo: function(e, t) {
                    return this.currentPoint.set(e, t), this
                },
                lineTo: function(e, t) {
                    const n = new LineCurve(this.currentPoint.clone(), new Vector2(e, t));
                    return this.curves.push(n), this.currentPoint.set(e, t), this
                },
                quadraticCurveTo: function(e, t, n, i) {
                    const r = new QuadraticBezierCurve(this.currentPoint.clone(), new Vector2(e, t), new Vector2(n, i));
                    return this.curves.push(r), this.currentPoint.set(n, i), this
                },
                bezierCurveTo: function(e, t, n, i, r, a) {
                    const o = new CubicBezierCurve(this.currentPoint.clone(), new Vector2(e, t), new Vector2(n, i), new Vector2(r, a));
                    return this.curves.push(o), this.currentPoint.set(r, a), this
                },
                splineThru: function(e) {
                    const t = new SplineCurve([this.currentPoint.clone()].concat(e));
                    return this.curves.push(t), this.currentPoint.copy(e[e.length - 1]), this
                },
                arc: function(e, t, n, i, r, a) {
                    const o = this.currentPoint.x,
                        s = this.currentPoint.y;
                    return this.absarc(e + o, t + s, n, i, r, a), this
                },
                absarc: function(e, t, n, i, r, a) {
                    return this.absellipse(e, t, n, n, i, r, a), this
                },
                ellipse: function(e, t, n, i, r, a, o, s) {
                    const l = this.currentPoint.x,
                        c = this.currentPoint.y;
                    return this.absellipse(e + l, t + c, n, i, r, a, o, s), this
                },
                absellipse: function(e, t, n, i, r, a, o, s) {
                    const l = new EllipseCurve(e, t, n, i, r, a, o, s);
                    if (this.curves.length > 0) {
                        const e = l.getPoint(0);
                        e.equals(this.currentPoint) || this.lineTo(e.x, e.y)
                    }
                    this.curves.push(l);
                    const c = l.getPoint(1);
                    return this.currentPoint.copy(c), this
                },
                copy: function(e) {
                    return CurvePath.prototype.copy.call(this, e), this.currentPoint.copy(e.currentPoint), this
                },
                toJSON: function() {
                    const e = CurvePath.prototype.toJSON.call(this);
                    return e.currentPoint = this.currentPoint.toArray(), e
                },
                fromJSON: function(e) {
                    return CurvePath.prototype.fromJSON.call(this, e), this.currentPoint.fromArray(e.currentPoint), this
                }
            }), Shape.prototype = Object.assign(Object.create(Path.prototype), {
                constructor: Shape,
                getPointsHoles: function(e) {
                    const t = [];
                    for (let n = 0, i = this.holes.length; n < i; n++) t[n] = this.holes[n].getPoints(e);
                    return t
                },
                extractPoints: function(e) {
                    return {
                        shape: this.getPoints(e),
                        holes: this.getPointsHoles(e)
                    }
                },
                copy: function(e) {
                    Path.prototype.copy.call(this, e), this.holes = [];
                    for (let t = 0, n = e.holes.length; t < n; t++) {
                        const n = e.holes[t];
                        this.holes.push(n.clone())
                    }
                    return this
                },
                toJSON: function() {
                    const e = Path.prototype.toJSON.call(this);
                    e.uuid = this.uuid, e.holes = [];
                    for (let t = 0, n = this.holes.length; t < n; t++) {
                        const n = this.holes[t];
                        e.holes.push(n.toJSON())
                    }
                    return e
                },
                fromJSON: function(e) {
                    Path.prototype.fromJSON.call(this, e), this.uuid = e.uuid, this.holes = [];
                    for (let t = 0, n = e.holes.length; t < n; t++) {
                        const n = e.holes[t];
                        this.holes.push((new Path).fromJSON(n))
                    }
                    return this
                }
            }), Light.prototype = Object.assign(Object.create(Object3D.prototype), {
                constructor: Light,
                isLight: !0,
                copy: function(e) {
                    return Object3D.prototype.copy.call(this, e), this.color.copy(e.color), this.intensity = e.intensity, this
                },
                toJSON: function(e) {
                    const t = Object3D.prototype.toJSON.call(this, e);
                    return t.object.color = this.color.getHex(), t.object.intensity = this.intensity, void 0 !== this.groundColor && (t.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (t.object.distance = this.distance), void 0 !== this.angle && (t.object.angle = this.angle), void 0 !== this.decay && (t.object.decay = this.decay), void 0 !== this.penumbra && (t.object.penumbra = this.penumbra), void 0 !== this.shadow && (t.object.shadow = this.shadow.toJSON()), t
                }
            }), HemisphereLight.prototype = Object.assign(Object.create(Light.prototype), {
                constructor: HemisphereLight,
                isHemisphereLight: !0,
                copy: function(e) {
                    return Light.prototype.copy.call(this, e), this.groundColor.copy(e.groundColor), this
                }
            }), Object.assign(LightShadow.prototype, {
                _projScreenMatrix: new Matrix4,
                _lightPositionWorld: new Vector3,
                _lookTarget: new Vector3,
                getViewportCount: function() {
                    return this._viewportCount
                },
                getFrustum: function() {
                    return this._frustum
                },
                updateMatrices: function(e) {
                    const t = this.camera,
                        n = this.matrix,
                        i = this._projScreenMatrix,
                        r = this._lookTarget,
                        a = this._lightPositionWorld;
                    a.setFromMatrixPosition(e.matrixWorld), t.position.copy(a), r.setFromMatrixPosition(e.target.matrixWorld), t.lookAt(r), t.updateMatrixWorld(), i.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), this._frustum.setFromProjectionMatrix(i), n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), n.multiply(t.projectionMatrix), n.multiply(t.matrixWorldInverse)
                },
                getViewport: function(e) {
                    return this._viewports[e]
                },
                getFrameExtents: function() {
                    return this._frameExtents
                },
                copy: function(e) {
                    return this.camera = e.camera.clone(), this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                toJSON: function() {
                    const e = {};
                    return 0 !== this.bias && (e.bias = this.bias), 0 !== this.normalBias && (e.normalBias = this.normalBias), 1 !== this.radius && (e.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e
                }
            }), SpotLightShadow.prototype = Object.assign(Object.create(LightShadow.prototype), {
                constructor: SpotLightShadow,
                isSpotLightShadow: !0,
                updateMatrices: function(e) {
                    const t = this.camera,
                        n = 2 * Fa.RAD2DEG * e.angle * this.focus,
                        i = this.mapSize.width / this.mapSize.height,
                        r = e.distance || t.far;
                    n === t.fov && i === t.aspect && r === t.far || (t.fov = n, t.aspect = i, t.far = r, t.updateProjectionMatrix()), LightShadow.prototype.updateMatrices.call(this, e)
                }
            }), SpotLight.prototype = Object.assign(Object.create(Light.prototype), {
                constructor: SpotLight,
                isSpotLight: !0,
                copy: function(e) {
                    return Light.prototype.copy.call(this, e), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this
                }
            }), PointLightShadow.prototype = Object.assign(Object.create(LightShadow.prototype), {
                constructor: PointLightShadow,
                isPointLightShadow: !0,
                updateMatrices: function(e, t = 0) {
                    const n = this.camera,
                        i = this.matrix,
                        r = this._lightPositionWorld,
                        a = this._lookTarget,
                        o = this._projScreenMatrix;
                    r.setFromMatrixPosition(e.matrixWorld), n.position.copy(r), a.copy(n.position), a.add(this._cubeDirections[t]), n.up.copy(this._cubeUps[t]), n.lookAt(a), n.updateMatrixWorld(), i.makeTranslation(-r.x, -r.y, -r.z), o.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(o)
                }
            }), PointLight.prototype = Object.assign(Object.create(Light.prototype), {
                constructor: PointLight,
                isPointLight: !0,
                copy: function(e) {
                    return Light.prototype.copy.call(this, e), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this
                }
            }), OrthographicCamera.prototype = Object.assign(Object.create(Camera.prototype), {
                constructor: OrthographicCamera,
                isOrthographicCamera: !0,
                copy: function(e, t) {
                    return Camera.prototype.copy.call(this, e, t), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = null === e.view ? null : Object.assign({}, e.view), this
                },
                setViewOffset: function(e, t, n, i, r, a) {
                    null === this.view && (this.view = {
                        enabled: !0,
                        fullWidth: 1,
                        fullHeight: 1,
                        offsetX: 0,
                        offsetY: 0,
                        width: 1,
                        height: 1
                    }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = i, this.view.width = r, this.view.height = a, this.updateProjectionMatrix()
                },
                clearViewOffset: function() {
                    null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
                },
                updateProjectionMatrix: function() {
                    const e = (this.right - this.left) / (2 * this.zoom),
                        t = (this.top - this.bottom) / (2 * this.zoom),
                        n = (this.right + this.left) / 2,
                        i = (this.top + this.bottom) / 2;
                    let r = n - e,
                        a = n + e,
                        o = i + t,
                        s = i - t;
                    if (null !== this.view && this.view.enabled) {
                        const e = (this.right - this.left) / this.view.fullWidth / this.zoom,
                            t = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
                        r += e * this.view.offsetX, a = r + e * this.view.width, o -= t * this.view.offsetY, s = o - t * this.view.height
                    }
                    this.projectionMatrix.makeOrthographic(r, a, o, s, this.near, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
                },
                toJSON: function(e) {
                    const t = Object3D.prototype.toJSON.call(this, e);
                    return t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, null !== this.view && (t.object.view = Object.assign({}, this.view)), t
                }
            }), DirectionalLightShadow.prototype = Object.assign(Object.create(LightShadow.prototype), {
                constructor: DirectionalLightShadow,
                isDirectionalLightShadow: !0,
                updateMatrices: function(e) {
                    LightShadow.prototype.updateMatrices.call(this, e)
                }
            }), DirectionalLight.prototype = Object.assign(Object.create(Light.prototype), {
                constructor: DirectionalLight,
                isDirectionalLight: !0,
                copy: function(e) {
                    return Light.prototype.copy.call(this, e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this
                }
            }), AmbientLight.prototype = Object.assign(Object.create(Light.prototype), {
                constructor: AmbientLight,
                isAmbientLight: !0
            }), RectAreaLight.prototype = Object.assign(Object.create(Light.prototype), {
                constructor: RectAreaLight,
                isRectAreaLight: !0,
                copy: function(e) {
                    return Light.prototype.copy.call(this, e), this.width = e.width, this.height = e.height, this
                },
                toJSON: function(e) {
                    const t = Light.prototype.toJSON.call(this, e);
                    return t.object.width = this.width, t.object.height = this.height, t
                }
            });
            class SphericalHarmonics3 {
                constructor() {
                    Object.defineProperty(this, "isSphericalHarmonics3", {
                        value: !0
                    }), this.coefficients = [];
                    for (let e = 0; e < 9; e++) this.coefficients.push(new Vector3)
                }
                set(e) {
                    for (let t = 0; t < 9; t++) this.coefficients[t].copy(e[t]);
                    return this
                }
                zero() {
                    for (let e = 0; e < 9; e++) this.coefficients[e].set(0, 0, 0);
                    return this
                }
                getAt(e, t) {
                    const n = e.x,
                        i = e.y,
                        r = e.z,
                        a = this.coefficients;
                    return t.copy(a[0]).multiplyScalar(.282095), t.addScaledVector(a[1], .488603 * i), t.addScaledVector(a[2], .488603 * r), t.addScaledVector(a[3], .488603 * n), t.addScaledVector(a[4], n * i * 1.092548), t.addScaledVector(a[5], i * r * 1.092548), t.addScaledVector(a[6], .315392 * (3 * r * r - 1)), t.addScaledVector(a[7], n * r * 1.092548), t.addScaledVector(a[8], .546274 * (n * n - i * i)), t
                }
                getIrradianceAt(e, t) {
                    const n = e.x,
                        i = e.y,
                        r = e.z,
                        a = this.coefficients;
                    return t.copy(a[0]).multiplyScalar(.886227), t.addScaledVector(a[1], 1.023328 * i), t.addScaledVector(a[2], 1.023328 * r), t.addScaledVector(a[3], 1.023328 * n), t.addScaledVector(a[4], .858086 * n * i), t.addScaledVector(a[5], .858086 * i * r), t.addScaledVector(a[6], .743125 * r * r - .247708), t.addScaledVector(a[7], .858086 * n * r), t.addScaledVector(a[8], .429043 * (n * n - i * i)), t
                }
                add(e) {
                    for (let t = 0; t < 9; t++) this.coefficients[t].add(e.coefficients[t]);
                    return this
                }
                addScaledSH(e, t) {
                    for (let n = 0; n < 9; n++) this.coefficients[n].addScaledVector(e.coefficients[n], t);
                    return this
                }
                scale(e) {
                    for (let t = 0; t < 9; t++) this.coefficients[t].multiplyScalar(e);
                    return this
                }
                lerp(e, t) {
                    for (let n = 0; n < 9; n++) this.coefficients[n].lerp(e.coefficients[n], t);
                    return this
                }
                equals(e) {
                    for (let t = 0; t < 9; t++)
                        if (!this.coefficients[t].equals(e.coefficients[t])) return !1;
                    return !0
                }
                copy(e) {
                    return this.set(e.coefficients)
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                fromArray(e, t = 0) {
                    const n = this.coefficients;
                    for (let i = 0; i < 9; i++) n[i].fromArray(e, t + 3 * i);
                    return this
                }
                toArray(e = [], t = 0) {
                    const n = this.coefficients;
                    for (let i = 0; i < 9; i++) n[i].toArray(e, t + 3 * i);
                    return e
                }
                static getBasisAt(e, t) {
                    const n = e.x,
                        i = e.y,
                        r = e.z;
                    t[0] = .282095, t[1] = .488603 * i, t[2] = .488603 * r, t[3] = .488603 * n, t[4] = 1.092548 * n * i, t[5] = 1.092548 * i * r, t[6] = .315392 * (3 * r * r - 1), t[7] = 1.092548 * n * r, t[8] = .546274 * (n * n - i * i)
                }
            }
            LightProbe.prototype = Object.assign(Object.create(Light.prototype), {
                constructor: LightProbe,
                isLightProbe: !0,
                copy: function(e) {
                    return Light.prototype.copy.call(this, e), this.sh.copy(e.sh), this
                },
                fromJSON: function(e) {
                    return this.intensity = e.intensity, this.sh.fromArray(e.sh), this
                },
                toJSON: function(e) {
                    const t = Light.prototype.toJSON.call(this, e);
                    return t.object.sh = this.sh.toArray(), t
                }
            }), MaterialLoader.prototype = Object.assign(Object.create(Loader.prototype), {
                constructor: MaterialLoader,
                load: function(e, t, n, i) {
                    const r = this,
                        a = new FileLoader(r.manager);
                    a.setPath(r.path), a.setRequestHeader(r.requestHeader), a.setWithCredentials(r.withCredentials), a.load(e, (function(n) {
                        try {
                            t(r.parse(JSON.parse(n)))
                        } catch (t) {
                            i && i(t), r.manager.itemError(e)
                        }
                    }), n, i)
                },
                parse: function(e) {
                    function getTexture(e) {
                        return t[e], t[e]
                    }
                    const t = this.textures,
                        n = new s[e.type];
                    if (void 0 !== e.uuid && (n.uuid = e.uuid), void 0 !== e.name && (n.name = e.name), void 0 !== e.color && void 0 !== n.color && n.color.setHex(e.color), void 0 !== e.roughness && (n.roughness = e.roughness), void 0 !== e.metalness && (n.metalness = e.metalness), void 0 !== e.sheen && (n.sheen = (new Color).setHex(e.sheen)), void 0 !== e.emissive && void 0 !== n.emissive && n.emissive.setHex(e.emissive), void 0 !== e.specular && void 0 !== n.specular && n.specular.setHex(e.specular), void 0 !== e.shininess && (n.shininess = e.shininess), void 0 !== e.clearcoat && (n.clearcoat = e.clearcoat), void 0 !== e.clearcoatRoughness && (n.clearcoatRoughness = e.clearcoatRoughness), void 0 !== e.fog && (n.fog = e.fog), void 0 !== e.flatShading && (n.flatShading = e.flatShading), void 0 !== e.blending && (n.blending = e.blending), void 0 !== e.combine && (n.combine = e.combine), void 0 !== e.side && (n.side = e.side), void 0 !== e.opacity && (n.opacity = e.opacity), void 0 !== e.transparent && (n.transparent = e.transparent), void 0 !== e.alphaTest && (n.alphaTest = e.alphaTest), void 0 !== e.depthTest && (n.depthTest = e.depthTest), void 0 !== e.depthWrite && (n.depthWrite = e.depthWrite), void 0 !== e.colorWrite && (n.colorWrite = e.colorWrite), void 0 !== e.stencilWrite && (n.stencilWrite = e.stencilWrite), void 0 !== e.stencilWriteMask && (n.stencilWriteMask = e.stencilWriteMask), void 0 !== e.stencilFunc && (n.stencilFunc = e.stencilFunc), void 0 !== e.stencilRef && (n.stencilRef = e.stencilRef), void 0 !== e.stencilFuncMask && (n.stencilFuncMask = e.stencilFuncMask), void 0 !== e.stencilFail && (n.stencilFail = e.stencilFail), void 0 !== e.stencilZFail && (n.stencilZFail = e.stencilZFail), void 0 !== e.stencilZPass && (n.stencilZPass = e.stencilZPass), void 0 !== e.wireframe && (n.wireframe = e.wireframe), void 0 !== e.wireframeLinewidth && (n.wireframeLinewidth = e.wireframeLinewidth), void 0 !== e.wireframeLinecap && (n.wireframeLinecap = e.wireframeLinecap), void 0 !== e.wireframeLinejoin && (n.wireframeLinejoin = e.wireframeLinejoin), void 0 !== e.rotation && (n.rotation = e.rotation), 1 !== e.linewidth && (n.linewidth = e.linewidth), void 0 !== e.dashSize && (n.dashSize = e.dashSize), void 0 !== e.gapSize && (n.gapSize = e.gapSize), void 0 !== e.scale && (n.scale = e.scale), void 0 !== e.polygonOffset && (n.polygonOffset = e.polygonOffset), void 0 !== e.polygonOffsetFactor && (n.polygonOffsetFactor = e.polygonOffsetFactor), void 0 !== e.polygonOffsetUnits && (n.polygonOffsetUnits = e.polygonOffsetUnits), void 0 !== e.skinning && (n.skinning = e.skinning), void 0 !== e.morphTargets && (n.morphTargets = e.morphTargets), void 0 !== e.morphNormals && (n.morphNormals = e.morphNormals), void 0 !== e.dithering && (n.dithering = e.dithering), void 0 !== e.vertexTangents && (n.vertexTangents = e.vertexTangents), void 0 !== e.visible && (n.visible = e.visible), void 0 !== e.toneMapped && (n.toneMapped = e.toneMapped), void 0 !== e.userData && (n.userData = e.userData), void 0 !== e.vertexColors && ("number" == typeof e.vertexColors ? n.vertexColors = e.vertexColors > 0 : n.vertexColors = e.vertexColors), void 0 !== e.uniforms)
                        for (const t in e.uniforms) {
                            const i = e.uniforms[t];
                            switch (n.uniforms[t] = {}, i.type) {
                                case "t":
                                    n.uniforms[t].value = getTexture(i.value);
                                    break;
                                case "c":
                                    n.uniforms[t].value = (new Color).setHex(i.value);
                                    break;
                                case "v2":
                                    n.uniforms[t].value = (new Vector2).fromArray(i.value);
                                    break;
                                case "v3":
                                    n.uniforms[t].value = (new Vector3).fromArray(i.value);
                                    break;
                                case "v4":
                                    n.uniforms[t].value = (new Vector4).fromArray(i.value);
                                    break;
                                case "m3":
                                    n.uniforms[t].value = (new Matrix3).fromArray(i.value);
                                    break;
                                case "m4":
                                    n.uniforms[t].value = (new Matrix4).fromArray(i.value);
                                    break;
                                default:
                                    n.uniforms[t].value = i.value
                            }
                        }
                    if (void 0 !== e.defines && (n.defines = e.defines), void 0 !== e.vertexShader && (n.vertexShader = e.vertexShader), void 0 !== e.fragmentShader && (n.fragmentShader = e.fragmentShader), void 0 !== e.extensions)
                        for (const t in e.extensions) n.extensions[t] = e.extensions[t];
                    if (void 0 !== e.shading && (n.flatShading = 1 === e.shading), void 0 !== e.size && (n.size = e.size), void 0 !== e.sizeAttenuation && (n.sizeAttenuation = e.sizeAttenuation), void 0 !== e.map && (n.map = getTexture(e.map)), void 0 !== e.matcap && (n.matcap = getTexture(e.matcap)), void 0 !== e.alphaMap && (n.alphaMap = getTexture(e.alphaMap)), void 0 !== e.bumpMap && (n.bumpMap = getTexture(e.bumpMap)), void 0 !== e.bumpScale && (n.bumpScale = e.bumpScale), void 0 !== e.normalMap && (n.normalMap = getTexture(e.normalMap)), void 0 !== e.normalMapType && (n.normalMapType = e.normalMapType), void 0 !== e.normalScale) {
                        let t = e.normalScale;
                        !1 === Array.isArray(t) && (t = [t, t]), n.normalScale = (new Vector2).fromArray(t)
                    }
                    return void 0 !== e.displacementMap && (n.displacementMap = getTexture(e.displacementMap)), void 0 !== e.displacementScale && (n.displacementScale = e.displacementScale), void 0 !== e.displacementBias && (n.displacementBias = e.displacementBias), void 0 !== e.roughnessMap && (n.roughnessMap = getTexture(e.roughnessMap)), void 0 !== e.metalnessMap && (n.metalnessMap = getTexture(e.metalnessMap)), void 0 !== e.emissiveMap && (n.emissiveMap = getTexture(e.emissiveMap)), void 0 !== e.emissiveIntensity && (n.emissiveIntensity = e.emissiveIntensity), void 0 !== e.specularMap && (n.specularMap = getTexture(e.specularMap)), void 0 !== e.envMap && (n.envMap = getTexture(e.envMap)), void 0 !== e.envMapIntensity && (n.envMapIntensity = e.envMapIntensity), void 0 !== e.reflectivity && (n.reflectivity = e.reflectivity), void 0 !== e.refractionRatio && (n.refractionRatio = e.refractionRatio), void 0 !== e.lightMap && (n.lightMap = getTexture(e.lightMap)), void 0 !== e.lightMapIntensity && (n.lightMapIntensity = e.lightMapIntensity), void 0 !== e.aoMap && (n.aoMap = getTexture(e.aoMap)), void 0 !== e.aoMapIntensity && (n.aoMapIntensity = e.aoMapIntensity), void 0 !== e.gradientMap && (n.gradientMap = getTexture(e.gradientMap)), void 0 !== e.clearcoatMap && (n.clearcoatMap = getTexture(e.clearcoatMap)), void 0 !== e.clearcoatRoughnessMap && (n.clearcoatRoughnessMap = getTexture(e.clearcoatRoughnessMap)), void 0 !== e.clearcoatNormalMap && (n.clearcoatNormalMap = getTexture(e.clearcoatNormalMap)), void 0 !== e.clearcoatNormalScale && (n.clearcoatNormalScale = (new Vector2).fromArray(e.clearcoatNormalScale)), void 0 !== e.transmission && (n.transmission = e.transmission), void 0 !== e.transmissionMap && (n.transmissionMap = getTexture(e.transmissionMap)), n
                },
                setTextures: function(e) {
                    return this.textures = e, this
                }
            });
            const kl = {
                decodeText: function(e) {
                    if ("undefined" != typeof TextDecoder) return (new TextDecoder).decode(e);
                    let t = "";
                    for (let n = 0, i = e.length; n < i; n++) t += String.fromCharCode(e[n]);
                    try {
                        return decodeURIComponent(escape(t))
                    } catch (e) {
                        return t
                    }
                },
                extractUrlBase: function(e) {
                    const t = e.lastIndexOf("/");
                    return -1 === t ? "./" : e.substr(0, t + 1)
                }
            };
            InstancedBufferGeometry.prototype = Object.assign(Object.create(BufferGeometry.prototype), {
                constructor: InstancedBufferGeometry,
                isInstancedBufferGeometry: !0,
                copy: function(e) {
                    return BufferGeometry.prototype.copy.call(this, e), this.instanceCount = e.instanceCount, this
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                toJSON: function() {
                    const e = BufferGeometry.prototype.toJSON.call(this);
                    return e.instanceCount = this.instanceCount, e.isInstancedBufferGeometry = !0, e
                }
            }), InstancedBufferAttribute.prototype = Object.assign(Object.create(BufferAttribute.prototype), {
                constructor: InstancedBufferAttribute,
                isInstancedBufferAttribute: !0,
                copy: function(e) {
                    return BufferAttribute.prototype.copy.call(this, e), this.meshPerAttribute = e.meshPerAttribute, this
                },
                toJSON: function() {
                    const e = BufferAttribute.prototype.toJSON.call(this);
                    return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = !0, e
                }
            }), BufferGeometryLoader.prototype = Object.assign(Object.create(Loader.prototype), {
                constructor: BufferGeometryLoader,
                load: function(e, t, n, i) {
                    const r = this,
                        a = new FileLoader(r.manager);
                    a.setPath(r.path), a.setRequestHeader(r.requestHeader), a.setWithCredentials(r.withCredentials), a.load(e, (function(n) {
                        try {
                            t(r.parse(JSON.parse(n)))
                        } catch (t) {
                            i && i(t), r.manager.itemError(e)
                        }
                    }), n, i)
                },
                parse: function(e) {
                    function getInterleavedBuffer(e, i) {
                        if (void 0 !== t[i]) return t[i];
                        const r = e.interleavedBuffers[i],
                            a = function getArrayBuffer(e, t) {
                                if (void 0 !== n[t]) return n[t];
                                const i = e.arrayBuffers[t],
                                    r = new Uint32Array(i).buffer;
                                return n[t] = r, r
                            }(e, r.buffer),
                            o = new InterleavedBuffer(getTypedArray(r.type, a), r.stride);
                        return o.uuid = r.uuid, t[i] = o, o
                    }
                    const t = {},
                        n = {},
                        i = e.isInstancedBufferGeometry ? new InstancedBufferGeometry : new BufferGeometry,
                        r = e.data.index;
                    if (void 0 !== r) {
                        const e = getTypedArray(r.type, r.array);
                        i.setIndex(new BufferAttribute(e, 1))
                    }
                    const a = e.data.attributes;
                    for (const t in a) {
                        const n = a[t];
                        let r;
                        if (n.isInterleavedBufferAttribute) {
                            r = new InterleavedBufferAttribute(getInterleavedBuffer(e.data, n.data), n.itemSize, n.offset, n.normalized)
                        } else {
                            const e = getTypedArray(n.type, n.array);
                            r = new(n.isInstancedBufferAttribute ? InstancedBufferAttribute : BufferAttribute)(e, n.itemSize, n.normalized)
                        }
                        void 0 !== n.name && (r.name = n.name), i.setAttribute(t, r)
                    }
                    const o = e.data.morphAttributes;
                    if (o)
                        for (const t in o) {
                            const n = o[t],
                                r = [];
                            for (let t = 0, i = n.length; t < i; t++) {
                                const i = n[t];
                                let a;
                                if (i.isInterleavedBufferAttribute) {
                                    a = new InterleavedBufferAttribute(getInterleavedBuffer(e.data, i.data), i.itemSize, i.offset, i.normalized)
                                } else {
                                    a = new BufferAttribute(getTypedArray(i.type, i.array), i.itemSize, i.normalized)
                                }
                                void 0 !== i.name && (a.name = i.name), r.push(a)
                            }
                            i.morphAttributes[t] = r
                        }
                    e.data.morphTargetsRelative && (i.morphTargetsRelative = !0);
                    const s = e.data.groups || e.data.drawcalls || e.data.offsets;
                    if (void 0 !== s)
                        for (let e = 0, t = s.length; e !== t; ++e) {
                            const t = s[e];
                            i.addGroup(t.start, t.count, t.materialIndex)
                        }
                    const l = e.data.boundingSphere;
                    if (void 0 !== l) {
                        const e = new Vector3;
                        void 0 !== l.center && e.fromArray(l.center), i.boundingSphere = new Sphere(e, l.radius)
                    }
                    return e.name && (i.name = e.name), e.userData && (i.userData = e.userData), i
                }
            });
            class ObjectLoader extends Loader {
                constructor(e) {
                    super(e)
                }
                load(e, t, n, i) {
                    const r = this,
                        a = "" === this.path ? kl.extractUrlBase(e) : this.path;
                    this.resourcePath = this.resourcePath || a;
                    const o = new FileLoader(this.manager);
                    o.setPath(this.path), o.setRequestHeader(this.requestHeader), o.setWithCredentials(this.withCredentials), o.load(e, (function(e) {
                        let n = null;
                        try {
                            n = JSON.parse(e)
                        } catch (e) {
                            return void(void 0 !== i && i(e))
                        }
                        const a = n.metadata;
                        void 0 !== a && void 0 !== a.type && "geometry" !== a.type.toLowerCase() && r.parse(n, t)
                    }), n, i)
                }
                parse(e, t) {
                    const n = this.parseAnimations(e.animations),
                        i = this.parseShapes(e.shapes),
                        r = this.parseGeometries(e.geometries, i),
                        a = this.parseImages(e.images, (function() {
                            void 0 !== t && t(l)
                        })),
                        o = this.parseTextures(e.textures, a),
                        s = this.parseMaterials(e.materials, o),
                        l = this.parseObject(e.object, r, s, n),
                        c = this.parseSkeletons(e.skeletons, l);
                    if (this.bindSkeletons(l, c), void 0 !== t) {
                        let e = !1;
                        for (const t in a)
                            if (a[t] instanceof HTMLImageElement) {
                                e = !0;
                                break
                            }!1 === e && t(l)
                    }
                    return l
                }
                parseShapes(e) {
                    const t = {};
                    if (void 0 !== e)
                        for (let n = 0, i = e.length; n < i; n++) {
                            const i = (new Shape).fromJSON(e[n]);
                            t[i.uuid] = i
                        }
                    return t
                }
                parseSkeletons(e, t) {
                    const n = {},
                        i = {};
                    if (t.traverse((function(e) {
                            e.isBone && (i[e.uuid] = e)
                        })), void 0 !== e)
                        for (let t = 0, r = e.length; t < r; t++) {
                            const r = (new Skeleton).fromJSON(e[t], i);
                            n[r.uuid] = r
                        }
                    return n
                }
                parseGeometries(e, t) {
                    const n = {};
                    let i;
                    if (void 0 !== e) {
                        const r = new BufferGeometryLoader;
                        for (let a = 0, s = e.length; a < s; a++) {
                            let s;
                            const c = e[a];
                            switch (c.type) {
                                case "PlaneGeometry":
                                case "PlaneBufferGeometry":
                                    s = new o[c.type](c.width, c.height, c.widthSegments, c.heightSegments);
                                    break;
                                case "BoxGeometry":
                                case "BoxBufferGeometry":
                                case "CubeGeometry":
                                    s = new o[c.type](c.width, c.height, c.depth, c.widthSegments, c.heightSegments, c.depthSegments);
                                    break;
                                case "CircleGeometry":
                                case "CircleBufferGeometry":
                                    s = new o[c.type](c.radius, c.segments, c.thetaStart, c.thetaLength);
                                    break;
                                case "CylinderGeometry":
                                case "CylinderBufferGeometry":
                                    s = new o[c.type](c.radiusTop, c.radiusBottom, c.height, c.radialSegments, c.heightSegments, c.openEnded, c.thetaStart, c.thetaLength);
                                    break;
                                case "ConeGeometry":
                                case "ConeBufferGeometry":
                                    s = new o[c.type](c.radius, c.height, c.radialSegments, c.heightSegments, c.openEnded, c.thetaStart, c.thetaLength);
                                    break;
                                case "SphereGeometry":
                                case "SphereBufferGeometry":
                                    s = new o[c.type](c.radius, c.widthSegments, c.heightSegments, c.phiStart, c.phiLength, c.thetaStart, c.thetaLength);
                                    break;
                                case "DodecahedronGeometry":
                                case "DodecahedronBufferGeometry":
                                case "IcosahedronGeometry":
                                case "IcosahedronBufferGeometry":
                                case "OctahedronGeometry":
                                case "OctahedronBufferGeometry":
                                case "TetrahedronGeometry":
                                case "TetrahedronBufferGeometry":
                                    s = new o[c.type](c.radius, c.detail);
                                    break;
                                case "RingGeometry":
                                case "RingBufferGeometry":
                                    s = new o[c.type](c.innerRadius, c.outerRadius, c.thetaSegments, c.phiSegments, c.thetaStart, c.thetaLength);
                                    break;
                                case "TorusGeometry":
                                case "TorusBufferGeometry":
                                    s = new o[c.type](c.radius, c.tube, c.radialSegments, c.tubularSegments, c.arc);
                                    break;
                                case "TorusKnotGeometry":
                                case "TorusKnotBufferGeometry":
                                    s = new o[c.type](c.radius, c.tube, c.tubularSegments, c.radialSegments, c.p, c.q);
                                    break;
                                case "TubeGeometry":
                                case "TubeBufferGeometry":
                                    s = new o[c.type]((new l[c.path.type]).fromJSON(c.path), c.tubularSegments, c.radius, c.radialSegments, c.closed);
                                    break;
                                case "LatheGeometry":
                                case "LatheBufferGeometry":
                                    s = new o[c.type](c.points, c.segments, c.phiStart, c.phiLength);
                                    break;
                                case "PolyhedronGeometry":
                                case "PolyhedronBufferGeometry":
                                    s = new o[c.type](c.vertices, c.indices, c.radius, c.details);
                                    break;
                                case "ShapeGeometry":
                                case "ShapeBufferGeometry":
                                    i = [];
                                    for (let e = 0, n = c.shapes.length; e < n; e++) {
                                        const n = t[c.shapes[e]];
                                        i.push(n)
                                    }
                                    s = new o[c.type](i, c.curveSegments);
                                    break;
                                case "ExtrudeGeometry":
                                case "ExtrudeBufferGeometry":
                                    i = [];
                                    for (let e = 0, n = c.shapes.length; e < n; e++) {
                                        const n = t[c.shapes[e]];
                                        i.push(n)
                                    }
                                    const e = c.options.extrudePath;
                                    void 0 !== e && (c.options.extrudePath = (new l[e.type]).fromJSON(e)), s = new o[c.type](i, c.options);
                                    break;
                                case "BufferGeometry":
                                case "InstancedBufferGeometry":
                                    s = r.parse(c);
                                    break;
                                case "Geometry":
                                    break;
                                default:
                                    continue
                            }
                            s.uuid = c.uuid, void 0 !== c.name && (s.name = c.name), !0 === s.isBufferGeometry && void 0 !== c.userData && (s.userData = c.userData), n[c.uuid] = s
                        }
                    }
                    return n
                }
                parseMaterials(e, t) {
                    const n = {},
                        i = {};
                    if (void 0 !== e) {
                        const r = new MaterialLoader;
                        r.setTextures(t);
                        for (let t = 0, a = e.length; t < a; t++) {
                            const a = e[t];
                            if ("MultiMaterial" === a.type) {
                                const e = [];
                                for (let t = 0; t < a.materials.length; t++) {
                                    const i = a.materials[t];
                                    void 0 === n[i.uuid] && (n[i.uuid] = r.parse(i)), e.push(n[i.uuid])
                                }
                                i[a.uuid] = e
                            } else void 0 === n[a.uuid] && (n[a.uuid] = r.parse(a)), i[a.uuid] = n[a.uuid]
                        }
                    }
                    return i
                }
                parseAnimations(e) {
                    const t = {};
                    if (void 0 !== e)
                        for (let n = 0; n < e.length; n++) {
                            const i = e[n],
                                r = AnimationClip.parse(i);
                            t[r.uuid] = r
                        }
                    return t
                }
                parseImages(e, t) {
                    function deserializeImage(e) {
                        if ("string" == typeof e) {
                            const t = e;
                            return function loadImage(e) {
                                return n.manager.itemStart(e), r.load(e, (function() {
                                    n.manager.itemEnd(e)
                                }), void 0, (function() {
                                    n.manager.itemError(e), n.manager.itemEnd(e)
                                }))
                            }(/^(\/\/)|([a-z]+:(\/\/)?)/i.test(t) ? t : n.resourcePath + t)
                        }
                        return e.data ? {
                            data: getTypedArray(e.type, e.data),
                            width: e.width,
                            height: e.height
                        } : null
                    }
                    const n = this,
                        i = {};
                    let r;
                    if (void 0 !== e && e.length > 0) {
                        const n = new LoadingManager(t);
                        r = new ImageLoader(n), r.setCrossOrigin(this.crossOrigin);
                        for (let t = 0, n = e.length; t < n; t++) {
                            const n = e[t],
                                r = n.url;
                            if (Array.isArray(r)) {
                                i[n.uuid] = [];
                                for (let e = 0, t = r.length; e < t; e++) {
                                    const t = deserializeImage(r[e]);
                                    null !== t && (t instanceof HTMLImageElement ? i[n.uuid].push(t) : i[n.uuid].push(new DataTexture(t.data, t.width, t.height)))
                                }
                            } else {
                                const e = deserializeImage(n.url);
                                null !== e && (i[n.uuid] = e)
                            }
                        }
                    }
                    return i
                }
                parseTextures(e, t) {
                    function parseConstant(e, t) {
                        return "number" == typeof e ? e : t[e]
                    }
                    const n = {};
                    if (void 0 !== e)
                        for (let i = 0, r = e.length; i < r; i++) {
                            const r = e[i];
                            let a;
                            r.image, t[r.image];
                            const o = t[r.image];
                            Array.isArray(o) ? (a = new CubeTexture(o), 6 === o.length && (a.needsUpdate = !0)) : (a = o && o.data ? new DataTexture(o.data, o.width, o.height) : new Texture(o), o && (a.needsUpdate = !0)), a.uuid = r.uuid, void 0 !== r.name && (a.name = r.name), void 0 !== r.mapping && (a.mapping = parseConstant(r.mapping, jl)), void 0 !== r.offset && a.offset.fromArray(r.offset), void 0 !== r.repeat && a.repeat.fromArray(r.repeat), void 0 !== r.center && a.center.fromArray(r.center), void 0 !== r.rotation && (a.rotation = r.rotation), void 0 !== r.wrap && (a.wrapS = parseConstant(r.wrap[0], Wl), a.wrapT = parseConstant(r.wrap[1], Wl)), void 0 !== r.format && (a.format = r.format), void 0 !== r.type && (a.type = r.type), void 0 !== r.encoding && (a.encoding = r.encoding), void 0 !== r.minFilter && (a.minFilter = parseConstant(r.minFilter, Hl)), void 0 !== r.magFilter && (a.magFilter = parseConstant(r.magFilter, Hl)), void 0 !== r.anisotropy && (a.anisotropy = r.anisotropy), void 0 !== r.flipY && (a.flipY = r.flipY), void 0 !== r.premultiplyAlpha && (a.premultiplyAlpha = r.premultiplyAlpha), void 0 !== r.unpackAlignment && (a.unpackAlignment = r.unpackAlignment), n[r.uuid] = a
                        }
                    return n
                }
                parseObject(e, t, n, i) {
                    function getGeometry(e) {
                        return t[e], t[e]
                    }

                    function getMaterial(e) {
                        if (void 0 !== e) {
                            if (Array.isArray(e)) {
                                const t = [];
                                for (let i = 0, r = e.length; i < r; i++) {
                                    const r = e[i];
                                    n[r], t.push(n[r])
                                }
                                return t
                            }
                            return n[e], n[e]
                        }
                    }
                    let r, a, o;
                    switch (e.type) {
                        case "Scene":
                            r = new Scene, void 0 !== e.background && Number.isInteger(e.background) && (r.background = new Color(e.background)), void 0 !== e.fog && ("Fog" === e.fog.type ? r.fog = new Fog(e.fog.color, e.fog.near, e.fog.far) : "FogExp2" === e.fog.type && (r.fog = new FogExp2(e.fog.color, e.fog.density)));
                            break;
                        case "PerspectiveCamera":
                            r = new PerspectiveCamera(e.fov, e.aspect, e.near, e.far), void 0 !== e.focus && (r.focus = e.focus), void 0 !== e.zoom && (r.zoom = e.zoom), void 0 !== e.filmGauge && (r.filmGauge = e.filmGauge), void 0 !== e.filmOffset && (r.filmOffset = e.filmOffset), void 0 !== e.view && (r.view = Object.assign({}, e.view));
                            break;
                        case "OrthographicCamera":
                            r = new OrthographicCamera(e.left, e.right, e.top, e.bottom, e.near, e.far), void 0 !== e.zoom && (r.zoom = e.zoom), void 0 !== e.view && (r.view = Object.assign({}, e.view));
                            break;
                        case "AmbientLight":
                            r = new AmbientLight(e.color, e.intensity);
                            break;
                        case "DirectionalLight":
                            r = new DirectionalLight(e.color, e.intensity);
                            break;
                        case "PointLight":
                            r = new PointLight(e.color, e.intensity, e.distance, e.decay);
                            break;
                        case "RectAreaLight":
                            r = new RectAreaLight(e.color, e.intensity, e.width, e.height);
                            break;
                        case "SpotLight":
                            r = new SpotLight(e.color, e.intensity, e.distance, e.angle, e.penumbra, e.decay);
                            break;
                        case "HemisphereLight":
                            r = new HemisphereLight(e.color, e.groundColor, e.intensity);
                            break;
                        case "LightProbe":
                            r = (new LightProbe).fromJSON(e);
                            break;
                        case "SkinnedMesh":
                            a = getGeometry(e.geometry), o = getMaterial(e.material), r = new SkinnedMesh(a, o), void 0 !== e.bindMode && (r.bindMode = e.bindMode), void 0 !== e.bindMatrix && r.bindMatrix.fromArray(e.bindMatrix), void 0 !== e.skeleton && (r.skeleton = e.skeleton);
                            break;
                        case "Mesh":
                            a = getGeometry(e.geometry), o = getMaterial(e.material), r = new Mesh(a, o);
                            break;
                        case "InstancedMesh":
                            a = getGeometry(e.geometry), o = getMaterial(e.material);
                            const t = e.count,
                                n = e.instanceMatrix;
                            r = new InstancedMesh(a, o, t), r.instanceMatrix = new BufferAttribute(new Float32Array(n.array), 16);
                            break;
                        case "LOD":
                            r = new LOD;
                            break;
                        case "Line":
                            r = new Line(getGeometry(e.geometry), getMaterial(e.material));
                            break;
                        case "LineLoop":
                            r = new LineLoop(getGeometry(e.geometry), getMaterial(e.material));
                            break;
                        case "LineSegments":
                            r = new LineSegments(getGeometry(e.geometry), getMaterial(e.material));
                            break;
                        case "PointCloud":
                        case "Points":
                            r = new Points(getGeometry(e.geometry), getMaterial(e.material));
                            break;
                        case "Sprite":
                            r = new Sprite(getMaterial(e.material));
                            break;
                        case "Group":
                            r = new Group;
                            break;
                        case "Bone":
                            r = new Bone;
                            break;
                        default:
                            r = new Object3D
                    }
                    if (r.uuid = e.uuid, void 0 !== e.name && (r.name = e.name), void 0 !== e.matrix ? (r.matrix.fromArray(e.matrix), void 0 !== e.matrixAutoUpdate && (r.matrixAutoUpdate = e.matrixAutoUpdate), r.matrixAutoUpdate && r.matrix.decompose(r.position, r.quaternion, r.scale)) : (void 0 !== e.position && r.position.fromArray(e.position), void 0 !== e.rotation && r.rotation.fromArray(e.rotation), void 0 !== e.quaternion && r.quaternion.fromArray(e.quaternion), void 0 !== e.scale && r.scale.fromArray(e.scale)), void 0 !== e.castShadow && (r.castShadow = e.castShadow), void 0 !== e.receiveShadow && (r.receiveShadow = e.receiveShadow), e.shadow && (void 0 !== e.shadow.bias && (r.shadow.bias = e.shadow.bias), void 0 !== e.shadow.normalBias && (r.shadow.normalBias = e.shadow.normalBias), void 0 !== e.shadow.radius && (r.shadow.radius = e.shadow.radius), void 0 !== e.shadow.mapSize && r.shadow.mapSize.fromArray(e.shadow.mapSize), void 0 !== e.shadow.camera && (r.shadow.camera = this.parseObject(e.shadow.camera))), void 0 !== e.visible && (r.visible = e.visible), void 0 !== e.frustumCulled && (r.frustumCulled = e.frustumCulled), void 0 !== e.renderOrder && (r.renderOrder = e.renderOrder), void 0 !== e.userData && (r.userData = e.userData), void 0 !== e.layers && (r.layers.mask = e.layers), void 0 !== e.children) {
                        const a = e.children;
                        for (let e = 0; e < a.length; e++) r.add(this.parseObject(a[e], t, n, i))
                    }
                    if (void 0 !== e.animations) {
                        const t = e.animations;
                        for (let e = 0; e < t.length; e++) {
                            const n = t[e];
                            r.animations.push(i[n])
                        }
                    }
                    if ("LOD" === e.type) {
                        void 0 !== e.autoUpdate && (r.autoUpdate = e.autoUpdate);
                        const t = e.levels;
                        for (let e = 0; e < t.length; e++) {
                            const n = t[e],
                                i = r.getObjectByProperty("uuid", n.object);
                            void 0 !== i && r.addLevel(i, n.distance)
                        }
                    }
                    return r
                }
                bindSkeletons(e, t) {
                    0 !== Object.keys(t).length && e.traverse((function(e) {
                        if (!0 === e.isSkinnedMesh && void 0 !== e.skeleton) {
                            const n = t[e.skeleton];
                            void 0 === n || e.bind(n, e.bindMatrix)
                        }
                    }))
                }
                setTexturePath(e) {
                    return this.setResourcePath(e)
                }
            }
            const jl = {
                    UVMapping: $n,
                    CubeReflectionMapping: ei,
                    CubeRefractionMapping: ti,
                    EquirectangularReflectionMapping: ni,
                    EquirectangularRefractionMapping: ii,
                    CubeUVReflectionMapping: ri,
                    CubeUVRefractionMapping: ai
                },
                Wl = {
                    RepeatWrapping: oi,
                    ClampToEdgeWrapping: si,
                    MirroredRepeatWrapping: li
                },
                Hl = {
                    NearestFilter: ci,
                    NearestMipmapNearestFilter: ui,
                    NearestMipmapLinearFilter: di,
                    LinearFilter: fi,
                    LinearMipmapNearestFilter: mi,
                    LinearMipmapLinearFilter: vi
                };
            let Xl;
            ImageBitmapLoader.prototype = Object.assign(Object.create(Loader.prototype), {
                constructor: ImageBitmapLoader,
                isImageBitmapLoader: !0,
                setOptions: function setOptions(e) {
                    return this.options = e, this
                },
                load: function(e, t, n, i) {
                    void 0 === e && (e = ""), void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e);
                    const r = this,
                        a = Rl.get(e);
                    if (void 0 !== a) return r.manager.itemStart(e), setTimeout((function() {
                        t && t(a), r.manager.itemEnd(e)
                    }), 0), a;
                    const o = {};
                    o.credentials = "anonymous" === this.crossOrigin ? "same-origin" : "include", fetch(e, o).then((function(e) {
                        return e.blob()
                    })).then((function(e) {
                        return createImageBitmap(e, r.options)
                    })).then((function(n) {
                        Rl.add(e, n), t && t(n), r.manager.itemEnd(e)
                    })).catch((function(t) {
                        i && i(t), r.manager.itemError(e), r.manager.itemEnd(e)
                    })), r.manager.itemStart(e)
                }
            }), Object.assign(ShapePath.prototype, {
                moveTo: function(e, t) {
                    return this.currentPath = new Path, this.subPaths.push(this.currentPath), this.currentPath.moveTo(e, t), this
                },
                lineTo: function(e, t) {
                    return this.currentPath.lineTo(e, t), this
                },
                quadraticCurveTo: function(e, t, n, i) {
                    return this.currentPath.quadraticCurveTo(e, t, n, i), this
                },
                bezierCurveTo: function(e, t, n, i, r, a) {
                    return this.currentPath.bezierCurveTo(e, t, n, i, r, a), this
                },
                splineThru: function(e) {
                    return this.currentPath.splineThru(e), this
                },
                toShapes: function(e, t) {
                    function toShapesNoHoles(e) {
                        const t = [];
                        for (let n = 0, i = e.length; n < i; n++) {
                            const i = e[n],
                                r = new Shape;
                            r.curves = i.curves, t.push(r)
                        }
                        return t
                    }

                    function isPointInsidePolygon(e, t) {
                        const n = t.length;
                        let i = !1;
                        for (let r = n - 1, a = 0; a < n; r = a++) {
                            let n = t[r],
                                o = t[a],
                                s = o.x - n.x,
                                l = o.y - n.y;
                            if (Math.abs(l) > Number.EPSILON) {
                                if (l < 0 && (n = t[a], s = -s, o = t[r], l = -l), e.y < n.y || e.y > o.y) continue;
                                if (e.y === n.y) {
                                    if (e.x === n.x) return !0
                                } else {
                                    const t = l * (e.x - n.x) - s * (e.y - n.y);
                                    if (0 === t) return !0;
                                    if (t < 0) continue;
                                    i = !i
                                }
                            } else {
                                if (e.y !== n.y) continue;
                                if (o.x <= e.x && e.x <= n.x || n.x <= e.x && e.x <= o.x) return !0
                            }
                        }
                        return i
                    }
                    const n = Fl.isClockWise,
                        i = this.subPaths;
                    if (0 === i.length) return [];
                    if (!0 === t) return toShapesNoHoles(i);
                    let r, a, o;
                    const s = [];
                    if (1 === i.length) return a = i[0], o = new Shape, o.curves = a.curves, s.push(o), s;
                    let l = !n(i[0].getPoints());
                    l = e ? !l : l;
                    const c = [],
                        u = [];
                    let h, d, p = [],
                        f = 0;
                    u[f] = void 0, p[f] = [];
                    for (let t = 0, o = i.length; t < o; t++) a = i[t], h = a.getPoints(), r = n(h), r = e ? !r : r, r ? (!l && u[f] && f++, u[f] = {
                        s: new Shape,
                        p: h
                    }, u[f].s.curves = a.curves, l && f++, p[f] = []) : p[f].push({
                        h: a,
                        p: h[0]
                    });
                    if (!u[0]) return toShapesNoHoles(i);
                    if (u.length > 1) {
                        let e = !1;
                        const t = [];
                        for (let e = 0, t = u.length; e < t; e++) c[e] = [];
                        for (let n = 0, i = u.length; n < i; n++) {
                            const i = p[n];
                            for (let r = 0; r < i.length; r++) {
                                const a = i[r];
                                let o = !0;
                                for (let i = 0; i < u.length; i++) isPointInsidePolygon(a.p, u[i].p) && (n !== i && t.push({
                                    froms: n,
                                    tos: i,
                                    hole: r
                                }), o ? (o = !1, c[i].push(a)) : e = !0);
                                o && c[n].push(a)
                            }
                        }
                        t.length > 0 && (e || (p = c))
                    }
                    for (let e = 0, t = u.length; e < t; e++) {
                        o = u[e].s, s.push(o), d = p[e];
                        for (let e = 0, t = d.length; e < t; e++) o.holes.push(d[e].h)
                    }
                    return s
                }
            }), Object.assign(Font.prototype, {
                isFont: !0,
                generateShapes: function(e, t = 100) {
                    const n = [],
                        i = function createPaths(e, t, n) {
                            const i = Array.from ? Array.from(e) : (e + "").split(""),
                                r = t / n.resolution,
                                a = (n.boundingBox.yMax - n.boundingBox.yMin + n.underlineThickness) * r,
                                o = [];
                            let s = 0,
                                l = 0;
                            for (let e = 0; e < i.length; e++) {
                                const t = i[e];
                                if ("\n" === t) s = 0, l -= a;
                                else {
                                    const e = createPath(t, r, s, l, n);
                                    s += e.offsetX, o.push(e.path)
                                }
                            }
                            return o
                        }(e, t, this.data);
                    for (let e = 0, t = i.length; e < t; e++) Array.prototype.push.apply(n, i[e].toShapes());
                    return n
                }
            }), FontLoader.prototype = Object.assign(Object.create(Loader.prototype), {
                constructor: FontLoader,
                load: function(e, t, n, i) {
                    const r = this,
                        a = new FileLoader(this.manager);
                    a.setPath(this.path), a.setRequestHeader(this.requestHeader), a.setWithCredentials(r.withCredentials), a.load(e, (function(e) {
                        let n;
                        try {
                            n = JSON.parse(e)
                        } catch (t) {
                            n = JSON.parse(e.substring(65, e.length - 2))
                        }
                        const i = r.parse(n);
                        t && t(i)
                    }), n, i)
                },
                parse: function(e) {
                    return new Font(e)
                }
            });
            const Yl = {
                getContext: function() {
                    return void 0 === Xl && (Xl = new(window.AudioContext || window.webkitAudioContext)), Xl
                },
                setContext: function(e) {
                    Xl = e
                }
            };
            AudioLoader.prototype = Object.assign(Object.create(Loader.prototype), {
                constructor: AudioLoader,
                load: function(e, t, n, i) {
                    const r = this,
                        a = new FileLoader(r.manager);
                    a.setResponseType("arraybuffer"), a.setPath(r.path), a.setRequestHeader(r.requestHeader), a.setWithCredentials(r.withCredentials), a.load(e, (function(n) {
                        try {
                            const e = n.slice(0);
                            Yl.getContext().decodeAudioData(e, (function(e) {
                                t(e)
                            }))
                        } catch (t) {
                            i && i(t), r.manager.itemError(e)
                        }
                    }), n, i)
                }
            }), HemisphereLightProbe.prototype = Object.assign(Object.create(LightProbe.prototype), {
                constructor: HemisphereLightProbe,
                isHemisphereLightProbe: !0,
                copy: function(e) {
                    return LightProbe.prototype.copy.call(this, e), this
                },
                toJSON: function(e) {
                    return LightProbe.prototype.toJSON.call(this, e)
                }
            }), AmbientLightProbe.prototype = Object.assign(Object.create(LightProbe.prototype), {
                constructor: AmbientLightProbe,
                isAmbientLightProbe: !0,
                copy: function(e) {
                    return LightProbe.prototype.copy.call(this, e), this
                },
                toJSON: function(e) {
                    return LightProbe.prototype.toJSON.call(this, e)
                }
            });
            const ql = new Matrix4,
                Ql = new Matrix4;
            Object.assign(StereoCamera.prototype, {
                update: function(e) {
                    const t = this._cache;
                    if (t.focus !== e.focus || t.fov !== e.fov || t.aspect !== e.aspect * this.aspect || t.near !== e.near || t.far !== e.far || t.zoom !== e.zoom || t.eyeSep !== this.eyeSep) {
                        t.focus = e.focus, t.fov = e.fov, t.aspect = e.aspect * this.aspect, t.near = e.near, t.far = e.far, t.zoom = e.zoom, t.eyeSep = this.eyeSep;
                        const n = e.projectionMatrix.clone(),
                            i = t.eyeSep / 2,
                            r = i * t.near / t.focus,
                            a = t.near * Math.tan(Fa.DEG2RAD * t.fov * .5) / t.zoom;
                        let o, s;
                        Ql.elements[12] = -i, ql.elements[12] = i, o = -a * t.aspect + r, s = a * t.aspect + r, n.elements[0] = 2 * t.near / (s - o), n.elements[8] = (s + o) / (s - o), this.cameraL.projectionMatrix.copy(n), o = -a * t.aspect - r, s = a * t.aspect - r, n.elements[0] = 2 * t.near / (s - o), n.elements[8] = (s + o) / (s - o), this.cameraR.projectionMatrix.copy(n)
                    }
                    this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(Ql), this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(ql)
                }
            });
            class Clock {
                constructor(e) {
                    this.autoStart = void 0 === e || e, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1
                }
                start() {
                    this.startTime = now(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0
                }
                stop() {
                    this.getElapsedTime(), this.running = !1, this.autoStart = !1
                }
                getElapsedTime() {
                    return this.getDelta(), this.elapsedTime
                }
                getDelta() {
                    let e = 0;
                    if (this.autoStart && !this.running) return this.start(), 0;
                    if (this.running) {
                        const t = now();
                        e = (t - this.oldTime) / 1e3, this.oldTime = t, this.elapsedTime += e
                    }
                    return e
                }
            }
            const Jl = new Vector3,
                Zl = new Quaternion,
                Kl = new Vector3,
                $l = new Vector3;
            class AudioListener extends Object3D {
                constructor() {
                    super(), this.type = "AudioListener", this.context = Yl.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0, this._clock = new Clock
                }
                getInput() {
                    return this.gain
                }
                removeFilter() {
                    return null !== this.filter && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this
                }
                getFilter() {
                    return this.filter
                }
                setFilter(e) {
                    return null !== this.filter ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = e, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this
                }
                getMasterVolume() {
                    return this.gain.gain.value
                }
                setMasterVolume(e) {
                    return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01), this
                }
                updateMatrixWorld(e) {
                    super.updateMatrixWorld(e);
                    const t = this.context.listener,
                        n = this.up;
                    if (this.timeDelta = this._clock.getDelta(), this.matrixWorld.decompose(Jl, Zl, Kl), $l.set(0, 0, -1).applyQuaternion(Zl), t.positionX) {
                        const e = this.context.currentTime + this.timeDelta;
                        t.positionX.linearRampToValueAtTime(Jl.x, e), t.positionY.linearRampToValueAtTime(Jl.y, e), t.positionZ.linearRampToValueAtTime(Jl.z, e), t.forwardX.linearRampToValueAtTime($l.x, e), t.forwardY.linearRampToValueAtTime($l.y, e), t.forwardZ.linearRampToValueAtTime($l.z, e), t.upX.linearRampToValueAtTime(n.x, e), t.upY.linearRampToValueAtTime(n.y, e), t.upZ.linearRampToValueAtTime(n.z, e)
                    } else t.setPosition(Jl.x, Jl.y, Jl.z), t.setOrientation($l.x, $l.y, $l.z, n.x, n.y, n.z)
                }
            }
            class Audio extends Object3D {
                constructor(e) {
                    super(), this.type = "Audio", this.listener = e, this.context = e.context, this.gain = this.context.createGain(), this.gain.connect(e.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = !1, this.filters = []
                }
                getOutput() {
                    return this.gain
                }
                setNodeSource(e) {
                    return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = e, this.connect(), this
                }
                setMediaElementSource(e) {
                    return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(e), this.connect(), this
                }
                setMediaStreamSource(e) {
                    return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(e), this.connect(), this
                }
                setBuffer(e) {
                    return this.buffer = e, this.sourceType = "buffer", this.autoplay && this.play(), this
                }
                play(e = 0) {
                    if (!0 === this.isPlaying) return;
                    if (!1 === this.hasPlaybackControl) return;
                    this._startedAt = this.context.currentTime + e;
                    const t = this.context.createBufferSource();
                    return t.buffer = this.buffer, t.loop = this.loop, t.loopStart = this.loopStart, t.loopEnd = this.loopEnd, t.onended = this.onEnded.bind(this), t.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = !0, this.source = t, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect()
                }
                pause() {
                    if (!1 !== this.hasPlaybackControl) return !0 === this.isPlaying && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, !0 === this.loop && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = !1), this
                }
                stop() {
                    if (!1 !== this.hasPlaybackControl) return this._progress = 0, this.source.stop(), this.source.onended = null, this.isPlaying = !1, this
                }
                connect() {
                    if (this.filters.length > 0) {
                        this.source.connect(this.filters[0]);
                        for (let e = 1, t = this.filters.length; e < t; e++) this.filters[e - 1].connect(this.filters[e]);
                        this.filters[this.filters.length - 1].connect(this.getOutput())
                    } else this.source.connect(this.getOutput());
                    return this._connected = !0, this
                }
                disconnect() {
                    if (this.filters.length > 0) {
                        this.source.disconnect(this.filters[0]);
                        for (let e = 1, t = this.filters.length; e < t; e++) this.filters[e - 1].disconnect(this.filters[e]);
                        this.filters[this.filters.length - 1].disconnect(this.getOutput())
                    } else this.source.disconnect(this.getOutput());
                    return this._connected = !1, this
                }
                getFilters() {
                    return this.filters
                }
                setFilters(e) {
                    return e || (e = []), !0 === this._connected ? (this.disconnect(), this.filters = e.slice(), this.connect()) : this.filters = e.slice(), this
                }
                setDetune(e) {
                    if (this.detune = e, void 0 !== this.source.detune) return !0 === this.isPlaying && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01), this
                }
                getDetune() {
                    return this.detune
                }
                getFilter() {
                    return this.getFilters()[0]
                }
                setFilter(e) {
                    return this.setFilters(e ? [e] : [])
                }
                setPlaybackRate(e) {
                    if (!1 !== this.hasPlaybackControl) return this.playbackRate = e, !0 === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01), this
                }
                getPlaybackRate() {
                    return this.playbackRate
                }
                onEnded() {
                    this.isPlaying = !1
                }
                getLoop() {
                    return !1 !== this.hasPlaybackControl && this.loop
                }
                setLoop(e) {
                    if (!1 !== this.hasPlaybackControl) return this.loop = e, !0 === this.isPlaying && (this.source.loop = this.loop), this
                }
                setLoopStart(e) {
                    return this.loopStart = e, this
                }
                setLoopEnd(e) {
                    return this.loopEnd = e, this
                }
                getVolume() {
                    return this.gain.gain.value
                }
                setVolume(e) {
                    return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01), this
                }
            }
            const ec = new Vector3,
                tc = new Quaternion,
                nc = new Vector3,
                ic = new Vector3;
            class PositionalAudio extends Audio {
                constructor(e) {
                    super(e), this.panner = this.context.createPanner(), this.panner.panningModel = "HRTF", this.panner.connect(this.gain)
                }
                getOutput() {
                    return this.panner
                }
                getRefDistance() {
                    return this.panner.refDistance
                }
                setRefDistance(e) {
                    return this.panner.refDistance = e, this
                }
                getRolloffFactor() {
                    return this.panner.rolloffFactor
                }
                setRolloffFactor(e) {
                    return this.panner.rolloffFactor = e, this
                }
                getDistanceModel() {
                    return this.panner.distanceModel
                }
                setDistanceModel(e) {
                    return this.panner.distanceModel = e, this
                }
                getMaxDistance() {
                    return this.panner.maxDistance
                }
                setMaxDistance(e) {
                    return this.panner.maxDistance = e, this
                }
                setDirectionalCone(e, t, n) {
                    return this.panner.coneInnerAngle = e, this.panner.coneOuterAngle = t, this.panner.coneOuterGain = n, this
                }
                updateMatrixWorld(e) {
                    if (super.updateMatrixWorld(e), !0 === this.hasPlaybackControl && !1 === this.isPlaying) return;
                    this.matrixWorld.decompose(ec, tc, nc), ic.set(0, 0, 1).applyQuaternion(tc);
                    const t = this.panner;
                    if (t.positionX) {
                        const e = this.context.currentTime + this.listener.timeDelta;
                        t.positionX.linearRampToValueAtTime(ec.x, e), t.positionY.linearRampToValueAtTime(ec.y, e), t.positionZ.linearRampToValueAtTime(ec.z, e), t.orientationX.linearRampToValueAtTime(ic.x, e), t.orientationY.linearRampToValueAtTime(ic.y, e), t.orientationZ.linearRampToValueAtTime(ic.z, e)
                    } else t.setPosition(ec.x, ec.y, ec.z), t.setOrientation(ic.x, ic.y, ic.z)
                }
            }
            class AudioAnalyser {
                constructor(e, t = 2048) {
                    this.analyser = e.context.createAnalyser(), this.analyser.fftSize = t, this.data = new Uint8Array(this.analyser.frequencyBinCount), e.getOutput().connect(this.analyser)
                }
                getFrequencyData() {
                    return this.analyser.getByteFrequencyData(this.data), this.data
                }
                getAverageFrequency() {
                    let e = 0;
                    const t = this.getFrequencyData();
                    for (let n = 0; n < t.length; n++) e += t[n];
                    return e / t.length
                }
            }
            Object.assign(PropertyMixer.prototype, {
                accumulate: function(e, t) {
                    const n = this.buffer,
                        i = this.valueSize,
                        r = e * i + i;
                    let a = this.cumulativeWeight;
                    if (0 === a) {
                        for (let e = 0; e !== i; ++e) n[r + e] = n[e];
                        a = t
                    } else {
                        a += t;
                        const e = t / a;
                        this._mixBufferRegion(n, r, 0, e, i)
                    }
                    this.cumulativeWeight = a
                },
                accumulateAdditive: function(e) {
                    const t = this.buffer,
                        n = this.valueSize,
                        i = n * this._addIndex;
                    0 === this.cumulativeWeightAdditive && this._setIdentity(), this._mixBufferRegionAdditive(t, i, 0, e, n), this.cumulativeWeightAdditive += e
                },
                apply: function(e) {
                    const t = this.valueSize,
                        n = this.buffer,
                        i = e * t + t,
                        r = this.cumulativeWeight,
                        a = this.cumulativeWeightAdditive,
                        o = this.binding;
                    if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, r < 1) {
                        const e = t * this._origIndex;
                        this._mixBufferRegion(n, i, e, 1 - r, t)
                    }
                    a > 0 && this._mixBufferRegionAdditive(n, i, this._addIndex * t, 1, t);
                    for (let e = t, r = t + t; e !== r; ++e)
                        if (n[e] !== n[e + t]) {
                            o.setValue(n, i);
                            break
                        }
                },
                saveOriginalState: function() {
                    const e = this.binding,
                        t = this.buffer,
                        n = this.valueSize,
                        i = n * this._origIndex;
                    e.getValue(t, i);
                    for (let e = n, r = i; e !== r; ++e) t[e] = t[i + e % n];
                    this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0
                },
                restoreOriginalState: function() {
                    const e = 3 * this.valueSize;
                    this.binding.setValue(this.buffer, e)
                },
                _setAdditiveIdentityNumeric: function() {
                    const e = this._addIndex * this.valueSize,
                        t = e + this.valueSize;
                    for (let n = e; n < t; n++) this.buffer[n] = 0
                },
                _setAdditiveIdentityQuaternion: function() {
                    this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1
                },
                _setAdditiveIdentityOther: function() {
                    const e = this._origIndex * this.valueSize,
                        t = this._addIndex * this.valueSize;
                    for (let n = 0; n < this.valueSize; n++) this.buffer[t + n] = this.buffer[e + n]
                },
                _select: function(e, t, n, i, r) {
                    if (i >= .5)
                        for (let i = 0; i !== r; ++i) e[t + i] = e[n + i]
                },
                _slerp: function(e, t, n, i) {
                    Quaternion.slerpFlat(e, t, e, t, e, n, i)
                },
                _slerpAdditive: function(e, t, n, i, r) {
                    const a = this._workIndex * r;
                    Quaternion.multiplyQuaternionsFlat(e, a, e, t, e, n), Quaternion.slerpFlat(e, t, e, t, e, a, i)
                },
                _lerp: function(e, t, n, i, r) {
                    const a = 1 - i;
                    for (let o = 0; o !== r; ++o) {
                        const r = t + o;
                        e[r] = e[r] * a + e[n + o] * i
                    }
                },
                _lerpAdditive: function(e, t, n, i, r) {
                    for (let a = 0; a !== r; ++a) {
                        const r = t + a;
                        e[r] = e[r] + e[n + a] * i
                    }
                }
            });
            const rc = /[\[\]\.:\/]/g,
                ac = /^((?:[^\[\]\.:\/]+[\/:])*)([^\[\]:\/]+)?(?:\.([^\[\]\.:\/]+)(?:\[(.+)\])?)?\.([^\[\]\.:\/]+)(?:\[(.+)\])?$/,
                oc = ["material", "materials", "bones"];
            Object.assign(Composite.prototype, {
                getValue: function(e, t) {
                    this.bind();
                    const n = this._targetGroup.nCachedObjects_,
                        i = this._bindings[n];
                    void 0 !== i && i.getValue(e, t)
                },
                setValue: function(e, t) {
                    const n = this._bindings;
                    for (let i = this._targetGroup.nCachedObjects_, r = n.length; i !== r; ++i) n[i].setValue(e, t)
                },
                bind: function() {
                    const e = this._bindings;
                    for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t) e[t].bind()
                },
                unbind: function() {
                    const e = this._bindings;
                    for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t) e[t].unbind()
                }
            }), Object.assign(PropertyBinding, {
                Composite,
                create: function(e, t, n) {
                    return e && e.isAnimationObjectGroup ? new PropertyBinding.Composite(e, t, n) : new PropertyBinding(e, t, n)
                },
                sanitizeNodeName: function(e) {
                    return e.replace(/\s/g, "_").replace(rc, "")
                },
                parseTrackName: function(e) {
                    const t = ac.exec(e);
                    if (!t) throw Error("PropertyBinding: Cannot parse trackName: " + e);
                    const n = {
                            nodeName: t[2],
                            objectName: t[3],
                            objectIndex: t[4],
                            propertyName: t[5],
                            propertyIndex: t[6]
                        },
                        i = n.nodeName && n.nodeName.lastIndexOf(".");
                    if (void 0 !== i && -1 !== i) {
                        const e = n.nodeName.substring(i + 1); - 1 !== oc.indexOf(e) && (n.nodeName = n.nodeName.substring(0, i), n.objectName = e)
                    }
                    if (null === n.propertyName || 0 === n.propertyName.length) throw Error("PropertyBinding: can not parse propertyName from trackName: " + e);
                    return n
                },
                findNode: function(e, t) {
                    if (!t || "" === t || "." === t || -1 === t || t === e.name || t === e.uuid) return e;
                    if (e.skeleton) {
                        const n = e.skeleton.getBoneByName(t);
                        if (void 0 !== n) return n
                    }
                    if (e.children) {
                        const searchNodeSubtree = function(e) {
                                for (let n = 0; n < e.length; n++) {
                                    const i = e[n];
                                    if (i.name === t || i.uuid === t) return i;
                                    const r = searchNodeSubtree(i.children);
                                    if (r) return r
                                }
                                return null
                            },
                            n = searchNodeSubtree(e.children);
                        if (n) return n
                    }
                    return null
                }
            }), Object.assign(PropertyBinding.prototype, {
                _getValue_unavailable: function() {},
                _setValue_unavailable: function() {},
                BindingType: {
                    Direct: 0,
                    EntireArray: 1,
                    ArrayElement: 2,
                    HasFromToArray: 3
                },
                Versioning: {
                    None: 0,
                    NeedsUpdate: 1,
                    MatrixWorldNeedsUpdate: 2
                },
                GetterByBindingType: [function getValue_direct(e, t) {
                    e[t] = this.node[this.propertyName]
                }, function getValue_array(e, t) {
                    const n = this.resolvedProperty;
                    for (let i = 0, r = n.length; i !== r; ++i) e[t++] = n[i]
                }, function getValue_arrayElement(e, t) {
                    e[t] = this.resolvedProperty[this.propertyIndex]
                }, function getValue_toArray(e, t) {
                    this.resolvedProperty.toArray(e, t)
                }],
                SetterByBindingTypeAndVersioning: [
                    [function setValue_direct(e, t) {
                        this.targetObject[this.propertyName] = e[t]
                    }, function setValue_direct_setNeedsUpdate(e, t) {
                        this.targetObject[this.propertyName] = e[t], this.targetObject.needsUpdate = !0
                    }, function setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
                        this.targetObject[this.propertyName] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0
                    }],
                    [function setValue_array(e, t) {
                        const n = this.resolvedProperty;
                        for (let i = 0, r = n.length; i !== r; ++i) n[i] = e[t++]
                    }, function setValue_array_setNeedsUpdate(e, t) {
                        const n = this.resolvedProperty;
                        for (let i = 0, r = n.length; i !== r; ++i) n[i] = e[t++];
                        this.targetObject.needsUpdate = !0
                    }, function setValue_array_setMatrixWorldNeedsUpdate(e, t) {
                        const n = this.resolvedProperty;
                        for (let i = 0, r = n.length; i !== r; ++i) n[i] = e[t++];
                        this.targetObject.matrixWorldNeedsUpdate = !0
                    }],
                    [function setValue_arrayElement(e, t) {
                        this.resolvedProperty[this.propertyIndex] = e[t]
                    }, function setValue_arrayElement_setNeedsUpdate(e, t) {
                        this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.needsUpdate = !0
                    }, function setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
                        this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0
                    }],
                    [function setValue_fromArray(e, t) {
                        this.resolvedProperty.fromArray(e, t)
                    }, function setValue_fromArray_setNeedsUpdate(e, t) {
                        this.resolvedProperty.fromArray(e, t), this.targetObject.needsUpdate = !0
                    }, function setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
                        this.resolvedProperty.fromArray(e, t), this.targetObject.matrixWorldNeedsUpdate = !0
                    }]
                ],
                getValue: function getValue_unbound(e, t) {
                    this.bind(), this.getValue(e, t)
                },
                setValue: function getValue_unbound(e, t) {
                    this.bind(), this.setValue(e, t)
                },
                bind: function() {
                    let e = this.node;
                    const t = this.parsedPath,
                        n = t.objectName,
                        i = t.propertyName;
                    let r = t.propertyIndex;
                    if (e || (e = PropertyBinding.findNode(this.rootNode, t.nodeName) || this.rootNode, this.node = e), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !e) return;
                    if (n) {
                        let i = t.objectIndex;
                        switch (n) {
                            case "materials":
                                if (!e.material) return;
                                if (!e.material.materials) return;
                                e = e.material.materials;
                                break;
                            case "bones":
                                if (!e.skeleton) return;
                                e = e.skeleton.bones;
                                for (let t = 0; t < e.length; t++)
                                    if (e[t].name === i) {
                                        i = t;
                                        break
                                    }
                                break;
                            default:
                                if (void 0 === e[n]) return;
                                e = e[n]
                        }
                        if (void 0 !== i) {
                            if (void 0 === e[i]) return;
                            e = e[i]
                        }
                    }
                    const a = e[i];
                    if (void 0 === a) {
                        t.nodeName;
                        return
                    }
                    let o = this.Versioning.None;
                    this.targetObject = e, void 0 !== e.needsUpdate ? o = this.Versioning.NeedsUpdate : void 0 !== e.matrixWorldNeedsUpdate && (o = this.Versioning.MatrixWorldNeedsUpdate);
                    let s = this.BindingType.Direct;
                    if (void 0 !== r) {
                        if ("morphTargetInfluences" === i) {
                            if (!e.geometry) return;
                            if (!e.geometry.isBufferGeometry) return;
                            if (!e.geometry.morphAttributes) return;
                            void 0 !== e.morphTargetDictionary[r] && (r = e.morphTargetDictionary[r])
                        }
                        s = this.BindingType.ArrayElement, this.resolvedProperty = a, this.propertyIndex = r
                    } else void 0 !== a.fromArray && void 0 !== a.toArray ? (s = this.BindingType.HasFromToArray, this.resolvedProperty = a) : Array.isArray(a) ? (s = this.BindingType.EntireArray, this.resolvedProperty = a) : this.propertyName = i;
                    this.getValue = this.GetterByBindingType[s], this.setValue = this.SetterByBindingTypeAndVersioning[s][o]
                },
                unbind: function() {
                    this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
                }
            }), Object.assign(PropertyBinding.prototype, {
                _getValue_unbound: PropertyBinding.prototype.getValue,
                _setValue_unbound: PropertyBinding.prototype.setValue
            }), Object.assign(AnimationObjectGroup.prototype, {
                isAnimationObjectGroup: !0,
                add: function() {
                    const e = this._objects,
                        t = this._indicesByUUID,
                        n = this._paths,
                        i = this._parsedPaths,
                        r = this._bindings,
                        a = r.length;
                    let o, s = e.length,
                        l = this.nCachedObjects_;
                    for (let c = 0, u = arguments.length; c !== u; ++c) {
                        const u = arguments[c],
                            h = u.uuid;
                        let d = t[h];
                        if (void 0 === d) {
                            d = s++, t[h] = d, e.push(u);
                            for (let e = 0, t = a; e !== t; ++e) r[e].push(new PropertyBinding(u, n[e], i[e]))
                        } else if (d < l) {
                            o = e[d];
                            const s = --l,
                                c = e[s];
                            t[c.uuid] = d, e[d] = c, t[h] = s, e[s] = u;
                            for (let e = 0, t = a; e !== t; ++e) {
                                const t = r[e],
                                    a = t[s];
                                let o = t[d];
                                t[d] = a, void 0 === o && (o = new PropertyBinding(u, n[e], i[e])), t[s] = o
                            }
                        } else e[d]
                    }
                    this.nCachedObjects_ = l
                },
                remove: function() {
                    const e = this._objects,
                        t = this._indicesByUUID,
                        n = this._bindings,
                        i = n.length;
                    let r = this.nCachedObjects_;
                    for (let a = 0, o = arguments.length; a !== o; ++a) {
                        const o = arguments[a],
                            s = o.uuid,
                            l = t[s];
                        if (void 0 !== l && l >= r) {
                            const a = r++,
                                c = e[a];
                            t[c.uuid] = l, e[l] = c, t[s] = a, e[a] = o;
                            for (let e = 0, t = i; e !== t; ++e) {
                                const t = n[e],
                                    i = t[a],
                                    r = t[l];
                                t[l] = i, t[a] = r
                            }
                        }
                    }
                    this.nCachedObjects_ = r
                },
                uncache: function() {
                    const e = this._objects,
                        t = this._indicesByUUID,
                        n = this._bindings,
                        i = n.length;
                    let r = this.nCachedObjects_,
                        a = e.length;
                    for (let o = 0, s = arguments.length; o !== s; ++o) {
                        const s = arguments[o].uuid,
                            l = t[s];
                        if (void 0 !== l)
                            if (delete t[s], l < r) {
                                const o = --r,
                                    s = e[o],
                                    c = --a,
                                    u = e[c];
                                t[s.uuid] = l, e[l] = s, t[u.uuid] = o, e[o] = u, e.pop();
                                for (let e = 0, t = i; e !== t; ++e) {
                                    const t = n[e],
                                        i = t[o],
                                        r = t[c];
                                    t[l] = i, t[o] = r, t.pop()
                                }
                            } else {
                                const r = --a,
                                    o = e[r];
                                r > 0 && (t[o.uuid] = l), e[l] = o, e.pop();
                                for (let e = 0, t = i; e !== t; ++e) {
                                    const t = n[e];
                                    t[l] = t[r], t.pop()
                                }
                            }
                    }
                    this.nCachedObjects_ = r
                },
                subscribe_: function(e, t) {
                    const n = this._bindingsIndicesByPath;
                    let i = n[e];
                    const r = this._bindings;
                    if (void 0 !== i) return r[i];
                    const a = this._paths,
                        o = this._parsedPaths,
                        s = this._objects,
                        l = s.length,
                        c = this.nCachedObjects_,
                        u = Array(l);
                    i = r.length, n[e] = i, a.push(e), o.push(t), r.push(u);
                    for (let n = c, i = s.length; n !== i; ++n) {
                        const i = s[n];
                        u[n] = new PropertyBinding(i, e, t)
                    }
                    return u
                },
                unsubscribe_: function(e) {
                    const t = this._bindingsIndicesByPath,
                        n = t[e];
                    if (void 0 !== n) {
                        const i = this._paths,
                            r = this._parsedPaths,
                            a = this._bindings,
                            o = a.length - 1,
                            s = a[o];
                        t[e[o]] = n, a[n] = s, a.pop(), r[n] = r[o], r.pop(), i[n] = i[o], i.pop()
                    }
                }
            });
            class AnimationAction {
                constructor(e, t, n = null, i = t.blendMode) {
                    this._mixer = e, this._clip = t, this._localRoot = n, this.blendMode = i;
                    const r = t.tracks,
                        a = r.length,
                        o = Array(a),
                        s = {
                            endingStart: Dr,
                            endingEnd: Dr
                        };
                    for (let e = 0; e !== a; ++e) {
                        const t = r[e].createInterpolant(null);
                        o[e] = t, t.settings = s
                    }
                    this._interpolantSettings = s, this._interpolants = o, this._propertyBindings = Array(a), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = Fr, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0
                }
                play() {
                    return this._mixer._activateAction(this), this
                }
                stop() {
                    return this._mixer._deactivateAction(this), this.reset()
                }
                reset() {
                    return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping()
                }
                isRunning() {
                    return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this)
                }
                isScheduled() {
                    return this._mixer._isActiveAction(this)
                }
                startAt(e) {
                    return this._startTime = e, this
                }
                setLoop(e, t) {
                    return this.loop = e, this.repetitions = t, this
                }
                setEffectiveWeight(e) {
                    return this.weight = e, this._effectiveWeight = this.enabled ? e : 0, this.stopFading()
                }
                getEffectiveWeight() {
                    return this._effectiveWeight
                }
                fadeIn(e) {
                    return this._scheduleFading(e, 0, 1)
                }
                fadeOut(e) {
                    return this._scheduleFading(e, 1, 0)
                }
                crossFadeFrom(e, t, n) {
                    if (e.fadeOut(t), this.fadeIn(t), n) {
                        const n = this._clip.duration,
                            i = e._clip.duration,
                            r = i / n,
                            a = n / i;
                        e.warp(1, r, t), this.warp(a, 1, t)
                    }
                    return this
                }
                crossFadeTo(e, t, n) {
                    return e.crossFadeFrom(this, t, n)
                }
                stopFading() {
                    const e = this._weightInterpolant;
                    return null !== e && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this
                }
                setEffectiveTimeScale(e) {
                    return this.timeScale = e, this._effectiveTimeScale = this.paused ? 0 : e, this.stopWarping()
                }
                getEffectiveTimeScale() {
                    return this._effectiveTimeScale
                }
                setDuration(e) {
                    return this.timeScale = this._clip.duration / e, this.stopWarping()
                }
                syncWith(e) {
                    return this.time = e.time, this.timeScale = e.timeScale, this.stopWarping()
                }
                halt(e) {
                    return this.warp(this._effectiveTimeScale, 0, e)
                }
                warp(e, t, n) {
                    const i = this._mixer,
                        r = i.time,
                        a = this.timeScale;
                    let o = this._timeScaleInterpolant;
                    null === o && (o = i._lendControlInterpolant(), this._timeScaleInterpolant = o);
                    const s = o.parameterPositions,
                        l = o.sampleValues;
                    return s[0] = r, s[1] = r + n, l[0] = e / a, l[1] = t / a, this
                }
                stopWarping() {
                    const e = this._timeScaleInterpolant;
                    return null !== e && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this
                }
                getMixer() {
                    return this._mixer
                }
                getClip() {
                    return this._clip
                }
                getRoot() {
                    return this._localRoot || this._mixer._root
                }
                _update(e, t, n, i) {
                    if (!this.enabled) return void this._updateWeight(e);
                    const r = this._startTime;
                    if (null !== r) {
                        const i = (e - r) * n;
                        if (i < 0 || 0 === n) return;
                        this._startTime = null, t = n * i
                    }
                    t *= this._updateTimeScale(e);
                    const a = this._updateTime(t),
                        o = this._updateWeight(e);
                    if (o > 0) {
                        const e = this._interpolants,
                            t = this._propertyBindings;
                        if (this.blendMode === Gr)
                            for (let n = 0, i = e.length; n !== i; ++n) e[n].evaluate(a), t[n].accumulateAdditive(o);
                        else
                            for (let n = 0, r = e.length; n !== r; ++n) e[n].evaluate(a), t[n].accumulate(i, o)
                    }
                }
                _updateWeight(e) {
                    let t = 0;
                    if (this.enabled) {
                        t = this.weight;
                        const n = this._weightInterpolant;
                        if (null !== n) {
                            const i = n.evaluate(e)[0];
                            t *= i, e > n.parameterPositions[1] && (this.stopFading(), 0 === i && (this.enabled = !1))
                        }
                    }
                    return this._effectiveWeight = t, t
                }
                _updateTimeScale(e) {
                    let t = 0;
                    if (!this.paused) {
                        t = this.timeScale;
                        const n = this._timeScaleInterpolant;
                        if (null !== n) {
                            t *= n.evaluate(e)[0], e > n.parameterPositions[1] && (this.stopWarping(), 0 === t ? this.paused = !0 : this.timeScale = t)
                        }
                    }
                    return this._effectiveTimeScale = t, t
                }
                _updateTime(e) {
                    const t = this._clip.duration,
                        n = this.loop;
                    let i = this.time + e,
                        r = this._loopCount;
                    const a = n === Or;
                    if (0 === e) return -1 === r ? i : a && 1 == (1 & r) ? t - i : i;
                    if (n === Ir) {
                        -1 === r && (this._loopCount = 0, this._setEndings(!0, !0, !1));
                        e: {
                            if (i >= t) i = t;
                            else {
                                if (!(i < 0)) {
                                    this.time = i;
                                    break e
                                }
                                i = 0
                            }
                            this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                            this.time = i,
                            this._mixer.dispatchEvent({
                                type: "finished",
                                action: this,
                                direction: e < 0 ? -1 : 1
                            })
                        }
                    } else {
                        if (-1 === r && (e >= 0 ? (r = 0, this._setEndings(!0, 0 === this.repetitions, a)) : this._setEndings(0 === this.repetitions, !0, a)), i >= t || i < 0) {
                            const n = Math.floor(i / t);
                            i -= t * n, r += Math.abs(n);
                            const o = this.repetitions - r;
                            if (o <= 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, i = e > 0 ? t : 0, this.time = i, this._mixer.dispatchEvent({
                                type: "finished",
                                action: this,
                                direction: e > 0 ? 1 : -1
                            });
                            else {
                                if (1 === o) {
                                    const t = e < 0;
                                    this._setEndings(t, !t, a)
                                } else this._setEndings(!1, !1, a);
                                this._loopCount = r, this.time = i, this._mixer.dispatchEvent({
                                    type: "loop",
                                    action: this,
                                    loopDelta: n
                                })
                            }
                        } else this.time = i;
                        if (a && 1 == (1 & r)) return t - i
                    }
                    return i
                }
                _setEndings(e, t, n) {
                    const i = this._interpolantSettings;
                    n ? (i.endingStart = Vr, i.endingEnd = Vr) : (i.endingStart = e ? this.zeroSlopeAtStart ? Vr : Dr : Ur, i.endingEnd = t ? this.zeroSlopeAtEnd ? Vr : Dr : Ur)
                }
                _scheduleFading(e, t, n) {
                    const i = this._mixer,
                        r = i.time;
                    let a = this._weightInterpolant;
                    null === a && (a = i._lendControlInterpolant(), this._weightInterpolant = a);
                    const o = a.parameterPositions,
                        s = a.sampleValues;
                    return o[0] = r, s[0] = t, o[1] = r + e, s[1] = n, this
                }
            }
            AnimationMixer.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
                constructor: AnimationMixer,
                _bindAction: function(e, t) {
                    const n = e._localRoot || this._root,
                        i = e._clip.tracks,
                        r = i.length,
                        a = e._propertyBindings,
                        o = e._interpolants,
                        s = n.uuid,
                        l = this._bindingsByRootAndName;
                    let c = l[s];
                    void 0 === c && (c = {}, l[s] = c);
                    for (let e = 0; e !== r; ++e) {
                        const r = i[e],
                            l = r.name;
                        let u = c[l];
                        if (void 0 !== u) a[e] = u;
                        else {
                            if (u = a[e], void 0 !== u) {
                                null === u._cacheIndex && (++u.referenceCount, this._addInactiveBinding(u, s, l));
                                continue
                            }
                            const i = t && t._propertyBindings[e].binding.parsedPath;
                            u = new PropertyMixer(PropertyBinding.create(n, l, i), r.ValueTypeName, r.getValueSize()), ++u.referenceCount, this._addInactiveBinding(u, s, l), a[e] = u
                        }
                        o[e].resultBuffer = u.buffer
                    }
                },
                _activateAction: function(e) {
                    if (!this._isActiveAction(e)) {
                        if (null === e._cacheIndex) {
                            const t = (e._localRoot || this._root).uuid,
                                n = e._clip.uuid,
                                i = this._actionsByClip[n];
                            this._bindAction(e, i && i.knownActions[0]), this._addInactiveAction(e, n, t)
                        }
                        const t = e._propertyBindings;
                        for (let e = 0, n = t.length; e !== n; ++e) {
                            const n = t[e];
                            0 == n.useCount++ && (this._lendBinding(n), n.saveOriginalState())
                        }
                        this._lendAction(e)
                    }
                },
                _deactivateAction: function(e) {
                    if (this._isActiveAction(e)) {
                        const t = e._propertyBindings;
                        for (let e = 0, n = t.length; e !== n; ++e) {
                            const n = t[e];
                            0 == --n.useCount && (n.restoreOriginalState(), this._takeBackBinding(n))
                        }
                        this._takeBackAction(e)
                    }
                },
                _initMemoryManager: function() {
                    this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
                    const e = this;
                    this.stats = {
                        actions: {
                            get total() {
                                return e._actions.length
                            },
                            get inUse() {
                                return e._nActiveActions
                            }
                        },
                        bindings: {
                            get total() {
                                return e._bindings.length
                            },
                            get inUse() {
                                return e._nActiveBindings
                            }
                        },
                        controlInterpolants: {
                            get total() {
                                return e._controlInterpolants.length
                            },
                            get inUse() {
                                return e._nActiveControlInterpolants
                            }
                        }
                    }
                },
                _isActiveAction: function(e) {
                    const t = e._cacheIndex;
                    return null !== t && t < this._nActiveActions
                },
                _addInactiveAction: function(e, t, n) {
                    const i = this._actions,
                        r = this._actionsByClip;
                    let a = r[t];
                    if (void 0 === a) a = {
                        knownActions: [e],
                        actionByRoot: {}
                    }, e._byClipCacheIndex = 0, r[t] = a;
                    else {
                        const t = a.knownActions;
                        e._byClipCacheIndex = t.length, t.push(e)
                    }
                    e._cacheIndex = i.length, i.push(e), a.actionByRoot[n] = e
                },
                _removeInactiveAction: function(e) {
                    const t = this._actions,
                        n = t[t.length - 1],
                        i = e._cacheIndex;
                    n._cacheIndex = i, t[i] = n, t.pop(), e._cacheIndex = null;
                    const r = e._clip.uuid,
                        a = this._actionsByClip,
                        o = a[r],
                        s = o.knownActions,
                        l = s[s.length - 1],
                        c = e._byClipCacheIndex;
                    l._byClipCacheIndex = c, s[c] = l, s.pop(), e._byClipCacheIndex = null;
                    delete o.actionByRoot[(e._localRoot || this._root).uuid], 0 === s.length && delete a[r], this._removeInactiveBindingsForAction(e)
                },
                _removeInactiveBindingsForAction: function(e) {
                    const t = e._propertyBindings;
                    for (let e = 0, n = t.length; e !== n; ++e) {
                        const n = t[e];
                        0 == --n.referenceCount && this._removeInactiveBinding(n)
                    }
                },
                _lendAction: function(e) {
                    const t = this._actions,
                        n = e._cacheIndex,
                        i = this._nActiveActions++,
                        r = t[i];
                    e._cacheIndex = i, t[i] = e, r._cacheIndex = n, t[n] = r
                },
                _takeBackAction: function(e) {
                    const t = this._actions,
                        n = e._cacheIndex,
                        i = --this._nActiveActions,
                        r = t[i];
                    e._cacheIndex = i, t[i] = e, r._cacheIndex = n, t[n] = r
                },
                _addInactiveBinding: function(e, t, n) {
                    const i = this._bindingsByRootAndName,
                        r = this._bindings;
                    let a = i[t];
                    void 0 === a && (a = {}, i[t] = a), a[n] = e, e._cacheIndex = r.length, r.push(e)
                },
                _removeInactiveBinding: function(e) {
                    const t = this._bindings,
                        n = e.binding,
                        i = n.rootNode.uuid,
                        r = n.path,
                        a = this._bindingsByRootAndName,
                        o = a[i],
                        s = t[t.length - 1],
                        l = e._cacheIndex;
                    s._cacheIndex = l, t[l] = s, t.pop(), delete o[r], 0 === Object.keys(o).length && delete a[i]
                },
                _lendBinding: function(e) {
                    const t = this._bindings,
                        n = e._cacheIndex,
                        i = this._nActiveBindings++,
                        r = t[i];
                    e._cacheIndex = i, t[i] = e, r._cacheIndex = n, t[n] = r
                },
                _takeBackBinding: function(e) {
                    const t = this._bindings,
                        n = e._cacheIndex,
                        i = --this._nActiveBindings,
                        r = t[i];
                    e._cacheIndex = i, t[i] = e, r._cacheIndex = n, t[n] = r
                },
                _lendControlInterpolant: function() {
                    const e = this._controlInterpolants,
                        t = this._nActiveControlInterpolants++;
                    let n = e[t];
                    return void 0 === n && (n = new LinearInterpolant(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer), n.__cacheIndex = t, e[t] = n), n
                },
                _takeBackControlInterpolant: function(e) {
                    const t = this._controlInterpolants,
                        n = e.__cacheIndex,
                        i = --this._nActiveControlInterpolants,
                        r = t[i];
                    e.__cacheIndex = i, t[i] = e, r.__cacheIndex = n, t[n] = r
                },
                _controlInterpolantsResultBuffer: new Float32Array(1),
                clipAction: function(e, t, n) {
                    const i = t || this._root,
                        r = i.uuid;
                    let a = "string" == typeof e ? AnimationClip.findByName(i, e) : e;
                    const o = null !== a ? a.uuid : e,
                        s = this._actionsByClip[o];
                    let l = null;
                    if (void 0 === n && (n = null !== a ? a.blendMode : zr), void 0 !== s) {
                        const e = s.actionByRoot[r];
                        if (void 0 !== e && e.blendMode === n) return e;
                        l = s.knownActions[0], null === a && (a = l._clip)
                    }
                    if (null === a) return null;
                    const c = new AnimationAction(this, a, t, n);
                    return this._bindAction(c, l), this._addInactiveAction(c, o, r), c
                },
                existingAction: function(e, t) {
                    const n = t || this._root,
                        i = n.uuid,
                        r = "string" == typeof e ? AnimationClip.findByName(n, e) : e,
                        a = r ? r.uuid : e,
                        o = this._actionsByClip[a];
                    return void 0 !== o && o.actionByRoot[i] || null
                },
                stopAllAction: function() {
                    const e = this._actions;
                    for (let t = this._nActiveActions - 1; t >= 0; --t) e[t].stop();
                    return this
                },
                update: function(e) {
                    e *= this.timeScale;
                    const t = this._actions,
                        n = this._nActiveActions,
                        i = this.time += e,
                        r = Math.sign(e),
                        a = this._accuIndex ^= 1;
                    for (let o = 0; o !== n; ++o) {
                        t[o]._update(i, e, r, a)
                    }
                    const o = this._bindings,
                        s = this._nActiveBindings;
                    for (let e = 0; e !== s; ++e) o[e].apply(a);
                    return this
                },
                setTime: function(e) {
                    this.time = 0;
                    for (let e = 0; e < this._actions.length; e++) this._actions[e].time = 0;
                    return this.update(e)
                },
                getRoot: function() {
                    return this._root
                },
                uncacheClip: function(e) {
                    const t = this._actions,
                        n = e.uuid,
                        i = this._actionsByClip,
                        r = i[n];
                    if (void 0 !== r) {
                        const e = r.knownActions;
                        for (let n = 0, i = e.length; n !== i; ++n) {
                            const i = e[n];
                            this._deactivateAction(i);
                            const r = i._cacheIndex,
                                a = t[t.length - 1];
                            i._cacheIndex = null, i._byClipCacheIndex = null, a._cacheIndex = r, t[r] = a, t.pop(), this._removeInactiveBindingsForAction(i)
                        }
                        delete i[n]
                    }
                },
                uncacheRoot: function(e) {
                    const t = e.uuid,
                        n = this._actionsByClip;
                    for (const e in n) {
                        const i = n[e].actionByRoot[t];
                        void 0 !== i && (this._deactivateAction(i), this._removeInactiveAction(i))
                    }
                    const i = this._bindingsByRootAndName[t];
                    if (void 0 !== i)
                        for (const e in i) {
                            const t = i[e];
                            t.restoreOriginalState(), this._removeInactiveBinding(t)
                        }
                },
                uncacheAction: function(e, t) {
                    const n = this.existingAction(e, t);
                    null !== n && (this._deactivateAction(n), this._removeInactiveAction(n))
                }
            });
            class Uniform {
                constructor(e) {
                    "string" == typeof e && (e = arguments[1]), this.value = e
                }
                clone() {
                    return new Uniform(void 0 === this.value.clone ? this.value : this.value.clone())
                }
            }
            InstancedInterleavedBuffer.prototype = Object.assign(Object.create(InterleavedBuffer.prototype), {
                constructor: InstancedInterleavedBuffer,
                isInstancedInterleavedBuffer: !0,
                copy: function(e) {
                    return InterleavedBuffer.prototype.copy.call(this, e), this.meshPerAttribute = e.meshPerAttribute, this
                },
                clone: function(e) {
                    const t = InterleavedBuffer.prototype.clone.call(this, e);
                    return t.meshPerAttribute = this.meshPerAttribute, t
                },
                toJSON: function(e) {
                    const t = InterleavedBuffer.prototype.toJSON.call(this, e);
                    return t.isInstancedInterleavedBuffer = !0, t.meshPerAttribute = this.meshPerAttribute, t
                }
            }), Object.defineProperty(GLBufferAttribute.prototype, "needsUpdate", {
                set: function(e) {
                    !0 === e && this.version++
                }
            }), Object.assign(GLBufferAttribute.prototype, {
                isGLBufferAttribute: !0,
                setBuffer: function(e) {
                    return this.buffer = e, this
                },
                setType: function(e, t) {
                    return this.type = e, this.elementSize = t, this
                },
                setItemSize: function(e) {
                    return this.itemSize = e, this
                },
                setCount: function(e) {
                    return this.count = e, this
                }
            }), Object.assign(Raycaster.prototype, {
                set: function(e, t) {
                    this.ray.set(e, t)
                },
                setFromCamera: function(e, t) {
                    t && t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld), this.ray.direction.set(e.x, e.y, .5).unproject(t).sub(this.ray.origin).normalize(), this.camera = t) : t && t.isOrthographicCamera && (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t), this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld), this.camera = t)
                },
                intersectObject: function(e, t, n) {
                    const i = n || [];
                    return intersectObject(e, this, i, t), i.sort(ascSort), i
                },
                intersectObjects: function(e, t, n) {
                    const i = n || [];
                    if (!1 === Array.isArray(e)) return i;
                    for (let n = 0, r = e.length; n < r; n++) intersectObject(e[n], this, i, t);
                    return i.sort(ascSort), i
                }
            });
            class Spherical {
                constructor(e = 1, t = 0, n = 0) {
                    return this.radius = e, this.phi = t, this.theta = n, this
                }
                set(e, t, n) {
                    return this.radius = e, this.phi = t, this.theta = n, this
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                copy(e) {
                    return this.radius = e.radius, this.phi = e.phi, this.theta = e.theta, this
                }
                makeSafe() {
                    const e = 1e-6;
                    return this.phi = Math.max(e, Math.min(Math.PI - e, this.phi)), this
                }
                setFromVector3(e) {
                    return this.setFromCartesianCoords(e.x, e.y, e.z)
                }
                setFromCartesianCoords(e, t, n) {
                    return this.radius = Math.sqrt(e * e + t * t + n * n), 0 === this.radius ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(e, n), this.phi = Math.acos(Fa.clamp(t / this.radius, -1, 1))), this
                }
            }
            class Cylindrical {
                constructor(e, t, n) {
                    return this.radius = void 0 !== e ? e : 1, this.theta = void 0 !== t ? t : 0, this.y = void 0 !== n ? n : 0, this
                }
                set(e, t, n) {
                    return this.radius = e, this.theta = t, this.y = n, this
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                copy(e) {
                    return this.radius = e.radius, this.theta = e.theta, this.y = e.y, this
                }
                setFromVector3(e) {
                    return this.setFromCartesianCoords(e.x, e.y, e.z)
                }
                setFromCartesianCoords(e, t, n) {
                    return this.radius = Math.sqrt(e * e + n * n), this.theta = Math.atan2(e, n), this.y = t, this
                }
            }
            const sc = new Vector2;
            class Box2 {
                constructor(e, t) {
                    Object.defineProperty(this, "isBox2", {
                        value: !0
                    }), this.min = void 0 !== e ? e : new Vector2(1 / 0, 1 / 0), this.max = void 0 !== t ? t : new Vector2(-1 / 0, -1 / 0)
                }
                set(e, t) {
                    return this.min.copy(e), this.max.copy(t), this
                }
                setFromPoints(e) {
                    this.makeEmpty();
                    for (let t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]);
                    return this
                }
                setFromCenterAndSize(e, t) {
                    const n = sc.copy(t).multiplyScalar(.5);
                    return this.min.copy(e).sub(n), this.max.copy(e).add(n), this
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                copy(e) {
                    return this.min.copy(e.min), this.max.copy(e.max), this
                }
                makeEmpty() {
                    return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this
                }
                isEmpty() {
                    return this.max.x < this.min.x || this.max.y < this.min.y
                }
                getCenter(e) {
                    return void 0 === e && (e = new Vector2), this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
                }
                getSize(e) {
                    return void 0 === e && (e = new Vector2), this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min)
                }
                expandByPoint(e) {
                    return this.min.min(e), this.max.max(e), this
                }
                expandByVector(e) {
                    return this.min.sub(e), this.max.add(e), this
                }
                expandByScalar(e) {
                    return this.min.addScalar(-e), this.max.addScalar(e), this
                }
                containsPoint(e) {
                    return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y)
                }
                containsBox(e) {
                    return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y
                }
                getParameter(e, t) {
                    return void 0 === t && (t = new Vector2), t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y))
                }
                intersectsBox(e) {
                    return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y)
                }
                clampPoint(e, t) {
                    return void 0 === t && (t = new Vector2), t.copy(e).clamp(this.min, this.max)
                }
                distanceToPoint(e) {
                    return sc.copy(e).clamp(this.min, this.max).sub(e).length()
                }
                intersect(e) {
                    return this.min.max(e.min), this.max.min(e.max), this
                }
                union(e) {
                    return this.min.min(e.min), this.max.max(e.max), this
                }
                translate(e) {
                    return this.min.add(e), this.max.add(e), this
                }
                equals(e) {
                    return e.min.equals(this.min) && e.max.equals(this.max)
                }
            }
            const lc = new Vector3,
                cc = new Vector3;
            class Line3 {
                constructor(e, t) {
                    this.start = void 0 !== e ? e : new Vector3, this.end = void 0 !== t ? t : new Vector3
                }
                set(e, t) {
                    return this.start.copy(e), this.end.copy(t), this
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                copy(e) {
                    return this.start.copy(e.start), this.end.copy(e.end), this
                }
                getCenter(e) {
                    return void 0 === e && (e = new Vector3), e.addVectors(this.start, this.end).multiplyScalar(.5)
                }
                delta(e) {
                    return void 0 === e && (e = new Vector3), e.subVectors(this.end, this.start)
                }
                distanceSq() {
                    return this.start.distanceToSquared(this.end)
                }
                distance() {
                    return this.start.distanceTo(this.end)
                }
                at(e, t) {
                    return void 0 === t && (t = new Vector3), this.delta(t).multiplyScalar(e).add(this.start)
                }
                closestPointToPointParameter(e, t) {
                    lc.subVectors(e, this.start), cc.subVectors(this.end, this.start);
                    const n = cc.dot(cc);
                    let i = cc.dot(lc) / n;
                    return t && (i = Fa.clamp(i, 0, 1)), i
                }
                closestPointToPoint(e, t, n) {
                    const i = this.closestPointToPointParameter(e, t);
                    return void 0 === n && (n = new Vector3), this.delta(n).multiplyScalar(i).add(this.start)
                }
                applyMatrix4(e) {
                    return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this
                }
                equals(e) {
                    return e.start.equals(this.start) && e.end.equals(this.end)
                }
            }
            ImmediateRenderObject.prototype = Object.create(Object3D.prototype), ImmediateRenderObject.prototype.constructor = ImmediateRenderObject, ImmediateRenderObject.prototype.isImmediateRenderObject = !0;
            const uc = new Vector3;
            class SpotLightHelper extends Object3D {
                constructor(e, t) {
                    super(), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = t;
                    const n = new BufferGeometry,
                        i = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];
                    for (let e = 0, t = 1, n = 32; e < n; e++, t++) {
                        const r = e / n * Math.PI * 2,
                            a = t / n * Math.PI * 2;
                        i.push(Math.cos(r), Math.sin(r), 1, Math.cos(a), Math.sin(a), 1)
                    }
                    n.setAttribute("position", new Float32BufferAttribute(i, 3));
                    const r = new LineBasicMaterial({
                        fog: !1,
                        toneMapped: !1
                    });
                    this.cone = new LineSegments(n, r), this.add(this.cone), this.update()
                }
                dispose() {
                    this.cone.geometry.dispose(), this.cone.material.dispose()
                }
                update() {
                    this.light.updateMatrixWorld();
                    const e = this.light.distance ? this.light.distance : 1e3,
                        t = e * Math.tan(this.light.angle);
                    this.cone.scale.set(t, t, e), uc.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(uc), void 0 !== this.color ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color)
                }
            }
            const hc = new Vector3,
                dc = new Matrix4,
                pc = new Matrix4;
            class SkeletonHelper extends LineSegments {
                constructor(e) {
                    const t = getBoneList(e),
                        n = new BufferGeometry,
                        i = [],
                        r = [],
                        a = new Color(0, 0, 1),
                        o = new Color(0, 1, 0);
                    for (let e = 0; e < t.length; e++) {
                        const n = t[e];
                        n.parent && n.parent.isBone && (i.push(0, 0, 0), i.push(0, 0, 0), r.push(a.r, a.g, a.b), r.push(o.r, o.g, o.b))
                    }
                    n.setAttribute("position", new Float32BufferAttribute(i, 3)), n.setAttribute("color", new Float32BufferAttribute(r, 3));
                    super(n, new LineBasicMaterial({
                        vertexColors: !0,
                        depthTest: !1,
                        depthWrite: !1,
                        toneMapped: !1,
                        transparent: !0
                    })), this.type = "SkeletonHelper", this.isSkeletonHelper = !0, this.root = e, this.bones = t, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1
                }
                updateMatrixWorld(e) {
                    const t = this.bones,
                        n = this.geometry,
                        i = n.getAttribute("position");
                    pc.copy(this.root.matrixWorld).invert();
                    for (let e = 0, n = 0; e < t.length; e++) {
                        const r = t[e];
                        r.parent && r.parent.isBone && (dc.multiplyMatrices(pc, r.matrixWorld), hc.setFromMatrixPosition(dc), i.setXYZ(n, hc.x, hc.y, hc.z), dc.multiplyMatrices(pc, r.parent.matrixWorld), hc.setFromMatrixPosition(dc), i.setXYZ(n + 1, hc.x, hc.y, hc.z), n += 2)
                    }
                    n.getAttribute("position").needsUpdate = !0, super.updateMatrixWorld(e)
                }
            }
            class PointLightHelper extends Mesh {
                constructor(e, t, n) {
                    super(new SphereBufferGeometry(t, 4, 2), new MeshBasicMaterial({
                        wireframe: !0,
                        fog: !1,
                        toneMapped: !1
                    })), this.light = e, this.light.updateMatrixWorld(), this.color = n, this.type = "PointLightHelper", this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update()
                }
                dispose() {
                    this.geometry.dispose(), this.material.dispose()
                }
                update() {
                    void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this.light.color)
                }
            }
            const fc = new Vector3,
                mc = new Color,
                gc = new Color;
            class HemisphereLightHelper extends Object3D {
                constructor(e, t, n) {
                    super(), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = n;
                    const i = new OctahedronBufferGeometry(t);
                    i.rotateY(.5 * Math.PI), this.material = new MeshBasicMaterial({
                        wireframe: !0,
                        fog: !1,
                        toneMapped: !1
                    }), void 0 === this.color && (this.material.vertexColors = !0);
                    const r = i.getAttribute("position"),
                        a = new Float32Array(3 * r.count);
                    i.setAttribute("color", new BufferAttribute(a, 3)), this.add(new Mesh(i, this.material)), this.update()
                }
                dispose() {
                    this.children[0].geometry.dispose(), this.children[0].material.dispose()
                }
                update() {
                    const e = this.children[0];
                    if (void 0 !== this.color) this.material.color.set(this.color);
                    else {
                        const t = e.geometry.getAttribute("color");
                        mc.copy(this.light.color), gc.copy(this.light.groundColor);
                        for (let e = 0, n = t.count; e < n; e++) {
                            const i = e < n / 2 ? mc : gc;
                            t.setXYZ(e, i.r, i.g, i.b)
                        }
                        t.needsUpdate = !0
                    }
                    e.lookAt(fc.setFromMatrixPosition(this.light.matrixWorld).negate())
                }
            }
            class GridHelper extends LineSegments {
                constructor(e = 10, t = 10, n = 4473924, i = 8947848) {
                    n = new Color(n), i = new Color(i);
                    const r = t / 2,
                        a = e / t,
                        o = e / 2,
                        s = [],
                        l = [];
                    for (let e = 0, c = 0, u = -o; e <= t; e++, u += a) {
                        s.push(-o, 0, u, o, 0, u), s.push(u, 0, -o, u, 0, o);
                        const t = e === r ? n : i;
                        t.toArray(l, c), c += 3, t.toArray(l, c), c += 3, t.toArray(l, c), c += 3, t.toArray(l, c), c += 3
                    }
                    const c = new BufferGeometry;
                    c.setAttribute("position", new Float32BufferAttribute(s, 3)), c.setAttribute("color", new Float32BufferAttribute(l, 3));
                    super(c, new LineBasicMaterial({
                        vertexColors: !0,
                        toneMapped: !1
                    })), this.type = "GridHelper"
                }
            }
            class PolarGridHelper extends LineSegments {
                constructor(e = 10, t = 16, n = 8, i = 64, r = 4473924, a = 8947848) {
                    r = new Color(r), a = new Color(a);
                    const o = [],
                        s = [];
                    for (let n = 0; n <= t; n++) {
                        const i = n / t * (2 * Math.PI),
                            l = Math.sin(i) * e,
                            c = Math.cos(i) * e;
                        o.push(0, 0, 0), o.push(l, 0, c);
                        const u = 1 & n ? r : a;
                        s.push(u.r, u.g, u.b), s.push(u.r, u.g, u.b)
                    }
                    for (let t = 0; t <= n; t++) {
                        const l = 1 & t ? r : a,
                            c = e - e / n * t;
                        for (let e = 0; e < i; e++) {
                            let t = e / i * (2 * Math.PI),
                                n = Math.sin(t) * c,
                                r = Math.cos(t) * c;
                            o.push(n, 0, r), s.push(l.r, l.g, l.b), t = (e + 1) / i * (2 * Math.PI), n = Math.sin(t) * c, r = Math.cos(t) * c, o.push(n, 0, r), s.push(l.r, l.g, l.b)
                        }
                    }
                    const l = new BufferGeometry;
                    l.setAttribute("position", new Float32BufferAttribute(o, 3)), l.setAttribute("color", new Float32BufferAttribute(s, 3));
                    super(l, new LineBasicMaterial({
                        vertexColors: !0,
                        toneMapped: !1
                    })), this.type = "PolarGridHelper"
                }
            }
            const vc = new Vector3,
                yc = new Vector3,
                xc = new Vector3;
            class DirectionalLightHelper extends Object3D {
                constructor(e, t, n) {
                    super(), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = n, void 0 === t && (t = 1);
                    let i = new BufferGeometry;
                    i.setAttribute("position", new Float32BufferAttribute([-t, t, 0, t, t, 0, t, -t, 0, -t, -t, 0, -t, t, 0], 3));
                    const r = new LineBasicMaterial({
                        fog: !1,
                        toneMapped: !1
                    });
                    this.lightPlane = new Line(i, r), this.add(this.lightPlane), i = new BufferGeometry, i.setAttribute("position", new Float32BufferAttribute([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new Line(i, r), this.add(this.targetLine), this.update()
                }
                dispose() {
                    this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose()
                }
                update() {
                    vc.setFromMatrixPosition(this.light.matrixWorld), yc.setFromMatrixPosition(this.light.target.matrixWorld), xc.subVectors(yc, vc), this.lightPlane.lookAt(yc), void 0 !== this.color ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(yc), this.targetLine.scale.z = xc.length()
                }
            }
            const _c = new Vector3,
                bc = new Camera;
            class CameraHelper extends LineSegments {
                constructor(e) {
                    function addLine(e, t, n) {
                        addPoint(e, n), addPoint(t, n)
                    }

                    function addPoint(e, t) {
                        i.push(0, 0, 0), r.push(t.r, t.g, t.b), void 0 === a[e] && (a[e] = []), a[e].push(i.length / 3 - 1)
                    }
                    const t = new BufferGeometry,
                        n = new LineBasicMaterial({
                            color: 16777215,
                            vertexColors: !0,
                            toneMapped: !1
                        }),
                        i = [],
                        r = [],
                        a = {},
                        o = new Color(16755200),
                        s = new Color(16711680),
                        l = new Color(43775),
                        c = new Color(16777215),
                        u = new Color(3355443);
                    addLine("n1", "n2", o), addLine("n2", "n4", o), addLine("n4", "n3", o), addLine("n3", "n1", o), addLine("f1", "f2", o), addLine("f2", "f4", o), addLine("f4", "f3", o), addLine("f3", "f1", o), addLine("n1", "f1", o), addLine("n2", "f2", o), addLine("n3", "f3", o), addLine("n4", "f4", o), addLine("p", "n1", s), addLine("p", "n2", s), addLine("p", "n3", s), addLine("p", "n4", s), addLine("u1", "u2", l), addLine("u2", "u3", l), addLine("u3", "u1", l), addLine("c", "t", c), addLine("p", "c", u), addLine("cn1", "cn2", u), addLine("cn3", "cn4", u), addLine("cf1", "cf2", u), addLine("cf3", "cf4", u), t.setAttribute("position", new Float32BufferAttribute(i, 3)), t.setAttribute("color", new Float32BufferAttribute(r, 3)), super(t, n), this.type = "CameraHelper", this.camera = e, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = a, this.update()
                }
                update() {
                    const e = this.geometry,
                        t = this.pointMap;
                    bc.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), setPoint("c", t, e, bc, 0, 0, -1), setPoint("t", t, e, bc, 0, 0, 1), setPoint("n1", t, e, bc, -1, -1, -1), setPoint("n2", t, e, bc, 1, -1, -1), setPoint("n3", t, e, bc, -1, 1, -1), setPoint("n4", t, e, bc, 1, 1, -1), setPoint("f1", t, e, bc, -1, -1, 1), setPoint("f2", t, e, bc, 1, -1, 1), setPoint("f3", t, e, bc, -1, 1, 1), setPoint("f4", t, e, bc, 1, 1, 1), setPoint("u1", t, e, bc, .7, 1.1, -1), setPoint("u2", t, e, bc, -.7, 1.1, -1), setPoint("u3", t, e, bc, 0, 2, -1), setPoint("cf1", t, e, bc, -1, 0, 1), setPoint("cf2", t, e, bc, 1, 0, 1), setPoint("cf3", t, e, bc, 0, -1, 1), setPoint("cf4", t, e, bc, 0, 1, 1), setPoint("cn1", t, e, bc, -1, 0, -1), setPoint("cn2", t, e, bc, 1, 0, -1), setPoint("cn3", t, e, bc, 0, -1, -1), setPoint("cn4", t, e, bc, 0, 1, -1), e.getAttribute("position").needsUpdate = !0
                }
            }
            const Mc = new Box3;
            class BoxHelper extends LineSegments {
                constructor(e, t = 16776960) {
                    const n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
                        i = new Float32Array(24),
                        r = new BufferGeometry;
                    r.setIndex(new BufferAttribute(n, 1)), r.setAttribute("position", new BufferAttribute(i, 3)), super(r, new LineBasicMaterial({
                        color: t,
                        toneMapped: !1
                    })), this.object = e, this.type = "BoxHelper", this.matrixAutoUpdate = !1, this.update()
                }
                update(e) {
                    if (void 0 !== this.object && Mc.setFromObject(this.object), Mc.isEmpty()) return;
                    const t = Mc.min,
                        n = Mc.max,
                        i = this.geometry.attributes.position,
                        r = i.array;
                    r[0] = n.x, r[1] = n.y, r[2] = n.z, r[3] = t.x, r[4] = n.y, r[5] = n.z, r[6] = t.x, r[7] = t.y, r[8] = n.z, r[9] = n.x, r[10] = t.y, r[11] = n.z, r[12] = n.x, r[13] = n.y, r[14] = t.z, r[15] = t.x, r[16] = n.y, r[17] = t.z, r[18] = t.x, r[19] = t.y, r[20] = t.z, r[21] = n.x, r[22] = t.y, r[23] = t.z, i.needsUpdate = !0, this.geometry.computeBoundingSphere()
                }
                setFromObject(e) {
                    return this.object = e, this.update(), this
                }
                copy(e) {
                    return LineSegments.prototype.copy.call(this, e), this.object = e.object, this
                }
            }
            class Box3Helper extends LineSegments {
                constructor(e, t = 16776960) {
                    const n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
                        i = new BufferGeometry;
                    i.setIndex(new BufferAttribute(n, 1)), i.setAttribute("position", new Float32BufferAttribute([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], 3)), super(i, new LineBasicMaterial({
                        color: t,
                        toneMapped: !1
                    })), this.box = e, this.type = "Box3Helper", this.geometry.computeBoundingSphere()
                }
                updateMatrixWorld(e) {
                    const t = this.box;
                    t.isEmpty() || (t.getCenter(this.position), t.getSize(this.scale), this.scale.multiplyScalar(.5), super.updateMatrixWorld(e))
                }
            }
            class PlaneHelper extends Line {
                constructor(e, t = 1, n = 16776960) {
                    const i = n,
                        r = new BufferGeometry;
                    r.setAttribute("position", new Float32BufferAttribute([1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0], 3)), r.computeBoundingSphere(), super(r, new LineBasicMaterial({
                        color: i,
                        toneMapped: !1
                    })), this.type = "PlaneHelper", this.plane = e, this.size = t;
                    const a = new BufferGeometry;
                    a.setAttribute("position", new Float32BufferAttribute([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1], 3)), a.computeBoundingSphere(), this.add(new Mesh(a, new MeshBasicMaterial({
                        color: i,
                        opacity: .2,
                        transparent: !0,
                        depthWrite: !1,
                        toneMapped: !1
                    })))
                }
                updateMatrixWorld(e) {
                    let t = -this.plane.constant;
                    Math.abs(t) < 1e-8 && (t = 1e-8), this.scale.set(.5 * this.size, .5 * this.size, t), this.children[0].material.side = t < 0 ? un : cn, this.lookAt(this.plane.normal), super.updateMatrixWorld(e)
                }
            }
            const Sc = new Vector3;
            let Ac, wc;
            class ArrowHelper extends Object3D {
                constructor(e, t, n, i, r, a) {
                    super(), this.type = "ArrowHelper", void 0 === e && (e = new Vector3(0, 0, 1)), void 0 === t && (t = new Vector3(0, 0, 0)), void 0 === n && (n = 1), void 0 === i && (i = 16776960), void 0 === r && (r = .2 * n), void 0 === a && (a = .2 * r), void 0 === Ac && (Ac = new BufferGeometry, Ac.setAttribute("position", new Float32BufferAttribute([0, 0, 0, 0, 1, 0], 3)), wc = new CylinderBufferGeometry(0, .5, 1, 5, 1), wc.translate(0, -.5, 0)), this.position.copy(t), this.line = new Line(Ac, new LineBasicMaterial({
                        color: i,
                        toneMapped: !1
                    })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new Mesh(wc, new MeshBasicMaterial({
                        color: i,
                        toneMapped: !1
                    })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(e), this.setLength(n, r, a)
                }
                setDirection(e) {
                    if (e.y > .99999) this.quaternion.set(0, 0, 0, 1);
                    else if (e.y < -.99999) this.quaternion.set(1, 0, 0, 0);
                    else {
                        Sc.set(e.z, 0, -e.x).normalize();
                        const t = Math.acos(e.y);
                        this.quaternion.setFromAxisAngle(Sc, t)
                    }
                }
                setLength(e, t, n) {
                    void 0 === t && (t = .2 * e), void 0 === n && (n = .2 * t), this.line.scale.set(1, Math.max(1e-4, e - t), 1), this.line.updateMatrix(), this.cone.scale.set(n, t, n), this.cone.position.y = e, this.cone.updateMatrix()
                }
                setColor(e) {
                    this.line.material.color.set(e), this.cone.material.color.set(e)
                }
                copy(e) {
                    return super.copy(e, !1), this.line.copy(e.line), this.cone.copy(e.cone), this
                }
            }
            class AxesHelper extends LineSegments {
                constructor(e = 1) {
                    const t = [0, 0, 0, e, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e],
                        n = new BufferGeometry;
                    n.setAttribute("position", new Float32BufferAttribute(t, 3)), n.setAttribute("color", new Float32BufferAttribute([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1], 3));
                    super(n, new LineBasicMaterial({
                        vertexColors: !0,
                        toneMapped: !1
                    })), this.type = "AxesHelper"
                }
            }
            const Tc = new Float32Array(1),
                Lc = new Int32Array(Tc.buffer),
                Cc = {
                    toHalfFloat: function(e) {
                        Tc[0] = e;
                        const t = Lc[0];
                        let n = t >> 16 & 32768,
                            i = t >> 12 & 2047;
                        const r = t >> 23 & 255;
                        return r < 103 ? n : r > 142 ? (n |= 31744, n |= (255 == r ? 0 : 1) && 8388607 & t, n) : r < 113 ? (i |= 2048, n |= (i >> 114 - r) + (i >> 113 - r & 1), n) : (n |= r - 112 << 10 | i >> 1, n += 1 & i, n)
                    }
                },
                Pc = 256,
                Ec = [.125, .215, .35, .446, .526, .582],
                Ic = 5 + Ec.length,
                Fc = {
                    [Hr]: 0,
                    [Xr]: 1,
                    [qr]: 2,
                    [Jr]: 3,
                    [Zr]: 4,
                    [Kr]: 5,
                    [Yr]: 6
                },
                Oc = new OrthographicCamera,
                {
                    _lodPlanes: Bc,
                    _sizeLods: Rc,
                    _sigmas: Nc
                } = _createPlanes(),
                Dc = new Color;
            let Vc = null;
            const Uc = 1.618033988749895,
                zc = 1 / Uc,
                Gc = [new Vector3(1, 1, 1), new Vector3(-1, 1, 1), new Vector3(1, 1, -1), new Vector3(-1, 1, -1), new Vector3(0, Uc, zc), new Vector3(0, Uc, -zc), new Vector3(zc, 0, Uc), new Vector3(-zc, 0, Uc), new Vector3(Uc, zc, 0), new Vector3(-Uc, zc, 0)];
            class PMREMGenerator {
                constructor(e) {
                    this._renderer = e, this._pingPongRenderTarget = null, this._blurMaterial = function _getBlurShader(e) {
                        return new RawShaderMaterial({
                            name: "SphericalGaussianBlur",
                            defines: {
                                n: e
                            },
                            uniforms: {
                                envMap: {
                                    value: null
                                },
                                samples: {
                                    value: 1
                                },
                                weights: {
                                    value: new Float32Array(e)
                                },
                                latitudinal: {
                                    value: !1
                                },
                                dTheta: {
                                    value: 0
                                },
                                mipInt: {
                                    value: 0
                                },
                                poleAxis: {
                                    value: new Vector3(0, 1, 0)
                                },
                                inputEncoding: {
                                    value: Fc[Hr]
                                },
                                outputEncoding: {
                                    value: Fc[Hr]
                                }
                            },
                            vertexShader: "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
                            fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t",
                            blending: fn,
                            depthTest: !1,
                            depthWrite: !1
                        })
                    }(20), this._equirectShader = null, this._cubemapShader = null, this._compileMaterial(this._blurMaterial)
                }
                fromScene(e, t = 0, n = .1, i = 100) {
                    Vc = this._renderer.getRenderTarget();
                    const r = this._allocateTargets();
                    return this._sceneToCubeUV(e, n, i, r), t > 0 && this._blur(r, 0, 0, t), this._applyPMREM(r), this._cleanup(r), r
                }
                fromEquirectangular(e) {
                    return this._fromTexture(e)
                }
                fromCubemap(e) {
                    return this._fromTexture(e)
                }
                compileCubemapShader() {
                    null === this._cubemapShader && (this._cubemapShader = _getCubemapShader(), this._compileMaterial(this._cubemapShader))
                }
                compileEquirectangularShader() {
                    null === this._equirectShader && (this._equirectShader = _getEquirectShader(), this._compileMaterial(this._equirectShader))
                }
                dispose() {
                    this._blurMaterial.dispose(), null !== this._cubemapShader && this._cubemapShader.dispose(), null !== this._equirectShader && this._equirectShader.dispose();
                    for (let e = 0; e < Bc.length; e++) Bc[e].dispose()
                }
                _cleanup(e) {
                    this._pingPongRenderTarget.dispose(), this._renderer.setRenderTarget(Vc), e.scissorTest = !1, _setViewport(e, 0, 0, e.width, e.height)
                }
                _fromTexture(e) {
                    Vc = this._renderer.getRenderTarget();
                    const t = this._allocateTargets(e);
                    return this._textureToCubeUV(e, t), this._applyPMREM(t), this._cleanup(t), t
                }
                _allocateTargets(e) {
                    const t = {
                            magFilter: ci,
                            minFilter: ci,
                            generateMipmaps: !1,
                            type: xi,
                            format: Ni,
                            encoding: _isLDR(e) ? e.encoding : qr,
                            depthBuffer: !1
                        },
                        n = _createRenderTarget(t);
                    return n.depthBuffer = !e, this._pingPongRenderTarget = _createRenderTarget(t), n
                }
                _compileMaterial(e) {
                    const t = new Mesh(Bc[0], e);
                    this._renderer.compile(t, Oc)
                }
                _sceneToCubeUV(e, t, n, i) {
                    const r = new PerspectiveCamera(90, 1, t, n),
                        a = [1, -1, 1, 1, 1, 1],
                        o = [1, 1, 1, -1, -1, -1],
                        s = this._renderer,
                        l = s.outputEncoding,
                        c = s.toneMapping;
                    s.getClearColor(Dc);
                    const u = s.getClearAlpha();
                    s.toneMapping = Yn, s.outputEncoding = Hr;
                    let h = e.background;
                    if (h && h.isColor) {
                        h.convertSRGBToLinear();
                        const t = Math.max(h.r, h.g, h.b),
                            n = Math.min(Math.max(Math.ceil(Math.log2(t)), -128), 127);
                        h = h.multiplyScalar(Math.pow(2, -n));
                        const i = (n + 128) / 255;
                        s.setClearColor(h, i), e.background = null
                    }
                    for (let t = 0; t < 6; t++) {
                        const n = t % 3;
                        0 == n ? (r.up.set(0, a[t], 0), r.lookAt(o[t], 0, 0)) : 1 == n ? (r.up.set(0, 0, a[t]), r.lookAt(0, o[t], 0)) : (r.up.set(0, a[t], 0), r.lookAt(0, 0, o[t])), _setViewport(i, n * Pc, t > 2 ? Pc : 0, Pc, Pc), s.setRenderTarget(i), s.render(e, r)
                    }
                    s.toneMapping = c, s.outputEncoding = l, s.setClearColor(Dc, u)
                }
                _textureToCubeUV(e, t) {
                    const n = this._renderer;
                    e.isCubeTexture ? null == this._cubemapShader && (this._cubemapShader = _getCubemapShader()) : null == this._equirectShader && (this._equirectShader = _getEquirectShader());
                    const i = e.isCubeTexture ? this._cubemapShader : this._equirectShader,
                        r = new Mesh(Bc[0], i),
                        a = i.uniforms;
                    a.envMap.value = e, e.isCubeTexture || a.texelSize.value.set(1 / e.image.width, 1 / e.image.height), a.inputEncoding.value = Fc[e.encoding], a.outputEncoding.value = Fc[t.texture.encoding], _setViewport(t, 0, 0, 768, 512), n.setRenderTarget(t), n.render(r, Oc)
                }
                _applyPMREM(e) {
                    const t = this._renderer,
                        n = t.autoClear;
                    t.autoClear = !1;
                    for (let t = 1; t < Ic; t++) {
                        const n = Math.sqrt(Nc[t] * Nc[t] - Nc[t - 1] * Nc[t - 1]),
                            i = Gc[(t - 1) % Gc.length];
                        this._blur(e, t - 1, t, n, i)
                    }
                    t.autoClear = n
                }
                _blur(e, t, n, i, r) {
                    const a = this._pingPongRenderTarget;
                    this._halfBlur(e, a, t, n, i, "latitudinal", r), this._halfBlur(a, e, n, n, i, "longitudinal", r)
                }
                _halfBlur(e, t, n, i, r, a, o) {
                    const s = this._renderer,
                        l = this._blurMaterial,
                        c = new Mesh(Bc[i], l),
                        u = l.uniforms,
                        h = Rc[n] - 1,
                        d = isFinite(r) ? Math.PI / (2 * h) : 2 * Math.PI / 39,
                        p = r / d,
                        f = isFinite(r) ? 1 + Math.floor(3 * p) : 20,
                        m = [];
                    let g = 0;
                    for (let e = 0; e < 20; ++e) {
                        const t = e / p,
                            n = Math.exp(-t * t / 2);
                        m.push(n), 0 == e ? g += n : e < f && (g += 2 * n)
                    }
                    for (let e = 0; e < m.length; e++) m[e] = m[e] / g;
                    u.envMap.value = e.texture, u.samples.value = f, u.weights.value = m, u.latitudinal.value = "latitudinal" === a, o && (u.poleAxis.value = o), u.dTheta.value = d, u.mipInt.value = 8 - n, u.inputEncoding.value = Fc[e.texture.encoding], u.outputEncoding.value = Fc[e.texture.encoding];
                    const y = Rc[i];
                    _setViewport(t, 3 * Math.max(0, Pc - 2 * y), (0 === i ? 0 : 512) + 2 * y * (i > 4 ? i - 8 + 4 : 0), 3 * y, 2 * y), s.setRenderTarget(t), s.render(c, Oc)
                }
            }
            const kc = 0,
                jc = 1,
                Wc = 0,
                Hc = 1,
                Xc = 2;
            Curve.create = function(e, t) {
                return e.prototype = Object.create(Curve.prototype), e.prototype.constructor = e, e.prototype.getPoint = t, e
            }, Object.assign(CurvePath.prototype, {
                createPointsGeometry: function(e) {
                    const t = this.getPoints(e);
                    return this.createGeometry(t)
                },
                createSpacedPointsGeometry: function(e) {
                    const t = this.getSpacedPoints(e);
                    return this.createGeometry(t)
                },
                createGeometry: function(e) {
                    const t = new Geometry;
                    for (let n = 0, i = e.length; n < i; n++) {
                        const i = e[n];
                        t.vertices.push(new Vector3(i.x, i.y, i.z || 0))
                    }
                    return t
                }
            }), Object.assign(Path.prototype, {
                fromPoints: function(e) {
                    return this.setFromPoints(e)
                }
            }), ClosedSplineCurve3.prototype = Object.create(CatmullRomCurve3.prototype), SplineCurve3.prototype = Object.create(CatmullRomCurve3.prototype), Spline.prototype = Object.create(CatmullRomCurve3.prototype), Object.assign(Spline.prototype, {
                initFromArray: function() {},
                getControlPointsArray: function() {},
                reparametrizeByArcLength: function() {}
            }), GridHelper.prototype.setColors = function() {}, SkeletonHelper.prototype.update = function() {}, Object.assign(Loader.prototype, {
                extractUrlBase: function(e) {
                    return kl.extractUrlBase(e)
                }
            }), Loader.Handlers = {
                add: function() {},
                get: function() {}
            }, Object.assign(Box2.prototype, {
                center: function(e) {
                    return this.getCenter(e)
                },
                empty: function() {
                    return this.isEmpty()
                },
                isIntersectionBox: function(e) {
                    return this.intersectsBox(e)
                },
                size: function(e) {
                    return this.getSize(e)
                }
            }), Object.assign(Box3.prototype, {
                center: function(e) {
                    return this.getCenter(e)
                },
                empty: function() {
                    return this.isEmpty()
                },
                isIntersectionBox: function(e) {
                    return this.intersectsBox(e)
                },
                isIntersectionSphere: function(e) {
                    return this.intersectsSphere(e)
                },
                size: function(e) {
                    return this.getSize(e)
                }
            }), Object.assign(Sphere.prototype, {
                empty: function() {
                    return this.isEmpty()
                }
            }), Frustum.prototype.setFromMatrix = function(e) {
                return this.setFromProjectionMatrix(e)
            }, Line3.prototype.center = function(e) {
                return this.getCenter(e)
            }, Object.assign(Fa, {
                random16: function() {
                    return Math.random()
                },
                nearestPowerOfTwo: function(e) {
                    return Fa.floorPowerOfTwo(e)
                },
                nextPowerOfTwo: function(e) {
                    return Fa.ceilPowerOfTwo(e)
                }
            }), Object.assign(Matrix3.prototype, {
                flattenToArrayOffset: function(e, t) {
                    return this.toArray(e, t)
                },
                multiplyVector3: function(e) {
                    return e.applyMatrix3(this)
                },
                multiplyVector3Array: function() {},
                applyToBufferAttribute: function(e) {
                    return e.applyMatrix3(this)
                },
                applyToVector3Array: function() {},
                getInverse: function(e) {
                    return this.copy(e).invert()
                }
            }), Object.assign(Matrix4.prototype, {
                extractPosition: function(e) {
                    return this.copyPosition(e)
                },
                flattenToArrayOffset: function(e, t) {
                    return this.toArray(e, t)
                },
                getPosition: function() {
                    return (new Vector3).setFromMatrixColumn(this, 3)
                },
                setRotationFromQuaternion: function(e) {
                    return this.makeRotationFromQuaternion(e)
                },
                multiplyToArray: function() {},
                multiplyVector3: function(e) {
                    return e.applyMatrix4(this)
                },
                multiplyVector4: function(e) {
                    return e.applyMatrix4(this)
                },
                multiplyVector3Array: function() {},
                rotateAxis: function(e) {
                    e.transformDirection(this)
                },
                crossVector: function(e) {
                    return e.applyMatrix4(this)
                },
                translate: function() {},
                rotateX: function() {},
                rotateY: function() {},
                rotateZ: function() {},
                rotateByAxis: function() {},
                applyToBufferAttribute: function(e) {
                    return e.applyMatrix4(this)
                },
                applyToVector3Array: function() {},
                makeFrustum: function(e, t, n, i, r, a) {
                    return this.makePerspective(e, t, i, n, r, a)
                },
                getInverse: function(e) {
                    return this.copy(e).invert()
                }
            }), Plane.prototype.isIntersectionLine = function(e) {
                return this.intersectsLine(e)
            }, Object.assign(Quaternion.prototype, {
                multiplyVector3: function(e) {
                    return e.applyQuaternion(this)
                },
                inverse: function() {
                    return this.invert()
                }
            }), Object.assign(Ray.prototype, {
                isIntersectionBox: function(e) {
                    return this.intersectsBox(e)
                },
                isIntersectionPlane: function(e) {
                    return this.intersectsPlane(e)
                },
                isIntersectionSphere: function(e) {
                    return this.intersectsSphere(e)
                }
            }), Object.assign(Triangle.prototype, {
                area: function() {
                    return this.getArea()
                },
                barycoordFromPoint: function(e, t) {
                    return this.getBarycoord(e, t)
                },
                midpoint: function(e) {
                    return this.getMidpoint(e)
                },
                normal: function(e) {
                    return this.getNormal(e)
                },
                plane: function(e) {
                    return this.getPlane(e)
                }
            }), Object.assign(Triangle, {
                barycoordFromPoint: function(e, t, n, i, r) {
                    return Triangle.getBarycoord(e, t, n, i, r)
                },
                normal: function(e, t, n, i) {
                    return Triangle.getNormal(e, t, n, i)
                }
            }), Object.assign(Shape.prototype, {
                extractAllPoints: function(e) {
                    return this.extractPoints(e)
                },
                extrude: function(e) {
                    return new ExtrudeGeometry(this, e)
                },
                makeGeometry: function(e) {
                    return new ShapeGeometry(this, e)
                }
            }), Object.assign(Vector2.prototype, {
                fromAttribute: function(e, t, n) {
                    return this.fromBufferAttribute(e, t, n)
                },
                distanceToManhattan: function(e) {
                    return this.manhattanDistanceTo(e)
                },
                lengthManhattan: function() {
                    return this.manhattanLength()
                }
            }), Object.assign(Vector3.prototype, {
                setEulerFromRotationMatrix: function() {},
                setEulerFromQuaternion: function() {},
                getPositionFromMatrix: function(e) {
                    return this.setFromMatrixPosition(e)
                },
                getScaleFromMatrix: function(e) {
                    return this.setFromMatrixScale(e)
                },
                getColumnFromMatrix: function(e, t) {
                    return this.setFromMatrixColumn(t, e)
                },
                applyProjection: function(e) {
                    return this.applyMatrix4(e)
                },
                fromAttribute: function(e, t, n) {
                    return this.fromBufferAttribute(e, t, n)
                },
                distanceToManhattan: function(e) {
                    return this.manhattanDistanceTo(e)
                },
                lengthManhattan: function() {
                    return this.manhattanLength()
                }
            }), Object.assign(Vector4.prototype, {
                fromAttribute: function(e, t, n) {
                    return this.fromBufferAttribute(e, t, n)
                },
                lengthManhattan: function() {
                    return this.manhattanLength()
                }
            }), Object.assign(Geometry.prototype, {
                computeTangents: function() {},
                computeLineDistances: function() {},
                applyMatrix: function(e) {
                    return this.applyMatrix4(e)
                }
            }), Object.assign(Object3D.prototype, {
                getChildByName: function(e) {
                    return this.getObjectByName(e)
                },
                renderDepth: function() {},
                translate: function(e, t) {
                    return this.translateOnAxis(t, e)
                },
                getWorldRotation: function() {},
                applyMatrix: function(e) {
                    return this.applyMatrix4(e)
                }
            }), Object.defineProperties(Object3D.prototype, {
                eulerOrder: {
                    get: function() {
                        return this.rotation.order
                    },
                    set: function(e) {
                        this.rotation.order = e
                    }
                },
                useQuaternion: {
                    get: function() {},
                    set: function() {}
                }
            }), Object.assign(Mesh.prototype, {
                setDrawMode: function() {}
            }), Object.defineProperties(Mesh.prototype, {
                drawMode: {
                    get: function() {
                        return kr
                    },
                    set: function() {}
                }
            }), Object.defineProperties(LOD.prototype, {
                objects: {
                    get: function() {
                        return this.levels
                    }
                }
            }), Object.defineProperty(Skeleton.prototype, "useVertexTexture", {
                get: function() {},
                set: function() {}
            }), SkinnedMesh.prototype.initBones = function() {}, Object.defineProperty(Curve.prototype, "__arcLengthDivisions", {
                get: function() {
                    return this.arcLengthDivisions
                },
                set: function(e) {
                    this.arcLengthDivisions = e
                }
            }), PerspectiveCamera.prototype.setLens = function(e, t) {
                void 0 !== t && (this.filmGauge = t), this.setFocalLength(e)
            }, Object.defineProperties(Light.prototype, {
                onlyShadow: {
                    set: function() {}
                },
                shadowCameraFov: {
                    set: function(e) {
                        this.shadow.camera.fov = e
                    }
                },
                shadowCameraLeft: {
                    set: function(e) {
                        this.shadow.camera.left = e
                    }
                },
                shadowCameraRight: {
                    set: function(e) {
                        this.shadow.camera.right = e
                    }
                },
                shadowCameraTop: {
                    set: function(e) {
                        this.shadow.camera.top = e
                    }
                },
                shadowCameraBottom: {
                    set: function(e) {
                        this.shadow.camera.bottom = e
                    }
                },
                shadowCameraNear: {
                    set: function(e) {
                        this.shadow.camera.near = e
                    }
                },
                shadowCameraFar: {
                    set: function(e) {
                        this.shadow.camera.far = e
                    }
                },
                shadowCameraVisible: {
                    set: function() {}
                },
                shadowBias: {
                    set: function(e) {
                        this.shadow.bias = e
                    }
                },
                shadowDarkness: {
                    set: function() {}
                },
                shadowMapWidth: {
                    set: function(e) {
                        this.shadow.mapSize.width = e
                    }
                },
                shadowMapHeight: {
                    set: function(e) {
                        this.shadow.mapSize.height = e
                    }
                }
            }), Object.defineProperties(BufferAttribute.prototype, {
                length: {
                    get: function() {
                        return this.array.length
                    }
                },
                dynamic: {
                    get: function() {
                        return this.usage === _a
                    },
                    set: function() {
                        this.setUsage(_a)
                    }
                }
            }), Object.assign(BufferAttribute.prototype, {
                setDynamic: function(e) {
                    return this.setUsage(!0 === e ? _a : xa), this
                },
                copyIndicesArray: function() {},
                setArray: function() {}
            }), Object.assign(BufferGeometry.prototype, {
                addIndex: function(e) {
                    this.setIndex(e)
                },
                addAttribute: function(e, t) {
                    return t && t.isBufferAttribute || t && t.isInterleavedBufferAttribute ? "index" === e ? (this.setIndex(t), this) : this.setAttribute(e, t) : this.setAttribute(e, new BufferAttribute(arguments[1], arguments[2]))
                },
                addDrawCall: function(e, t, n) {
                    this.addGroup(e, t)
                },
                clearDrawCalls: function() {
                    this.clearGroups()
                },
                computeTangents: function() {},
                computeOffsets: function() {},
                removeAttribute: function(e) {
                    return this.deleteAttribute(e)
                },
                applyMatrix: function(e) {
                    return this.applyMatrix4(e)
                }
            }), Object.defineProperties(BufferGeometry.prototype, {
                drawcalls: {
                    get: function() {
                        return this.groups
                    }
                },
                offsets: {
                    get: function() {
                        return this.groups
                    }
                }
            }), Object.defineProperties(InstancedBufferGeometry.prototype, {
                maxInstancedCount: {
                    get: function() {
                        return this.instanceCount
                    },
                    set: function(e) {
                        this.instanceCount = e
                    }
                }
            }), Object.defineProperties(Raycaster.prototype, {
                linePrecision: {
                    get: function() {
                        return this.params.Line.threshold
                    },
                    set: function(e) {
                        this.params.Line.threshold = e
                    }
                }
            }), Object.defineProperties(InterleavedBuffer.prototype, {
                dynamic: {
                    get: function() {
                        return this.usage === _a
                    },
                    set: function(e) {
                        this.setUsage(e)
                    }
                }
            }), Object.assign(InterleavedBuffer.prototype, {
                setDynamic: function(e) {
                    return this.setUsage(!0 === e ? _a : xa), this
                },
                setArray: function() {}
            }), Object.assign(ExtrudeBufferGeometry.prototype, {
                getArrays: function() {},
                addShapeList: function() {},
                addShape: function() {}
            }), Object.assign(Scene.prototype, {
                dispose: function() {}
            }), Object.defineProperties(Uniform.prototype, {
                dynamic: {
                    set: function() {}
                },
                onUpdate: {
                    value: function() {
                        return this
                    }
                }
            }), Object.defineProperties(Material.prototype, {
                wrapAround: {
                    get: function() {},
                    set: function() {}
                },
                overdraw: {
                    get: function() {},
                    set: function() {}
                },
                wrapRGB: {
                    get: function() {
                        return new Color
                    }
                },
                shading: {
                    get: function() {},
                    set: function(e) {
                        this.flatShading = e === dn
                    }
                },
                stencilMask: {
                    get: function() {
                        return this.stencilFuncMask
                    },
                    set: function(e) {
                        this.stencilFuncMask = e
                    }
                }
            }), Object.defineProperties(MeshPhongMaterial.prototype, {
                metal: {
                    get: function() {
                        return !1
                    },
                    set: function() {}
                }
            }), Object.defineProperties(MeshPhysicalMaterial.prototype, {
                transparency: {
                    get: function() {
                        return this.transmission
                    },
                    set: function(e) {
                        this.transmission = e
                    }
                }
            }), Object.defineProperties(ShaderMaterial.prototype, {
                derivatives: {
                    get: function() {
                        return this.extensions.derivatives
                    },
                    set: function(e) {
                        this.extensions.derivatives = e
                    }
                }
            }), Object.assign(WebGLRenderer.prototype, {
                clearTarget: function(e, t, n, i) {
                    this.setRenderTarget(e), this.clear(t, n, i)
                },
                animate: function(e) {
                    this.setAnimationLoop(e)
                },
                getCurrentRenderTarget: function() {
                    return this.getRenderTarget()
                },
                getMaxAnisotropy: function() {
                    return this.capabilities.getMaxAnisotropy()
                },
                getPrecision: function() {
                    return this.capabilities.precision
                },
                resetGLState: function() {
                    return this.state.reset()
                },
                supportsFloatTextures: function() {
                    return this.extensions.get("OES_texture_float")
                },
                supportsHalfFloatTextures: function() {
                    return this.extensions.get("OES_texture_half_float")
                },
                supportsStandardDerivatives: function() {
                    return this.extensions.get("OES_standard_derivatives")
                },
                supportsCompressedTextureS3TC: function() {
                    return this.extensions.get("WEBGL_compressed_texture_s3tc")
                },
                supportsCompressedTexturePVRTC: function() {
                    return this.extensions.get("WEBGL_compressed_texture_pvrtc")
                },
                supportsBlendMinMax: function() {
                    return this.extensions.get("EXT_blend_minmax")
                },
                supportsVertexTextures: function() {
                    return this.capabilities.vertexTextures
                },
                supportsInstancedArrays: function() {
                    return this.extensions.get("ANGLE_instanced_arrays")
                },
                enableScissorTest: function(e) {
                    this.setScissorTest(e)
                },
                initMaterial: function() {},
                addPrePlugin: function() {},
                addPostPlugin: function() {},
                updateShadowMap: function() {},
                setFaceCulling: function() {},
                allocTextureUnit: function() {},
                setTexture: function() {},
                setTexture2D: function() {},
                setTextureCube: function() {},
                getActiveMipMapLevel: function() {
                    return this.getActiveMipmapLevel()
                }
            }), Object.defineProperties(WebGLRenderer.prototype, {
                shadowMapEnabled: {
                    get: function() {
                        return this.shadowMap.enabled
                    },
                    set: function(e) {
                        this.shadowMap.enabled = e
                    }
                },
                shadowMapType: {
                    get: function() {
                        return this.shadowMap.type
                    },
                    set: function(e) {
                        this.shadowMap.type = e
                    }
                },
                shadowMapCullFace: {
                    get: function() {},
                    set: function() {}
                },
                context: {
                    get: function() {
                        return this.getContext()
                    }
                },
                vr: {
                    get: function() {
                        return this.xr
                    }
                },
                gammaInput: {
                    get: function() {
                        return !1
                    },
                    set: function() {}
                },
                gammaOutput: {
                    get: function() {
                        return !1
                    },
                    set: function(e) {
                        this.outputEncoding = !0 === e ? Xr : Hr
                    }
                },
                toneMappingWhitePoint: {
                    get: function() {
                        return 1
                    },
                    set: function() {}
                }
            }), Object.defineProperties(WebGLShadowMap.prototype, {
                cullFace: {
                    get: function() {},
                    set: function() {}
                },
                renderReverseSided: {
                    get: function() {},
                    set: function() {}
                },
                renderSingleSided: {
                    get: function() {},
                    set: function() {}
                }
            }), Object.defineProperties(WebGLRenderTarget.prototype, {
                wrapS: {
                    get: function() {
                        return this.texture.wrapS
                    },
                    set: function(e) {
                        this.texture.wrapS = e
                    }
                },
                wrapT: {
                    get: function() {
                        return this.texture.wrapT
                    },
                    set: function(e) {
                        this.texture.wrapT = e
                    }
                },
                magFilter: {
                    get: function() {
                        return this.texture.magFilter
                    },
                    set: function(e) {
                        this.texture.magFilter = e
                    }
                },
                minFilter: {
                    get: function() {
                        return this.texture.minFilter
                    },
                    set: function(e) {
                        this.texture.minFilter = e
                    }
                },
                anisotropy: {
                    get: function() {
                        return this.texture.anisotropy
                    },
                    set: function(e) {
                        this.texture.anisotropy = e
                    }
                },
                offset: {
                    get: function() {
                        return this.texture.offset
                    },
                    set: function(e) {
                        this.texture.offset = e
                    }
                },
                repeat: {
                    get: function() {
                        return this.texture.repeat
                    },
                    set: function(e) {
                        this.texture.repeat = e
                    }
                },
                format: {
                    get: function() {
                        return this.texture.format
                    },
                    set: function(e) {
                        this.texture.format = e
                    }
                },
                type: {
                    get: function() {
                        return this.texture.type
                    },
                    set: function(e) {
                        this.texture.type = e
                    }
                },
                generateMipmaps: {
                    get: function() {
                        return this.texture.generateMipmaps
                    },
                    set: function(e) {
                        this.texture.generateMipmaps = e
                    }
                }
            }), Object.defineProperties(Audio.prototype, {
                load: {
                    value: function(e) {
                        const t = this;
                        return (new AudioLoader).load(e, (function(e) {
                            t.setBuffer(e)
                        })), this
                    }
                },
                startTime: {
                    set: function() {}
                }
            }), AudioAnalyser.prototype.getData = function() {
                return this.getFrequencyData()
            }, CubeCamera.prototype.updateCubeMap = function(e, t) {
                return this.update(e, t)
            }, CubeCamera.prototype.clear = function(e, t, n, i) {
                return this.renderTarget.clear(e, t, n, i)
            };
            const Yc = {
                merge: function(e, t, n) {
                    let i;
                    t.isMesh && (t.matrixAutoUpdate && t.updateMatrix(), i = t.matrix, t = t.geometry), e.merge(t, i, n)
                },
                center: function(e) {
                    return e.center()
                }
            };
            Ba.crossOrigin = void 0, Ba.loadTexture = function(e, t, n, i) {
                const r = new TextureLoader;
                r.setCrossOrigin(this.crossOrigin);
                const a = r.load(e, n, void 0, i);
                return t && (a.mapping = t), a
            }, Ba.loadTextureCube = function(e, t, n, i) {
                const r = new CubeTextureLoader;
                r.setCrossOrigin(this.crossOrigin);
                const a = r.load(e, n, void 0, i);
                return t && (a.mapping = t), a
            }, Ba.loadCompressedTexture = function() {}, Ba.loadCompressedTextureCube = function() {};
            const qc = {
                createMultiMaterialObject: function() {},
                detach: function() {},
                attach: function() {}
            };
            "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {
                detail: {
                    revision: Zt
                }
            })), c = 0, u = 1, h = function() {
                function CommandBuffer(e, t) {
                    var n, i, r, a;
                    classCallCheck_classCallCheck(this, CommandBuffer), this.shared = !0, "unshared" == e ? (n = 1048576, i = Int32Array.BYTES_PER_ELEMENT * n, this.length = n, this.sharedDataBuffer = new ArrayBuffer(i), this.sharedControlBuffer = new ArrayBuffer(4 * Int32Array.BYTES_PER_ELEMENT), this.shared = !1) : e && t ? (this.sharedControlBuffer = t, this.sharedDataBuffer = e, this.length = e.byteLength / Int32Array.BYTES_PER_ELEMENT) : (r = 1048576, a = Int32Array.BYTES_PER_ELEMENT * r, this.length = r, this.sharedDataBuffer = new SharedArrayBuffer(a), this.sharedControlBuffer = new SharedArrayBuffer(4 * Int32Array.BYTES_PER_ELEMENT)), this.intArray = new Int32Array(this.sharedDataBuffer), this.floatArray = new Float32Array(this.sharedDataBuffer), this.controlArray = new Int32Array(this.sharedControlBuffer), this.tempOffset = 0, this.lengthOffset = 0
                }
                return createClass_createClass(CommandBuffer, [{
                    key: "startWriteCommand",
                    value: function startWriteCommand(e) {
                        this.tempOffset = this.writeHead, this.writeInt(e), this.lengthOffset = this.tempOffset, this.writeInt(0)
                    }
                }, {
                    key: "endWriteCommand",
                    value: function endWriteCommand() {
                        var e = this.writeHead,
                            t = this.tempOffset - e;
                        t < 0 && (t = this.length - e + this.tempOffset), this.intArray[this.lengthOffset] = t, this.shared && Atomics.store(this.controlArray, c, this.tempOffset)
                    }
                }, {
                    key: "cancelWriteCommand",
                    value: function cancelWriteCommand() {}
                }, {
                    key: "writeFloat",
                    value: function writeFloat(e) {
                        this.floatArray[this.tempOffset] = e, this.tempOffset++, this.tempOffset >= this.length && (this.tempOffset = 0)
                    }
                }, {
                    key: "writeInt",
                    value: function writeInt(e) {
                        this.intArray[this.tempOffset] = e, this.tempOffset++, this.tempOffset >= this.length && (this.tempOffset = 0)
                    }
                }, {
                    key: "writeMatrix",
                    value: function writeMatrix(e) {
                        this.tempOffset + 15 >= this.length && (this.tempOffset = 0), e.toArray(this.floatArray, this.tempOffset), this.tempOffset += 16, this.tempOffset >= this.length && (this.tempOffset = 0)
                    }
                }, {
                    key: "writeString",
                    value: function writeString(e) {
                        if (null != e) {
                            this.writeInt(e.length);
                            for (var t = 0; t < e.length; t++) this.writeInt(e.charCodeAt(t))
                        } else this.writeInt(-1)
                    }
                }, {
                    key: "writeObject",
                    value: function writeObject(e) {
                        this.writeString(JSON.stringify(e))
                    }
                }, {
                    key: "readHead",
                    get: function get() {
                        return this.controlArray[u]
                    }
                }, {
                    key: "writeHead",
                    get: function get() {
                        return this.controlArray[c]
                    }
                }, {
                    key: "readFloat",
                    value: function readFloat() {
                        var e = this.floatArray[this.tempOffset];
                        return this.tempOffset++, this.tempOffset >= this.length && (this.tempOffset = 0), e
                    }
                }, {
                    key: "readInt",
                    value: function readInt() {
                        var e = this.intArray[this.tempOffset];
                        return this.tempOffset++, this.tempOffset >= this.length && (this.tempOffset = 0), e
                    }
                }, {
                    key: "readMatrix",
                    value: function readMatrix(e) {
                        return this.tempOffset + 15 >= this.length && (this.tempOffset = 0), e.fromArray(this.floatArray, this.tempOffset), this.tempOffset += 16, this.tempOffset >= this.length && (this.tempOffset = 0), e
                    }
                }, {
                    key: "readString",
                    value: function readString() {
                        var e, t, n = this.readInt();
                        if (!(n < 0)) {
                            for (e = "", t = 0; t < n; t++) e += String.fromCharCode(this.readInt());
                            return e
                        }
                    }
                }, {
                    key: "readObject",
                    value: function readObject() {
                        var e = this.readString();
                        if (e) return JSON.parse(e)
                    }
                }, {
                    key: "notify",
                    value: function notify() {
                        this.shared && (Atomics.store(this.controlArray, c, this.writeHead), Atomics.notify(this.controlArray, c, 1))
                    }
                }, {
                    key: "commandLoop",
                    value: function commandLoop(e) {
                        for (var t, n, i, r; this.readHead != this.writeHead;) {
                            this.tempOffset = this.readHead, t = this.readInt(), n = this.readInt(), i = !1;
                            try {
                                i = e(t, n, this)
                            } catch (e) {}
                            if ((r = this.readHead + n) >= this.length && (r %= this.length), this.shared && Atomics.store(this.controlArray, u, r), i) return
                        }
                    }
                }, {
                    key: "waitForCommands",
                    value: function waitForCommands(e) {
                        var t = this;
                        this.interval = setInterval((function() {
                            t.commandLoop(e) || Atomics.wait(t.controlArray, c, t.readHead, 10)
                        }), 0)
                    }
                }, {
                    key: "readAuxControlInt",
                    value: function readAuxControlInt(e) {
                        return this.controlArray[e + 2]
                    }
                }, {
                    key: "writeAuxControlInt",
                    value: function writeAuxControlInt(e, t) {
                        this.controlArray[e + 2] = t
                    }
                }]), CommandBuffer
            }();
            const Qc = d = {
                CREATE_RENDERER: 0,
                DELETE_RENDERER: 1,
                SET_RENDERER_PIXEL_RATIO: 2,
                SET_RENDERER_SIZE: 3,
                SET_RENDERER_SHADOWS: 4,
                CREATE_SCENE: 5,
                DELETE_SCENE: 6,
                CREATE_OBJECT: 7,
                DELETE_OBJECT: 8,
                ADD_OBJECT: 9,
                REMOVE_OBJECT: 10,
                CALL_OBJECT_METHOD: 11,
                SET_OBJECT_PROPERTY: 12,
                SET_OBJECT_POSITION: 13,
                SET_OBJECT_QUATERNION: 14,
                SET_OBJECT_ROTATION: 15,
                SET_OBJECT_SCALE: 16,
                SET_OBJECT_VISIBLE: 17,
                SET_OBJECT_NAME: 18,
                UPDATE_OBJECT_MATRIX: 19,
                OBJECT_LOOKAT_POSITION: 20,
                OBJECT_LOOKAT_OBJECT: 21,
                OBJECT_MATCH_WORLD_POSITION: 22,
                OBJECT_MATCH_WORLD_ROTATION: 23,
                OBJECT_ADD_POSITION: 24,
                OBJECT_ROTATE_X: 25,
                OBJECT_ROTATE_Y: 26,
                OBJECT_ROTATE_Z: 27,
                SET_OBJECT_MATERIAL: 28,
                SET_OBJECT_DEPTH_MATERIAL: 29,
                SET_OBJECT_PROPERTY_EXPAND_OBJECT: 30,
                SET_OBJECT_SHADOWS: 31,
                SET_OBJECT_CUSTOM_MATERIAL: 32,
                RELEASE_OBJECT_ID: 40,
                CREATE_OBJECT_FROM_CLONE: 41,
                CREATE_OBJECT_FROM_FIND: 42,
                CREATE_SIMPLE_OBJECT: 43,
                CREATE_ANIMATION_MIXER: 44,
                CREATE_SKELETON: 45,
                CREATE_SHADER: 46,
                CREATE_MATERIAL: 47,
                CLONE_MATERIAL: 48,
                CREATE_UNIFORMS: 49,
                CLONE_UNIFORMS: 50,
                SET_UNIFORM_TEX: 51,
                SET_UNIFORM_FLOAT: 52,
                SET_UNIFORM_FLOAT2: 53,
                SET_UNIFORM_FLOAT3: 54,
                SET_UNIFORM_FLOAT4: 55,
                SET_MATERIAL_DEFINES: 56,
                SET_TEX_WRAPPING: 57,
                UNSHARE_UNIFORM: 58,
                SET_UNIFORM_TEX_CUBE: 59,
                SET_CAMERA_FOV: 60,
                UPDATE_CAMERA_PROJECTION_MATRIX: 61,
                UPDATE_ANIMATION_MIXER: 70,
                UPDATE_SKELETON: 71,
                PLAY_ANIMATION: 72,
                CREATE_CLIP: 73,
                SET_CLIP_WEIGHT: 74,
                SET_CLIP_TIME: 75,
                UPDATE_CLIP_TIME: 76,
                SET_CLIP_PLAYRATE: 77,
                PLAY_CLIP: 78,
                STOP_ALL_ANIMATION: 79,
                GET_SKELETON_BONE: 80,
                BIND_SKELETON: 81,
                UPDATE_MIXER_CLIP_TIME: 82,
                CREATE_MESH: 99,
                RENDERER_CLEAR: 100,
                RENDERER_CLEARDEPTH: 101,
                RENDERER_SETCOLORMASK: 102,
                RENDERER_RENDER: 103,
                INSERT_FENCE: 104,
                CREATE_INSTANCED_MESH: 109,
                SET_INSTANCE_TRANSFORM: 110,
                SET_INSTANCE_COLOR: 113,
                SET_INSTANCE_COUNT: 114,
                CREATE_DIRECTIONAL_LIGHT: 130,
                CREATE_DIRECTIONAL_LIGHT_TARGET: 131,
                SET_LIGHT_SHADOW_SIZE: 132,
                SET_SCENE_FOG: 133,
                BEGIN_FRAME: 134,
                END_FRAME: 135,
                CREATE_FLOAT_INTERP: 140,
                SET_FLOAT_INTERP: 141,
                CREATE_VECTOR_INTERP: 142,
                SET_VECTOR_INTERP: 143,
                CREATE_FUNCTION: 200,
                DELETE_FUNCTION: 201,
                RUN_FUNCTION: 202,
                RUN_FUNCTION_NO_PARAM: 203,
                RUN_FUNCTION_FAST_PARAM: 204,
                RUN_FUNCTION_FAST_PARAM2: 205,
                RUN_FUNCTION_FAST_PARAM3: 206,
                RUN_FUNCTION_OPEN_PARAMS: 207,
                RUN_FUNCTION_AT_EVENT: 210,
                RUN_FUNCTION_AT_EVENT_NO_PARAM: 211,
                RUN_FUNCTION_AT_EVENT_FAST_PARAM: 212,
                CREATE_SPRITE_MATERIAL: 300,
                CREATE_SPRITE: 301,
                SET_SPRITE_OPACITY: 302,
                SET_SPRITE_ROTATION: 303,
                CREATE_TRACKER_OBJECT: 400,
                CREATE_MERGED_MESH: 501,
                MERGE_MESHES: 502,
                CREATE_SPRITE_DESC: 503,
                CREATE_SPRITE_SET: 504,
                CREATE_COMPOSER: 600,
                COMPOSER_ADD_PASS: 601,
                COMPOSER_REMOVE_PASS: 602,
                COMPOSER_CREATE_RENDER_PASS: 603,
                COMPOSER_SET_SIZE: 604,
                COMPOSER_CREATE_FXAA_PASS: 605,
                COMPOSER_CREATE_DOF_PASS: 606,
                GENERATE_ENV_MAP: 700
            };
            d.SET_OBJECT_VISIBLE, d.ADD_OBJECT, f = new(p = function(e) {
                function ThreadableTextureLoader(e) {
                    return classCallCheck_classCallCheck(this, ThreadableTextureLoader), t.call(this, e)
                }
                _inherits(ThreadableTextureLoader, e);
                var t = _createSuper(ThreadableTextureLoader);
                return createClass_createClass(ThreadableTextureLoader, [{
                    key: "load",
                    value: function load(e, t, n, i) {
                        var r, a = new Texture;
                        if ("" != e) return a.flipInCanvas = !1, "undefined" != typeof WorkerGlobalScope && self instanceof WorkerGlobalScope ? ((r = new ImageBitmapLoader(this.manager)).setCrossOrigin(this.crossOrigin), r.setPath(this.path), r.setOptions({
                            imageOrientation: "flipY",
                            premultiplyAlpha: "none",
                            colorSpaceConversion: "default"
                        })) : ((r = new ImageLoader(this.manager)).setCrossOrigin(this.crossOrigin), r.setPath(this.path), a.flipInCanvas = !0), r.load(e, (function(n) {
                            a.image = n;
                            var i = e.search(/\.jpe?g($|\?)/i) > 0 || 0 === e.search(/^data\:image\/jpeg/);
                            a.format = i ? Fi : Oi, a.needsUpdate = !0, void 0 !== t && t(a)
                        }), n, i), a;
                        void 0 !== t && t(a)
                    }
                }]), ThreadableTextureLoader
            }(TextureLoader)), m = function() {
                function GLTFLoader(e) {
                    Loader.call(this, e), this.dracoLoader = null, this.ddsLoader = null
                }

                function GLTFRegistry() {
                    var e = {};
                    return {
                        get: function get(t) {
                            return e[t]
                        },
                        add: function add(t, n) {
                            e[t] = n
                        },
                        remove: function remove(t) {
                            delete e[t]
                        },
                        removeAll: function removeAll() {
                            e = {}
                        }
                    }
                }

                function GLTFTextureDDSExtension(t) {
                    if (!t) throw Error("THREE.GLTFLoader: Attempting to load .dds texture without importing THREE.DDSLoader");
                    this.name = e.MSFT_TEXTURE_DDS, this.ddsLoader = t
                }

                function GLTFLightsExtension(t) {
                    this.name = e.KHR_LIGHTS_PUNCTUAL;
                    var n = t.extensions && t.extensions[e.KHR_LIGHTS_PUNCTUAL] || {};
                    this.lightDefs = n.lights || []
                }

                function GLTFMaterialsUnlitExtension() {
                    this.name = e.KHR_MATERIALS_UNLIT
                }

                function GLTFBinaryExtension(a) {
                    var o, s, l, c, u, h, d;
                    if (this.name = e.KHR_BINARY_GLTF, this.content = null, this.body = null, o = new DataView(a, 0, n), this.header = {
                            magic: kl.decodeText(new Uint8Array(a.slice(0, 4))),
                            version: o.getUint32(4, !0),
                            length: o.getUint32(8, !0)
                        }, this.header.magic !== t) throw Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
                    if (this.header.version < 2) throw Error("THREE.GLTFLoader: Legacy binary file detected.");
                    for (s = new DataView(a, n), l = 0; l < s.byteLength;) c = s.getUint32(l, !0), l += 4, u = s.getUint32(l, !0), l += 4, u === i ? (h = new Uint8Array(a, n + l, c), this.content = kl.decodeText(h)) : u === r && (d = n + l, this.body = a.slice(d, d + c)), l += c;
                    if (null === this.content) throw Error("THREE.GLTFLoader: JSON content not found.")
                }

                function GLTFDracoMeshCompressionExtension(t, n) {
                    if (!n) throw Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
                    this.name = e.KHR_DRACO_MESH_COMPRESSION, this.json = t, this.dracoLoader = n
                }

                function GLTFTextureTransformExtension() {
                    this.name = e.KHR_TEXTURE_TRANSFORM
                }

                function GLTFMaterialsPbrSpecularGlossinessExtension() {
                    return {
                        name: e.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS,
                        specularGlossinessParams: ["color", "map", "lightMap", "lightMapIntensity", "aoMap", "aoMapIntensity", "emissive", "emissiveIntensity", "emissiveMap", "bumpMap", "bumpScale", "normalMap", "displacementMap", "displacementScale", "displacementBias", "specularMap", "specular", "glossinessMap", "glossiness", "alphaMap", "envMap", "envMapIntensity", "refractionRatio"],
                        getMaterialType: function getMaterialType() {
                            return ShaderMaterial
                        },
                        extendParams: function extendParams(e, t, n) {
                            var i, r, a, o = t.extensions[this.name],
                                s = As.standard,
                                l = ys.clone(s.uniforms),
                                c = "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
                                u = "#ifdef USE_GLOSSINESSMAP\n\tuniform sampler2D glossinessMap;\n#endif",
                                h = "vec3 specularFactor = specular;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\ttexelSpecular = sRGBToLinear( texelSpecular );\n\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture\n\tspecularFactor *= texelSpecular.rgb;\n#endif",
                                d = "float glossinessFactor = glossiness;\n#ifdef USE_GLOSSINESSMAP\n\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );\n\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture\n\tglossinessFactor *= texelGlossiness.a;\n#endif",
                                p = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularRoughness = clamp( 1.0 - glossinessFactor, 0.04, 1.0 );\nmaterial.specularColor = specularFactor.rgb;",
                                f = s.fragmentShader.replace("uniform float roughness;", "uniform vec3 specular;").replace("uniform float metalness;", "uniform float glossiness;").replace("#include <roughnessmap_pars_fragment>", c).replace("#include <metalnessmap_pars_fragment>", u).replace("#include <roughnessmap_fragment>", h).replace("#include <metalnessmap_fragment>", d).replace("#include <lights_physical_fragment>", p);
                            return delete l.roughness, delete l.metalness, delete l.roughnessMap, delete l.metalnessMap, l.specular = {
                                value: (new Color).setHex(1118481)
                            }, l.glossiness = {
                                value: .5
                            }, l.specularMap = {
                                value: null
                            }, l.glossinessMap = {
                                value: null
                            }, e.vertexShader = s.vertexShader, e.fragmentShader = f, e.uniforms = l, e.defines = {
                                STANDARD: ""
                            }, e.color = new Color(1, 1, 1), e.opacity = 1, i = [], Array.isArray(o.diffuseFactor) && (r = o.diffuseFactor, e.color.fromArray(r), e.opacity = r[3]), void 0 !== o.diffuseTexture && i.push(n.assignTexture(e, "map", o.diffuseTexture)), e.emissive = new Color(0, 0, 0), e.glossiness = void 0 !== o.glossinessFactor ? o.glossinessFactor : 1, e.specular = new Color(1, 1, 1), Array.isArray(o.specularFactor) && e.specular.fromArray(o.specularFactor), void 0 !== o.specularGlossinessTexture && (a = o.specularGlossinessTexture, i.push(n.assignTexture(e, "glossinessMap", a)), i.push(n.assignTexture(e, "specularMap", a))), Promise.all(i)
                        },
                        createMaterial: function createMaterial(e) {
                            var t = new ShaderMaterial({
                                defines: e.defines,
                                vertexShader: e.vertexShader,
                                fragmentShader: e.fragmentShader,
                                uniforms: e.uniforms,
                                fog: !0,
                                lights: !0,
                                opacity: e.opacity,
                                transparent: e.transparent
                            });
                            return t.isGLTFSpecularGlossinessMaterial = !0, t.color = e.color, t.map = void 0 === e.map ? null : e.map, t.lightMap = null, t.lightMapIntensity = 1, t.aoMap = void 0 === e.aoMap ? null : e.aoMap, t.aoMapIntensity = 1, t.emissive = e.emissive, t.emissiveIntensity = 1, t.emissiveMap = void 0 === e.emissiveMap ? null : e.emissiveMap, t.bumpMap = void 0 === e.bumpMap ? null : e.bumpMap, t.bumpScale = 1, t.normalMap = void 0 === e.normalMap ? null : e.normalMap, e.normalScale && (t.normalScale = e.normalScale), t.displacementMap = null, t.displacementScale = 1, t.displacementBias = 0, t.specularMap = void 0 === e.specularMap ? null : e.specularMap, t.specular = e.specular, t.glossinessMap = void 0 === e.glossinessMap ? null : e.glossinessMap, t.glossiness = e.glossiness, t.alphaMap = null, t.envMap = void 0 === e.envMap ? null : e.envMap, t.envMapIntensity = 1, t.refractionRatio = .98, t.extensions.derivatives = !0, t
                        },
                        cloneMaterial: function cloneMaterial(e) {
                            var t, n, i, r, a = e.clone();
                            for (a.isGLTFSpecularGlossinessMaterial = !0, n = 0, i = (t = this.specularGlossinessParams).length; n < i; n++) r = e[t[n]], a[t[n]] = r && r.isColor ? r.clone() : r;
                            return a
                        },
                        refreshUniforms: function refreshUniforms(e, t, n, i, r) {
                            var a, o, s;
                            !0 === r.isGLTFSpecularGlossinessMaterial && (a = r.uniforms, o = r.defines, a.opacity.value = r.opacity, a.diffuse.value.copy(r.color), a.emissive.value.copy(r.emissive).multiplyScalar(r.emissiveIntensity), a.map.value = r.map, a.specularMap.value = r.specularMap, a.alphaMap.value = r.alphaMap, a.lightMap.value = r.lightMap, a.lightMapIntensity.value = r.lightMapIntensity, a.aoMap.value = r.aoMap, a.aoMapIntensity.value = r.aoMapIntensity, r.map ? s = r.map : r.specularMap ? s = r.specularMap : r.displacementMap ? s = r.displacementMap : r.normalMap ? s = r.normalMap : r.bumpMap ? s = r.bumpMap : r.glossinessMap ? s = r.glossinessMap : r.alphaMap ? s = r.alphaMap : r.emissiveMap && (s = r.emissiveMap), void 0 !== s && (s.isWebGLRenderTarget && (s = s.texture), !0 === s.matrixAutoUpdate && s.updateMatrix(), a.uvTransform.value.copy(s.matrix)), r.envMap && (a.envMap.value = r.envMap, a.envMapIntensity.value = r.envMapIntensity, a.flipEnvMap.value = r.envMap.isCubeTexture ? -1 : 1, a.reflectivity.value = r.reflectivity, a.refractionRatio.value = r.refractionRatio, a.maxMipLevel.value = e.properties.get(r.envMap).__maxMipLevel), a.specular.value.copy(r.specular), a.glossiness.value = r.glossiness, a.glossinessMap.value = r.glossinessMap, a.emissiveMap.value = r.emissiveMap, a.bumpMap.value = r.bumpMap, a.normalMap.value = r.normalMap, a.displacementMap.value = r.displacementMap, a.displacementScale.value = r.displacementScale, a.displacementBias.value = r.displacementBias, null !== a.glossinessMap.value && void 0 === o.USE_GLOSSINESSMAP && (o.USE_GLOSSINESSMAP = "", o.USE_ROUGHNESSMAP = ""), null === a.glossinessMap.value && void 0 !== o.USE_GLOSSINESSMAP && (delete o.USE_GLOSSINESSMAP, delete o.USE_ROUGHNESSMAP))
                        }
                    }
                }

                function GLTFMeshQuantizationExtension() {
                    this.name = e.KHR_MESH_QUANTIZATION
                }

                function GLTFCubicSplineInterpolant(e, t, n, i) {
                    Interpolant.call(this, e, t, n, i)
                }

                function resolveURL(e, t) {
                    return "string" != typeof e || "" === e ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e)
                }

                function addUnknownExtensionsToUserData(e, t, n) {
                    for (var i in n.extensions) void 0 === e[i] && (t.userData.gltfExtensions = t.userData.gltfExtensions || {}, t.userData.gltfExtensions[i] = n.extensions[i])
                }

                function assignExtrasToUserData(e, t) {
                    void 0 !== t.extras && "object" === _typeof(t.extras) && Object.assign(e.userData, t.extras)
                }

                function updateMorphTargets(e, t) {
                    var n, i, r;
                    if (e.updateMorphTargets(), void 0 !== t.weights)
                        for (n = 0, i = t.weights.length; n < i; n++) e.morphTargetInfluences[n] = t.weights[n];
                    if (t.extras && Array.isArray(t.extras.targetNames) && (r = t.extras.targetNames, e.morphTargetInfluences.length === r.length))
                        for (e.morphTargetDictionary = {}, n = 0, i = r.length; n < i; n++) e.morphTargetDictionary[r[n]] = n
                }

                function createAttributesKey(e) {
                    var t, n, i = "",
                        r = Object.keys(e).sort();
                    for (t = 0, n = r.length; t < n; t++) i += r[t] + ":" + e[r[t]] + ";";
                    return i
                }

                function GLTFParser(e, t, n) {
                    this.json = e || {}, this.extensions = t || {}, this.options = n || {}, this.cache = new GLTFRegistry, this.primitiveCache = {}, this.textureLoader = new p(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.fileLoader = new FileLoader(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), "use-credentials" === this.options.crossOrigin && this.fileLoader.setWithCredentials(!0)
                }

                function addPrimitiveAttributes(e, t, n) {
                    function assignAttributeAccessor(t, i) {
                        return n.getDependency("accessor", t).then((function(t) {
                            e.setAttribute, e.setAttribute(i, t)
                        }))
                    }
                    var i, r, a, o = t.attributes,
                        s = [];
                    for (i in o)(r = y[i] || i.toLowerCase()) in e.attributes || s.push(assignAttributeAccessor(o[i], r));
                    return void 0 === t.indices || e.index || (a = n.getDependency("accessor", t.indices).then((function(t) {
                            e.setIndex(t)
                        })), s.push(a)), assignExtrasToUserData(e, t),
                        function computeBounds(e, t, n) {
                            var i, r, a, o, s, l, c, u, h, d = t.attributes,
                                p = new Box3;
                            if (void 0 !== d.POSITION) {
                                if (r = (i = n.json.accessors[d.POSITION]).min, a = i.max, p.set(new Vector3(r[0], r[1], r[2]), new Vector3(a[0], a[1], a[2])), void 0 !== (o = t.targets))
                                    for (s = new Vector3, l = 0, c = o.length; l < c; l++) void 0 !== (u = o[l]).POSITION && (r = (i = n.json.accessors[u.POSITION]).min, a = i.max, s.setX(Math.max(Math.abs(r[0]), Math.abs(a[0]))), s.setY(Math.max(Math.abs(r[1]), Math.abs(a[1]))), s.setZ(Math.max(Math.abs(r[2]), Math.abs(a[2]))), p.expandByVector(s));
                                e.boundingBox = p, h = new Sphere, p.getCenter(h.center), h.radius = p.min.distanceTo(p.max) / 2, e.boundingSphere = h
                            }
                        }(e, t, n), Promise.all(s).then((function() {
                            return void 0 !== t.targets ? function addMorphTargets(e, t, n) {
                                var i, r, a, o, s, l, c = !1,
                                    u = !1;
                                for (i = 0, r = t.length; i < r && (void 0 !== (a = t[i]).POSITION && (c = !0), void 0 !== a.NORMAL && (u = !0), !c || !u); i++);
                                if (!c && !u) return Promise.resolve(e);
                                for (o = [], s = [], i = 0, r = t.length; i < r; i++) a = t[i], c && (l = void 0 !== a.POSITION ? n.getDependency("accessor", a.POSITION) : e.attributes.position, o.push(l)), u && (l = void 0 !== a.NORMAL ? n.getDependency("accessor", a.NORMAL) : e.attributes.normal, s.push(l));
                                return Promise.all([Promise.all(o), Promise.all(s)]).then((function(t) {
                                    var n = t[0],
                                        i = t[1];
                                    return c && (e.morphAttributes.position = n), u && (e.morphAttributes.normal = i), e.morphTargetsRelative = !0, e
                                }))
                            }(e, t.targets, n) : e
                        }))
                }
                var e, t, n, i, r, a, o, s, l, c, u, h, d, f, m, g, y, x, _, b, M, S, A, w;
                return GLTFLoader.prototype = Object.assign(Object.create(Loader.prototype), {
                    constructor: GLTFLoader,
                    load: function load(e, t, n, i) {
                        var r, a, o, s = this;
                        r = "" !== this.resourcePath ? this.resourcePath : "" !== this.path ? this.path : kl.extractUrlBase(e), s.manager.itemStart(e), a = function _onError(t) {
                            i && i(t), s.manager.itemError(e), s.manager.itemEnd(e)
                        }, (o = new FileLoader(s.manager)).setPath(this.path), o.setResponseType("arraybuffer"), "use-credentials" === s.crossOrigin && o.setWithCredentials(!0), o.load(e, (function(n) {
                            try {
                                s.parse(n, r, (function(n) {
                                    t(n), s.manager.itemEnd(e)
                                }), a)
                            } catch (e) {
                                a(e)
                            }
                        }), n, a)
                    },
                    setDRACOLoader: function setDRACOLoader(e) {
                        return this.dracoLoader = e, this
                    },
                    setDDSLoader: function setDDSLoader(e) {
                        return this.ddsLoader = e, this
                    },
                    parse: function parse(n, i, r, a) {
                        var o, s, l, c, u, h = {};
                        if ("string" == typeof n) o = n;
                        else if (kl.decodeText(new Uint8Array(n, 0, 4)) === t) {
                            try {
                                h[e.KHR_BINARY_GLTF] = new GLTFBinaryExtension(n)
                            } catch (e) {
                                return void(a && a(e))
                            }
                            o = h[e.KHR_BINARY_GLTF].content
                        } else o = kl.decodeText(new Uint8Array(n));
                        if (void 0 === (s = JSON.parse(o)).asset || s.asset.version[0] < 2) a && a(Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));
                        else {
                            if (s.extensionsUsed)
                                for (l = 0; l < s.extensionsUsed.length; ++l) switch (c = s.extensionsUsed[l], u = s.extensionsRequired || [], c) {
                                    case e.KHR_LIGHTS_PUNCTUAL:
                                        h[c] = new GLTFLightsExtension(s);
                                        break;
                                    case e.KHR_MATERIALS_UNLIT:
                                        h[c] = new GLTFMaterialsUnlitExtension;
                                        break;
                                    case e.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
                                        h[c] = new GLTFMaterialsPbrSpecularGlossinessExtension;
                                        break;
                                    case e.KHR_DRACO_MESH_COMPRESSION:
                                        h[c] = new GLTFDracoMeshCompressionExtension(s, this.dracoLoader);
                                        break;
                                    case e.MSFT_TEXTURE_DDS:
                                        h[c] = new GLTFTextureDDSExtension(this.ddsLoader);
                                        break;
                                    case e.KHR_TEXTURE_TRANSFORM:
                                        h[c] = new GLTFTextureTransformExtension;
                                        break;
                                    case e.KHR_MESH_QUANTIZATION:
                                        h[c] = new GLTFMeshQuantizationExtension;
                                        break;
                                    default:
                                        u.indexOf(c)
                                }
                            new GLTFParser(s, h, {
                                path: i || this.resourcePath || "",
                                crossOrigin: this.crossOrigin,
                                manager: this.manager
                            }).parse(r, a)
                        }
                    }
                }), e = {
                    KHR_BINARY_GLTF: "KHR_binary_glTF",
                    KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
                    KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
                    KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: "KHR_materials_pbrSpecularGlossiness",
                    KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
                    KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
                    KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
                    MSFT_TEXTURE_DDS: "MSFT_texture_dds"
                }, GLTFLightsExtension.prototype.loadLight = function(e) {
                    var t, n, i = this.lightDefs[e],
                        r = new Color(16777215);
                    switch (void 0 !== i.color && r.fromArray(i.color), n = void 0 !== i.range ? i.range : 0, i.type) {
                        case "directional":
                            (t = new DirectionalLight(r)).target.position.set(0, 0, -1), t.add(t.target);
                            break;
                        case "point":
                            (t = new PointLight(r)).distance = n;
                            break;
                        case "spot":
                            (t = new SpotLight(r)).distance = n, i.spot = i.spot || {}, i.spot.innerConeAngle = void 0 !== i.spot.innerConeAngle ? i.spot.innerConeAngle : 0, i.spot.outerConeAngle = void 0 !== i.spot.outerConeAngle ? i.spot.outerConeAngle : Math.PI / 4, t.angle = i.spot.outerConeAngle, t.penumbra = 1 - i.spot.innerConeAngle / i.spot.outerConeAngle, t.target.position.set(0, 0, -1), t.add(t.target);
                            break;
                        default:
                            throw Error('THREE.GLTFLoader: Unexpected light type, "' + i.type + '".')
                    }
                    return t.position.set(0, 0, 0), t.decay = 2, void 0 !== i.intensity && (t.intensity = i.intensity), t.name = i.name || "light_" + e, Promise.resolve(t)
                }, GLTFMaterialsUnlitExtension.prototype.getMaterialType = function() {
                    return MeshBasicMaterial
                }, GLTFMaterialsUnlitExtension.prototype.extendParams = function(e, t, n) {
                    var i, r, a = [];
                    return e.color = new Color(1, 1, 1), e.opacity = 1, (i = t.pbrMetallicRoughness) && (Array.isArray(i.baseColorFactor) && (r = i.baseColorFactor, e.color.fromArray(r), e.opacity = r[3]), void 0 !== i.baseColorTexture && a.push(n.assignTexture(e, "map", i.baseColorTexture))), Promise.all(a)
                }, t = "glTF", n = 12, i = 1313821514, r = 5130562, GLTFDracoMeshCompressionExtension.prototype.decodePrimitive = function(e, t) {
                    var n, i, r, a, o = this.json,
                        s = this.dracoLoader,
                        l = e.extensions[this.name].bufferView,
                        c = e.extensions[this.name].attributes,
                        u = {},
                        h = {},
                        p = {};
                    for (n in c) i = y[n] || n.toLowerCase(), u[i] = c[n];
                    for (n in e.attributes) i = y[n] || n.toLowerCase(), void 0 !== c[n] && (r = o.accessors[e.attributes[n]], a = d[r.componentType], p[i] = a, h[i] = !0 === r.normalized);
                    return t.getDependency("bufferView", l).then((function(e) {
                        return new Promise((function(t) {
                            s.decodeDracoFile(e, (function(e) {
                                var n, i, r;
                                for (n in e.attributes) i = e.attributes[n], void 0 !== (r = h[n]) && (i.normalized = r);
                                t(e)
                            }), u, p)
                        }))
                    }))
                }, GLTFTextureTransformExtension.prototype.extendTexture = function(e, t) {
                    return e = e.clone(), void 0 !== t.offset && e.offset.fromArray(t.offset), void 0 !== t.rotation && (e.rotation = t.rotation), void 0 !== t.scale && e.repeat.fromArray(t.scale), t.texCoord, e.needsUpdate = !0, e
                }, GLTFCubicSplineInterpolant.prototype = Object.create(Interpolant.prototype), GLTFCubicSplineInterpolant.prototype.constructor = GLTFCubicSplineInterpolant, GLTFCubicSplineInterpolant.prototype.copySampleValue_ = function(e) {
                    var t, n = this.resultBuffer,
                        i = this.sampleValues,
                        r = this.valueSize,
                        a = e * r * 3 + r;
                    for (t = 0; t !== r; t++) n[t] = i[a + t];
                    return n
                }, GLTFCubicSplineInterpolant.prototype.beforeStart_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_, GLTFCubicSplineInterpolant.prototype.afterEnd_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_, GLTFCubicSplineInterpolant.prototype.interpolate_ = function(e, t, n, i) {
                    var r, a, o, s, l, c = this.resultBuffer,
                        u = this.sampleValues,
                        h = this.valueSize,
                        d = 2 * h,
                        p = 3 * h,
                        f = i - t,
                        m = (n - t) / f,
                        g = m * m,
                        y = g * m,
                        x = e * p,
                        _ = x - p,
                        b = -2 * y + 3 * g,
                        M = y - g,
                        S = 1 - b,
                        A = M - g + m;
                    for (r = 0; r !== h; r++) a = u[_ + r + h], o = u[_ + r + d] * f, s = u[x + r + h], l = u[x + r] * f, c[r] = S * a + A * o + b * s + M * l;
                    return c
                }, 5126, 35675, 35676, 35664, 35665, 35666, 9729, 10497, 35678, a = 0, o = 1, s = 2, l = 3, c = 4, u = 5, h = 6, 5121, 5123, d = {
                    5120: Int8Array,
                    5121: Uint8Array,
                    5122: Int16Array,
                    5123: Uint16Array,
                    5125: Uint32Array,
                    5126: Float32Array
                }, f = {
                    9728: ci,
                    9729: fi,
                    9984: ui,
                    9985: mi,
                    9986: di,
                    9987: vi
                }, m = {
                    33071: si,
                    33648: li,
                    10497: oi
                }, g = {
                    SCALAR: 1,
                    VEC2: 2,
                    VEC3: 3,
                    VEC4: 4,
                    MAT2: 4,
                    MAT3: 9,
                    MAT4: 16
                }, y = {
                    POSITION: "position",
                    NORMAL: "normal",
                    TANGENT: "tangent",
                    TEXCOORD_0: "uv",
                    TEXCOORD_1: "uv2",
                    COLOR_0: "color",
                    WEIGHTS_0: "skinWeight",
                    JOINTS_0: "skinIndex"
                }, x = {
                    scale: "scale",
                    translation: "position",
                    rotation: "quaternion",
                    weights: "morphTargetInfluences"
                }, _ = {
                    CUBICSPLINE: void 0,
                    LINEAR: Rr,
                    STEP: Br
                }, b = "OPAQUE", M = "MASK", S = "BLEND", A = {
                    "image/png": Oi,
                    "image/jpeg": Fi
                }, GLTFParser.prototype.parse = function(e, t) {
                    var n = this,
                        i = this.json,
                        r = this.extensions;
                    this.cache.removeAll(), this.markDefs(), Promise.all([this.getDependencies("scene"), this.getDependencies("animation"), this.getDependencies("camera")]).then((function(t) {
                        var a = {
                            scene: t[0][i.scene || 0],
                            scenes: t[0],
                            animations: t[1],
                            cameras: t[2],
                            asset: i.asset,
                            parser: n,
                            userData: {}
                        };
                        addUnknownExtensionsToUserData(r, a, i), assignExtrasToUserData(a, i), e(a)
                    })).catch(t)
                }, GLTFParser.prototype.markDefs = function() {
                    var e, t, n, i, r, a, o, s, l = this.json.nodes || [],
                        c = this.json.skins || [],
                        u = this.json.meshes || [],
                        h = {},
                        d = {};
                    for (e = 0, t = c.length; e < t; e++)
                        for (i = 0, r = (n = c[e].joints).length; i < r; i++) l[n[i]].isBone = !0;
                    for (a = 0, o = l.length; a < o; a++) void 0 !== (s = l[a]).mesh && (void 0 === h[s.mesh] && (h[s.mesh] = d[s.mesh] = 0), h[s.mesh]++, void 0 !== s.skin && (u[s.mesh].isSkinnedMesh = !0));
                    this.json.meshReferences = h, this.json.meshUses = d
                }, GLTFParser.prototype.getDependency = function(t, n) {
                    var i = t + ":" + n,
                        r = this.cache.get(i);
                    if (!r) {
                        switch (t) {
                            case "scene":
                                r = this.loadScene(n);
                                break;
                            case "node":
                                r = this.loadNode(n);
                                break;
                            case "mesh":
                                r = this.loadMesh(n);
                                break;
                            case "accessor":
                                r = this.loadAccessor(n);
                                break;
                            case "bufferView":
                                r = this.loadBufferView(n);
                                break;
                            case "buffer":
                                r = this.loadBuffer(n);
                                break;
                            case "material":
                                r = this.loadMaterial(n);
                                break;
                            case "texture":
                                r = this.loadTexture(n);
                                break;
                            case "skin":
                                r = this.loadSkin(n);
                                break;
                            case "animation":
                                r = this.loadAnimation(n);
                                break;
                            case "camera":
                                r = this.loadCamera(n);
                                break;
                            case "light":
                                r = this.extensions[e.KHR_LIGHTS_PUNCTUAL].loadLight(n);
                                break;
                            default:
                                throw Error("Unknown type: " + t)
                        }
                        this.cache.add(i, r)
                    }
                    return r
                }, GLTFParser.prototype.getDependencies = function(e) {
                    var t, n, i = this.cache.get(e);
                    return i || (t = this, n = this.json[e + ("mesh" === e ? "es" : "s")] || [], i = Promise.all(n.map((function(n, i) {
                        return t.getDependency(e, i)
                    }))), this.cache.add(e, i)), i
                }, GLTFParser.prototype.loadBuffer = function(t) {
                    var n, i = this.json.buffers[t],
                        r = this.fileLoader;
                    if (i.type && "arraybuffer" !== i.type) throw Error("THREE.GLTFLoader: " + i.type + " buffer type is not supported.");
                    return void 0 === i.uri && 0 === t ? Promise.resolve(this.extensions[e.KHR_BINARY_GLTF].body) : (n = this.options, new Promise((function(e, t) {
                        r.load(resolveURL(i.uri, n.path), e, void 0, (function() {
                            t(Error('THREE.GLTFLoader: Failed to load buffer "' + i.uri + '".'))
                        }))
                    })))
                }, GLTFParser.prototype.loadBufferView = function(e) {
                    var t = this.json.bufferViews[e];
                    return this.getDependency("buffer", t.buffer).then((function(e) {
                        var n = t.byteLength || 0,
                            i = t.byteOffset || 0;
                        return e.slice(i, i + n)
                    }))
                }, GLTFParser.prototype.loadAccessor = function(e) {
                    var t, n = this,
                        i = this.json,
                        r = this.json.accessors[e];
                    return void 0 === r.bufferView && void 0 === r.sparse ? Promise.resolve(null) : (t = [], void 0 !== r.bufferView ? t.push(this.getDependency("bufferView", r.bufferView)) : t.push(null), void 0 !== r.sparse && (t.push(this.getDependency("bufferView", r.sparse.indices.bufferView)), t.push(this.getDependency("bufferView", r.sparse.values.bufferView))), Promise.all(t).then((function(e) {
                        var t, a, o, s, l, c, u, h, p, f, m, y, x, _ = e[0],
                            b = g[r.type],
                            M = d[r.componentType],
                            S = M.BYTES_PER_ELEMENT,
                            A = S * b,
                            w = r.byteOffset || 0,
                            T = void 0 !== r.bufferView ? i.bufferViews[r.bufferView].byteStride : void 0,
                            L = !0 === r.normalized;
                        if (T && T !== A ? (a = Math.floor(w / T), o = "InterleavedBuffer:" + r.bufferView + ":" + r.componentType + ":" + a + ":" + r.count, (s = n.cache.get(o)) || (s = new InterleavedBuffer(new M(_, a * T, r.count * T / S), T / S), n.cache.add(o, s)), t = new InterleavedBufferAttribute(s, b, w % T / S, L)) : t = new BufferAttribute(null === _ ? new M(r.count * b) : new M(_, w, r.count * b), b, L), void 0 !== r.sparse)
                            for (l = g.SCALAR, c = d[r.sparse.indices.componentType], u = r.sparse.indices.byteOffset || 0, h = r.sparse.values.byteOffset || 0, p = new c(e[1], u, r.sparse.count * l), f = new M(e[2], h, r.sparse.count * b), null !== _ && (t = new BufferAttribute(t.array.slice(), t.itemSize, t.normalized)), m = 0, y = p.length; m < y; m++)
                                if (x = p[m], t.setX(x, f[m * b]), b >= 2 && t.setY(x, f[m * b + 1]), b >= 3 && t.setZ(x, f[m * b + 2]), b >= 4 && t.setW(x, f[m * b + 3]), b >= 5) throw Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.");
                        return t
                    })))
                }, GLTFParser.prototype.loadTexture = function(t) {
                    var n, i, r, a = this,
                        o = this.json,
                        s = this.options,
                        l = this.textureLoader,
                        c = o.textures[t],
                        u = c.extensions || {};
                    return n = u[e.MSFT_TEXTURE_DDS] ? o.images[u[e.MSFT_TEXTURE_DDS].source] : o.images[c.source], i = n.uri, r = !1, void 0 !== n.bufferView && (i = a.getDependency("bufferView", n.bufferView).then((function(e) {
                        if (r = !0, "undefined" != typeof Blob) {
                            var t = new Blob([e], {
                                type: n.mimeType
                            });
                            return i = URL.createObjectURL(t)
                        }
                        return ""
                    }))), Promise.resolve(i).then((function(t) {
                        var n = s.manager.getHandler(t);
                        return n || (n = u[e.MSFT_TEXTURE_DDS] ? a.extensions[e.MSFT_TEXTURE_DDS].ddsLoader : l), new Promise((function(e, i) {
                            n.load(resolveURL(t, s.path), e, void 0, i)
                        }))
                    })).then((function(e) {
                        var t;
                        return !0 === r && "" != i && URL.revokeObjectURL && URL.revokeObjectURL(i), e.flipY = !1, void 0 !== c.name && (e.name = c.name), n.mimeType in A && (e.format = A[n.mimeType]), t = (o.samplers || {})[c.sampler] || {}, e.magFilter = f[t.magFilter] || fi, e.minFilter = f[t.minFilter] || vi, e.wrapS = m[t.wrapS] || oi, e.wrapT = m[t.wrapT] || oi, e
                    }))
                }, GLTFParser.prototype.assignTexture = function(t, n, i) {
                    var r = this;
                    return this.getDependency("texture", i.index).then((function(a) {
                        if (!a.isCompressedTexture) switch (n) {
                            case "aoMap":
                            case "emissiveMap":
                            case "metalnessMap":
                            case "normalMap":
                            case "roughnessMap":
                                a.format = Fi
                        }
                        if (r.extensions[e.KHR_TEXTURE_TRANSFORM]) {
                            var o = void 0 !== i.extensions ? i.extensions[e.KHR_TEXTURE_TRANSFORM] : void 0;
                            o && (a = r.extensions[e.KHR_TEXTURE_TRANSFORM].extendTexture(a, o))
                        }
                        t[n] = a
                    }))
                }, GLTFParser.prototype.assignFinalMaterial = function(t) {
                    var n, i, r, a, o = t.geometry,
                        s = t.material,
                        l = this.extensions,
                        c = void 0 !== o.attributes.tangent,
                        u = void 0 !== o.attributes.color,
                        h = void 0 === o.attributes.normal,
                        d = !0 === t.isSkinnedMesh,
                        p = Object.keys(o.morphAttributes).length > 0,
                        f = p && void 0 !== o.morphAttributes.normal;
                    t.isPoints ? (n = "PointsMaterial:" + s.uuid, (i = this.cache.get(n)) || (i = new PointsMaterial, Material.prototype.copy.call(i, s), i.color.copy(s.color), i.map = s.map, i.sizeAttenuation = !1, this.cache.add(n, i)), s = i) : t.isLine && (n = "LineBasicMaterial:" + s.uuid, (r = this.cache.get(n)) || (r = new LineBasicMaterial, Material.prototype.copy.call(r, s), r.color.copy(s.color), this.cache.add(n, r)), s = r), (c || u || h || d || p) && (n = "ClonedMaterial:" + s.uuid + ":", s.isGLTFSpecularGlossinessMaterial && (n += "specular-glossiness:"), d && (n += "skinning:"), c && (n += "vertex-tangents:"), u && (n += "vertex-colors:"), h && (n += "flat-shading:"), p && (n += "morph-targets:"), f && (n += "morph-normals:"), (a = this.cache.get(n)) || (a = s.isGLTFSpecularGlossinessMaterial ? l[e.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].cloneMaterial(s) : s.clone(), d && (a.skinning = !0), c && (a.vertexTangents = !0), u && (a.vertexColors = Xc), h && (a.flatShading = !0), p && (a.morphTargets = !0), f && (a.morphNormals = !0), this.cache.add(n, a)), s = a), s.aoMap && void 0 === o.attributes.uv2 && void 0 !== o.attributes.uv && o.setAttribute("uv2", new BufferAttribute(o.attributes.uv.array, 2)), s.isGLTFSpecularGlossinessMaterial && (t.onBeforeRender = l[e.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].refreshUniforms), t.material = s
                }, GLTFParser.prototype.loadMaterial = function(t) {
                    var n, i, r, a, o, s, l = this,
                        c = this.json,
                        u = this.extensions,
                        h = c.materials[t],
                        d = {},
                        p = h.extensions || {},
                        f = [];
                    return p[e.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS] ? (i = u[e.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS], n = i.getMaterialType(), f.push(i.extendParams(d, h, l))) : p[e.KHR_MATERIALS_UNLIT] ? (r = u[e.KHR_MATERIALS_UNLIT], n = r.getMaterialType(), f.push(r.extendParams(d, h, l))) : (n = MeshStandardMaterial, a = h.pbrMetallicRoughness || {}, d.color = new Color(1, 1, 1), d.opacity = 1, Array.isArray(a.baseColorFactor) && (o = a.baseColorFactor, d.color.fromArray(o), d.opacity = o[3]), void 0 !== a.baseColorTexture && f.push(l.assignTexture(d, "map", a.baseColorTexture)), d.metalness = void 0 !== a.metallicFactor ? a.metallicFactor : 1, d.roughness = void 0 !== a.roughnessFactor ? a.roughnessFactor : 1, void 0 !== a.metallicRoughnessTexture && (f.push(l.assignTexture(d, "metalnessMap", a.metallicRoughnessTexture)), f.push(l.assignTexture(d, "roughnessMap", a.metallicRoughnessTexture)))), !0 === h.doubleSided && (d.side = hn), (s = h.alphaMode || b) === S ? d.transparent = !0 : (d.transparent = !1, s === M && (d.alphaTest = void 0 !== h.alphaCutoff ? h.alphaCutoff : .5)), void 0 !== h.normalTexture && n !== MeshBasicMaterial && (f.push(l.assignTexture(d, "normalMap", h.normalTexture)), d.normalScale = new Vector2(1, 1), void 0 !== h.normalTexture.scale && d.normalScale.set(h.normalTexture.scale, h.normalTexture.scale)), void 0 !== h.occlusionTexture && n !== MeshBasicMaterial && (f.push(l.assignTexture(d, "aoMap", h.occlusionTexture)), void 0 !== h.occlusionTexture.strength && (d.aoMapIntensity = h.occlusionTexture.strength)), void 0 !== h.emissiveFactor && n !== MeshBasicMaterial && (d.emissive = (new Color).fromArray(h.emissiveFactor)), void 0 !== h.emissiveTexture && n !== MeshBasicMaterial && f.push(l.assignTexture(d, "emissiveMap", h.emissiveTexture)), Promise.all(f).then((function() {
                        var t;
                        return t = n === ShaderMaterial ? u[e.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(d) : new n(d), void 0 !== h.name && (t.name = h.name), t.map && (t.map.encoding = Xr), t.emissiveMap && (t.emissiveMap.encoding = Xr), t.specularMap && (t.specularMap.encoding = Xr), assignExtrasToUserData(t, h), h.extensions && addUnknownExtensionsToUserData(u, t, h), t
                    }))
                }, GLTFParser.prototype.loadGeometries = function(t) {
                    function createDracoPrimitive(t) {
                        return h[e.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(t, u).then((function(e) {
                            return addPrimitiveAttributes(e, t, u)
                        }))
                    }
                    var n, i, r, a, o, s, l, c, u = this,
                        h = this.extensions,
                        d = this.primitiveCache,
                        p = [];
                    for (n = 0, i = t.length; n < i; n++) r = t[n], c = void 0, (o = d[a = (c = (l = r).extensions && l.extensions[e.KHR_DRACO_MESH_COMPRESSION]) ? "draco:" + c.bufferView + ":" + c.indices + ":" + createAttributesKey(c.attributes) : l.indices + ":" + createAttributesKey(l.attributes) + ":" + l.mode]) ? p.push(o.promise) : (s = r.extensions && r.extensions[e.KHR_DRACO_MESH_COMPRESSION] ? createDracoPrimitive(r) : addPrimitiveAttributes(new BufferGeometry, r, u), d[a] = {
                        primitive: r,
                        promise: s
                    }, p.push(s));
                    return Promise.all(p)
                }, GLTFParser.prototype.loadMesh = function(e) {
                    var t, n, i, r = this,
                        d = this.json,
                        p = d.meshes[e],
                        f = p.primitives,
                        m = [];
                    for (t = 0, n = f.length; t < n; t++) i = void 0 === f[t].material ? w = w || new MeshStandardMaterial({
                        color: 16777215,
                        emissive: 0,
                        metalness: 1,
                        roughness: 1,
                        transparent: !1,
                        depthTest: !0,
                        side: cn
                    }) : this.getDependency("material", f[t].material), m.push(i);
                    return Promise.all(m).then((function(t) {
                        return r.loadGeometries(f).then((function(n) {
                            var i, d, m, g, y, x, _, b = [];
                            for (i = 0, d = n.length; i < d; i++) {
                                if (m = n[i], g = f[i], x = t[i], g.mode === c || g.mode === u || g.mode === h || void 0 === g.mode) !0 !== (y = !0 === p.isSkinnedMesh ? new SkinnedMesh(m, x) : new Mesh(m, x)).isSkinnedMesh || y.geometry.attributes.skinWeight.normalized || y.normalizeSkinWeights(), g.mode === u ? y.drawMode = jr : g.mode === h && (y.drawMode = Wr);
                                else if (g.mode === o) y = new LineSegments(m, x);
                                else if (g.mode === l) y = new Line(m, x);
                                else if (g.mode === s) y = new LineLoop(m, x);
                                else {
                                    if (g.mode !== a) throw Error("THREE.GLTFLoader: Primitive mode unsupported: " + g.mode);
                                    y = new Points(m, x)
                                }
                                Object.keys(y.geometry.morphAttributes).length > 0 && updateMorphTargets(y, p), y.name = p.name || "mesh_" + e, n.length > 1 && (y.name += "_" + i), assignExtrasToUserData(y, p), r.assignFinalMaterial(y), b.push(y)
                            }
                            if (1 === b.length) return b[0];
                            for (_ = new Group, i = 0, d = b.length; i < d; i++) _.add(b[i]);
                            return _
                        }))
                    }))
                }, GLTFParser.prototype.loadCamera = function(e) {
                    var t, n = this.json.cameras[e],
                        i = n[n.type];
                    if (i) return "perspective" === n.type ? t = new PerspectiveCamera(Fa.radToDeg(i.yfov), i.aspectRatio || 1, i.znear || 1, i.zfar || 2e6) : "orthographic" === n.type && (t = new OrthographicCamera(i.xmag / -2, i.xmag / 2, i.ymag / 2, i.ymag / -2, i.znear, i.zfar)), void 0 !== n.name && (t.name = n.name), assignExtrasToUserData(t, n), Promise.resolve(t)
                }, GLTFParser.prototype.loadSkin = function(e) {
                    var t = this.json.skins[e],
                        n = {
                            joints: t.joints
                        };
                    return void 0 === t.inverseBindMatrices ? Promise.resolve(n) : this.getDependency("accessor", t.inverseBindMatrices).then((function(e) {
                        return n.inverseBindMatrices = e, n
                    }))
                }, GLTFParser.prototype.loadAnimation = function(e) {
                    var t, n, i, r, a, o, s, l, c = this.json,
                        u = c.animations[e],
                        h = [],
                        d = [],
                        p = [],
                        f = [],
                        m = [];
                    for (t = 0, n = u.channels.length; t < n; t++) i = u.channels[t], r = u.samplers[i.sampler], o = void 0 !== (a = i.target).node ? a.node : a.id, s = void 0 !== u.parameters ? u.parameters[r.input] : r.input, l = void 0 !== u.parameters ? u.parameters[r.output] : r.output, h.push(this.getDependency("node", o)), d.push(this.getDependency("accessor", s)), p.push(this.getDependency("accessor", l)), f.push(r), m.push(a);
                    return Promise.all([Promise.all(h), Promise.all(d), Promise.all(p), Promise.all(f), Promise.all(m)]).then((function(t) {
                        var n, i, r, a, o, s, l, c, h, d, p, f, m, g, y, b, M, S = t[0],
                            A = t[1],
                            w = t[2],
                            T = t[3],
                            L = t[4],
                            C = [];
                        for (n = 0, i = S.length; n < i; n++)
                            if (r = S[n], a = A[n], o = w[n], s = T[n], l = L[n], void 0 !== r) {
                                switch (r.updateMatrix(), r.matrixAutoUpdate = !0, x[l.path]) {
                                    case x.weights:
                                        c = NumberKeyframeTrack;
                                        break;
                                    case x.rotation:
                                        c = QuaternionKeyframeTrack;
                                        break;
                                    case x.position:
                                    case x.scale:
                                    default:
                                        c = VectorKeyframeTrack
                                }
                                if (h = r.name ? r.name : r.uuid, d = void 0 !== s.interpolation ? _[s.interpolation] : Rr, p = [], x[l.path] === x.weights ? r.traverse((function(e) {
                                        !0 === e.isMesh && e.morphTargetInfluences && p.push(e.name ? e.name : e.uuid)
                                    })) : p.push(h), f = o.array, o.normalized) {
                                    if (f.constructor === Int8Array) m = 1 / 127;
                                    else if (f.constructor === Uint8Array) m = 1 / 255;
                                    else if (f.constructor == Int16Array) m = 1 / 32767;
                                    else {
                                        if (f.constructor !== Uint16Array) throw Error("THREE.GLTFLoader: Unsupported output accessor component type.");
                                        m = 1 / 65535
                                    }
                                    for (g = new Float32Array(f.length), y = 0, b = f.length; y < b; y++) g[y] = f[y] * m;
                                    f = g
                                }
                                for (y = 0, b = p.length; y < b; y++) M = new c(p[y] + "." + x[l.path], a.array, f, d), "CUBICSPLINE" === s.interpolation && (M.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline(e) {
                                    return new GLTFCubicSplineInterpolant(this.times, this.values, this.getValueSize() / 3, e)
                                }, M.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0), C.push(M)
                            }
                        return new AnimationClip(void 0 !== u.name ? u.name : "animation_" + e, void 0, C)
                    }))
                }, GLTFParser.prototype.loadNode = function(t) {
                    var n, i = this.json,
                        r = this.extensions,
                        a = this,
                        o = i.meshReferences,
                        s = i.meshUses,
                        l = i.nodes[t];
                    return (n = [], void 0 !== l.mesh && n.push(a.getDependency("mesh", l.mesh).then((function(e) {
                        var t, n, i, r;
                        if (o[l.mesh] > 1)
                            for (n = s[l.mesh]++, (t = e.clone()).name += "_instance_" + n, t.onBeforeRender = e.onBeforeRender, i = 0, r = t.children.length; i < r; i++) t.children[i].name += "_instance_" + n, t.children[i].onBeforeRender = e.children[i].onBeforeRender;
                        else t = e;
                        return void 0 !== l.weights && t.traverse((function(e) {
                            if (e.isMesh)
                                for (var t = 0, n = l.weights.length; t < n; t++) e.morphTargetInfluences[t] = l.weights[t]
                        })), t
                    }))), void 0 !== l.camera && n.push(a.getDependency("camera", l.camera)), l.extensions && l.extensions[e.KHR_LIGHTS_PUNCTUAL] && void 0 !== l.extensions[e.KHR_LIGHTS_PUNCTUAL].light && n.push(a.getDependency("light", l.extensions[e.KHR_LIGHTS_PUNCTUAL].light)), Promise.all(n)).then((function(e) {
                        var t, n, i, a;
                        if ((t = !0 === l.isBone ? new Bone : e.length > 1 ? new Group : 1 === e.length ? e[0] : new Object3D) !== e[0])
                            for (n = 0, i = e.length; n < i; n++) t.add(e[n]);
                        return void 0 !== l.name && (t.userData.name = l.name, t.name = PropertyBinding.sanitizeNodeName(l.name)), assignExtrasToUserData(t, l), l.extensions && addUnknownExtensionsToUserData(r, t, l), void 0 !== l.matrix ? ((a = new Matrix4).fromArray(l.matrix), t.applyMatrix(a)) : (void 0 !== l.translation && t.position.fromArray(l.translation), void 0 !== l.rotation && t.quaternion.fromArray(l.rotation), void 0 !== l.scale && t.scale.fromArray(l.scale)), t
                    }))
                }, GLTFParser.prototype.loadScene = function() {
                    function buildNodeHierachy(e, t, n, i) {
                        var r = n.nodes[e];
                        return i.getDependency("node", e).then((function(e) {
                            return void 0 === r.skin ? e : i.getDependency("skin", r.skin).then((function(e) {
                                var n, r, a;
                                for (n = [], r = 0, a = (t = e).joints.length; r < a; r++) n.push(i.getDependency("node", t.joints[r]));
                                return Promise.all(n)
                            })).then((function(n) {
                                return e.traverse((function(e) {
                                    var i, r, a, o, s, l;
                                    if (e.isMesh) {
                                        for (i = [], r = [], a = 0, o = n.length; a < o; a++)(s = n[a]) && (i.push(s), l = new Matrix4, void 0 !== t.inverseBindMatrices && l.fromArray(t.inverseBindMatrices.array, 16 * a), r.push(l));
                                        e.bind(new Skeleton(i, r), e.matrixWorld)
                                    }
                                })), e
                            }));
                            var t
                        })).then((function(e) {
                            var a, o, s, l, c;
                            if (t.add(e), a = [], r.children)
                                for (s = 0, l = (o = r.children).length; s < l; s++) c = o[s], a.push(buildNodeHierachy(c, e, n, i));
                            return Promise.all(a)
                        }))
                    }
                    return function loadScene(e) {
                        var t, n, i, r, a = this.json,
                            o = this.extensions,
                            s = this.json.scenes[e],
                            l = this,
                            c = new Scene;
                        for (void 0 !== s.name && (c.name = s.name), assignExtrasToUserData(c, s), s.extensions && addUnknownExtensionsToUserData(o, c, s), n = [], i = 0, r = (t = s.nodes || []).length; i < r; i++) n.push(buildNodeHierachy(t[i], c, a, l));
                        return Promise.all(n).then((function() {
                            return c
                        }))
                    }
                }(), GLTFLoader
            }(), g = new m, y = [], x = __webpack_require__(7120), _ = __webpack_require__.n(x);
            const Jc = {
                RENDER_INTERP: 1,
                RENDER_BLIT: 2
            };
            b = new Matrix4, M = new Matrix4, new Matrix4, S = new Vector3, A = new Vector3, new Vector3, new Vector3, new Vector3, new Vector3, w = function() {
                function MergeMeshes() {
                    classCallCheck_classCallCheck(this, MergeMeshes)
                }
                return createClass_createClass(MergeMeshes, null, [{
                    key: "createMergedMesh",
                    value: function createMergedMesh(e) {
                        var t = new BufferGeometry,
                            n = 8e3,
                            i = 8e3;
                        return t.indexArray = new Uint16Array(3 * i), t.positionArray = new Float32Array(3 * n), t.normalArray = new Float32Array(3 * n), t.uvArray = new Float32Array(2 * n), t.uv2Array = new Float32Array(2 * n), t.colorArray = new Float32Array(4 * n), t.skinWeightArray = new Float32Array(4 * n), t.skinIndexArray = new Uint16Array(4 * n), t.setIndex(new BufferAttribute(t.indexArray, 1)), t.setAttribute("position", new BufferAttribute(t.positionArray, 3)), t.setAttribute("normal", new BufferAttribute(t.normalArray, 3)), t.setAttribute("uv", new BufferAttribute(t.uvArray, 2)), t.setAttribute("uv2", new BufferAttribute(t.uv2Array, 2)), t.setAttribute("color", new BufferAttribute(t.colorArray, 4)), t.setAttribute("skinWeight", new BufferAttribute(t.skinWeightArray, 4)), t.setAttribute("skinIndex", new BufferAttribute(t.skinIndexArray, 4)), t.setDrawRange(0, 0), new SkinnedMesh(t, e)
                    }
                }, {
                    key: "getBoneIndex",
                    value: function getBoneIndex(e, t) {
                        var n, i;
                        for (n = 0, i = e.bones.length; n < i; n++)
                            if (e.bones[n].name === t) return n
                    }
                }, {
                    key: "drawTex",
                    value: function drawTex(e, t, n, i, r, a, o, s, l, c, u) {
                        t.flipInCanvas ? (e.save(), e.translate(o, s + c), e.scale(1, -1), e.drawImage(t.image, n, i, r, a, 0, 0, l, c), e.restore()) : e.drawImage(t.image, n, i, r, a, o, s, l, c)
                    }
                }, {
                    key: "merge",
                    value: function merge(e, t) {
                        var n, i, r, a, o, s, l, c, u, h, d, p, f, m, g, y, x, _, w, T, L, C, P, E, I, F, O, B, R, N, D, V, U, z, G, k, j, W, H, X, Y, q, Q, J, Z, K, $, ee, te, ne, ie, re, ae, oe, se, le, ce, ue, he, de, pe, fe, me, ge, ve, ye, xe, _e, be, Me, Se, Ae, we, Te, Le, Ce, Pe, Ee, Ie, Fe, Oe, Be, Re, Ne, De, Ve, Ue, ze, Ge, ke, je, We, He, Xe, Ye, qe, Qe, Je, Ze, Ke, $e, et, tt, nt, it, rt, at, ot, st, lt, ct, ut, ht, dt, pt, ft, mt, gt, vt, yt, xt, _t, bt = t.imageWidth,
                            Mt = t.imageHeight,
                            St = [],
                            At = [];
                        for (n = 0; n < t.images.length; n++) i = void 0, "undefined" != typeof document ? ((i = document.createElement("canvas")).width = bt, i.height = Mt) : i = new OffscreenCanvas(bt, Mt), (r = i.getContext("2d")).translate(0, Mt), r.scale(1, -1), St.push(i), At.push(r);
                        for (a = t.slots, o = t.statics, s = t.draws, l = e.geometry, c = new Box3, u = !0, h = 0, d = 0, p = 0; p < a.length; p++)
                            if (void 0 !== a[p].model && void 0 !== (f = a[p].model.geometry)) {
                                for (m = l.index.array, g = f.index.array, y = l.attributes.position.array, x = f.attributes.position.array, _ = l.attributes.normal.array, w = f.attributes.normal.array, T = l.attributes.uv.array, L = f.attributes.uv.array, C = l.attributes.uv2.array, P = f.attributes.uv2 ? f.attributes.uv2.array : f.attributes.uv.array, E = l.attributes.skinWeight.array, I = f.attributes.skinWeight.array, F = l.attributes.skinIndex.array, O = f.attributes.skinIndex.array, B = l.attributes.color.array, R = f.attributes.color && f.attributes.color.array ? f.attributes.color.array : void 0, N = h, D = 0, V = f.index.count; D < V; D++) m[N + D] = g[D] + d;
                                for (h += f.index.count, U = f.attributes.position.count, z = 2 * d, G = a[p].uScale, k = a[p].vScale, j = a[p].uOfs, W = a[p].vOfs, H = 0, X = 2 * f.attributes.uv.count; H < X; H++) q = (Y = 0 == (1 & H)) ? G : k, Q = Y ? j : W, J = L[H], (Z = P[H]) < 0 && (Z += 1), Z > 1 && (Z -= 1), T[z + H] = J * q + Q, C[z + H] = Z * q + Q;
                                for (K = 3 * d, $ = 0, ee = 3 * f.attributes.position.count; $ < ee; $++) y[K + $] = x[$], _[K + $] = w[$];
                                for (te = 4 * d, ne = 0, ie = 4 * f.attributes.skinWeight.count; ne < ie; ne++) E[te + ne] = I[ne], F[te + ne] = O[ne];
                                if (R)
                                    for (re = 0, ae = 4 * f.attributes.color.count; re < ae; re++) B[te + re] = R[re];
                                else
                                    for (oe = 0, se = 4 * f.attributes.skinWeight.count; oe < se; oe++) B[te + oe] = 0;
                                for (d += U, le = bt * j, ce = Mt * W, ue = 0; ue < t.images.length; ue++) he = t.images[ue], "object" == _typeof(de = a[p][he]) ? (pe = a[p][he].image, this.drawTex(At[ue], de, 0, 0, pe.width, pe.height, le, ce, bt * G, Mt * k)) : "string" == typeof de && (At[ue].fillStyle = de, At[ue].fillRect(le, ce, bt * G, Mt * k));
                                u ? (u = !1, c.copy(f.boundingBox)) : c.union(f.boundingBox)
                            }
                        for (fe = 0; fe < o.length; fe++)
                            if (void 0 !== o[fe].model && void 0 !== (me = o[fe].model.geometry)) {
                                for (ge = l.index.array, ve = me.index.array, ye = l.attributes.position.array, xe = me.attributes.position.array, _e = l.attributes.normal.array, be = me.attributes.normal.array, Me = l.attributes.uv.array, Se = me.attributes.uv ? me.attributes.uv.array : void 0, Ae = l.attributes.uv2.array, we = me.attributes.uv2 ? me.attributes.uv2.array : me.attributes.uv.array, Te = l.attributes.skinWeight.array, Le = l.attributes.skinIndex.array, Ce = MergeMeshes.getBoneIndex(e.skeleton, o[fe].attach), b.copy(e.skeleton.boneInverses[Ce]).invert(), M.makeTranslation(o[fe].offsetX, o[fe].offsetY, o[fe].offsetZ), o[fe].model.updateWorldMatrix(!0), b.multiply(M), Pe = l.attributes.color.array, Ee = me.attributes.color && me.attributes.color.array ? me.attributes.color.array : void 0, Ie = h, Fe = 0, Oe = me.index.count; Fe < Oe; Fe++) ge[Ie + Fe] = ve[Fe] + d;
                                if (h += me.index.count, Be = me.attributes.position.count, Re = 2 * d, Ne = o[fe].uScale, De = o[fe].vScale, Ve = o[fe].uOfs, Ue = o[fe].vOfs, Se)
                                    for (ze = 0, Ge = 2 * me.attributes.uv.count; ze < Ge; ze++) je = (ke = 0 == (1 & ze)) ? Ne : De, We = ke ? Ve : Ue, He = Se[ze], (Xe = we[ze]) < 0 && (Xe += 1), Xe > 1 && (Xe -= 1), Me[Re + ze] = He * je + We, Ae[Re + ze] = Xe * je + We;
                                for (Ye = 3 * d, qe = 0, Qe = 3 * me.attributes.position.count; qe < Qe; qe += 3) S.set(xe[qe], xe[qe + 1], xe[qe + 2]), A.set(be[qe], be[qe + 1], be[qe + 2]), S.applyMatrix4(b), A.transformDirection(b), ye[Ye + qe + 0] = S.x, _e[Ye + qe + 0] = A.x, ye[Ye + qe + 1] = S.y, _e[Ye + qe + 1] = A.y, ye[Ye + qe + 2] = S.z, _e[Ye + qe + 2] = A.z;
                                for (Je = 4 * d, Ze = 0, Ke = 4 * Be; Ze < Ke; Ze += 4) Te[Je + Ze] = 1, Le[Je + Ze] = Ce, Te[Je + Ze + 1] = 0, Le[Je + Ze + 1] = Ce, Te[Je + Ze + 2] = 0, Le[Je + Ze + 2] = Ce, Te[Je + Ze + 3] = 0, Le[Je + Ze + 3] = Ce;
                                if (Ee)
                                    for ($e = 0, et = 4 * Be; $e < et; $e++) Pe[Je + $e] = Ee[$e];
                                else
                                    for (tt = 0, nt = 4 * Be; tt < nt; tt++) Pe[Je + tt] = 0;
                                for (d += Be, it = bt * Ve, rt = Mt * Ue, at = 0; at < t.images.length; at++) ot = t.images[at], "object" == _typeof(st = o[fe][ot]) ? (lt = o[fe][ot].image, this.drawTex(At[at], st, 0, 0, lt.width, lt.height, it, rt, bt * Ne, Mt * De)) : "string" == typeof st && (At[at].fillStyle = st, At[at].fillRect(it, rt, bt * Ne, Mt * De))
                            }
                        if (s)
                            for (ct = 0; ct < s.length; ct++)
                                for (ut = s[ct].uScale, ht = s[ct].vScale, dt = bt * s[ct].uOfs, pt = Mt * s[ct].vOfs, ft = 0; ft < t.images.length; ft++) mt = t.images[ft], "object" == _typeof(gt = s[ct][mt]) ? (vt = s[ct][mt].image, this.drawTex(At[ft], gt, 0, 0, vt.width, vt.height, dt, pt, bt * ut, Mt * ht)) : "string" == typeof gt && (At[ft].fillStyle = gt, At[ft].fillRect(dt, pt, bt * ut, Mt * ht));
                        for (l.index.needsUpdate = !0, l.attributes.position.needsUpdate = !0, l.attributes.normal.needsUpdate = !0, l.attributes.uv.needsUpdate = !0, l.attributes.uv2.needsUpdate = !0, l.attributes.color.needsUpdate = !0, l.attributes.skinWeight.needsUpdate = !0, l.attributes.skinIndex.needsUpdate = !0, l.boundingBox = c, l.boundingSphere = l.boundingBox.getBoundingSphere(new Sphere), l.setDrawRange(0, h), yt = 0; yt < t.images.length; yt++) xt = t.images[yt], (_t = new Texture(St[yt])).generateMipmaps = !0, _t.wrapS = _t.wrapT = oi, _t.minFilter = fi, _t.needsUpdate = !0, e.material.uniforms[xt] = {
                            type: "t",
                            value: _t
                        }, e.material.uniforms[xt].needsUpdate = !0, t.debugMat && (t.debugMat.map = _t, t.debugMat.needsUpdate = !0);
                        e.material.needsUpdate = !0, e.material.uniformsNeedUpdate = !0
                    }
                }]), MergeMeshes
            }(), T = {
                vertexShader: "attribute vec4 color;\nvarying vec2 vUv;\nvarying vec4 vTint;\nvoid main() {\nvUv = uv;\nvTint = color;\nvec4 outPos = projectionMatrix * modelViewMatrix * vec4(position,1.0);\ngl_Position = outPos;\n}",
                fragmentShader: "uniform sampler2D tDiffuse;\nvarying vec2 vUv;\nvarying vec4 vTint;\nvoid main() {\nvec4 texelDiffuse = texture2D( tDiffuse, vUv);\ngl_FragColor = vTint * vec4(texelDiffuse.rgb,texelDiffuse.a);\n}"
            }, L = function(e) {
                function SpriteSet(e, n, i) {
                    var r, a, o, s, l, c, u, h, d, p, f;
                    for (a in classCallCheck_classCallCheck(this, SpriteSet), (n = n || {}).glyphs = n.glyphs || {}, n.fonts = n.fonts || {}, n.fonts)
                        if (void 0 === (o = n.fonts[a]).charMap)
                            for (o.charMap = new Map, l = 0, c = (s = o.data.chars).length; l < c; l++) o.charMap.set(s[l].id, s[l]);
                    return u = new BufferGeometry, d = new Float32Array(6 * i * 9), p = !1, e.isMaterial ? h = e : (n.imageWidth || (n.imageWidth = e.image.width), n.imageHeight || (n.imageHeight = e.image.height), h = new ShaderMaterial({
                        vertexShader: T.vertexShader,
                        fragmentShader: T.fragmentShader,
                        uniforms: {
                            tDiffuse: {
                                type: "t",
                                value: e
                            }
                        },
                        side: hn,
                        transparent: !0
                    }), p = !0), f = new InterleavedBuffer(d, 9), u.setAttribute("position", new InterleavedBufferAttribute(f, 3, 0, !1)), u.setAttribute("uv", new InterleavedBufferAttribute(f, 2, 3, !1)), u.setAttribute("color", new InterleavedBufferAttribute(f, 4, 5, !1)), (r = t.call(this, u, h)).frustumCulled = !1, r.maxSprites = i, r.desc = n, r.array = d, r.interleavedBuffer = f, r.createdMaterial = p, r
                }
                _inherits(SpriteSet, e);
                var t = SpriteSet_createSuper(SpriteSet);
                return createClass_createClass(SpriteSet, [{
                    key: "dispose",
                    value: function dispose() {
                        this.geometry.dispose(), this.createdMaterial && this.material.dispose()
                    }
                }, {
                    key: "stringWidth",
                    value: function stringWidth(e, t, n) {
                        var i, r, a, o, s, l, c, u, h, d, p;
                        for (n = n || 1, r = (i = this.desc.fonts[e]).data.common.base * n, a = i.data.kernings, o = void 0, s = 0, l = 0, c = 0, u = t.length; c < u; c++) h = t.charCodeAt(c), void 0 !== (d = i.charMap.get(h)) ? (o && a[o] && void 0 !== (p = a[o][h]) && (l += p * n), l += d.xadvance * n, o = h) : l += Math.ceil(r / 4);
                        return l - s
                    }
                }, {
                    key: "drawString",
                    value: function drawString(e, t, n, i, r, a, o, s, l) {
                        var c, u, h, d, p, f, m, g, y, x, _, b, M, S, A, w, T, L;
                        for (r = r || 1, c = this.desc.fonts[e], void 0 === a && (a = 1), void 0 === o && (o = 1), void 0 === s && (s = 1), void 0 === l && (l = 1), u = this.desc.imageWidth, h = this.desc.imageHeight, d = c.data.common.base * r, p = c.data.kernings, f = void 0, m = t, g = 0, y = i.length; g < y; g++) x = i.charCodeAt(g), void 0 !== (_ = c.charMap.get(x)) ? (f && p[f] && void 0 !== (b = p[f][x]) && (t += b * r), M = _.width, S = _.height, A = _.x + c.u1, w = _.y + c.v1, T = t + _.xoffset * r, L = n + _.yoffset * r - d, this.blt(T, L, T + M * r, L + S * r, A / u, w / h, (A + M) / u, (w + S) / h, a, o, s, l), t += _.xadvance * r, f = x) : t += Math.ceil(d / 4);
                        return t - m
                    }
                }, {
                    key: "drawGlyph",
                    value: function drawGlyph(e, t, n, i, r, a, o, s, l) {
                        var c, u, h = this.desc.glyphs[e];
                        void 0 !== h && (void 0 === h.width && (h.width = h.u2 - h.u1), void 0 === h.height && (h.height = h.v2 - h.v1), void 0 === i && (i = t + h.width), void 0 === r && (r = n + h.height), void 0 === a && (a = 1), void 0 === o && (o = 1), void 0 === s && (s = 1), void 0 === l && (l = 1), c = this.desc.imageWidth, u = this.desc.imageHeight, this.blt(t, n, i, r, h.u1 / c, h.v1 / u, h.u2 / c, h.v2 / u, a, o, s, l))
                    }
                }, {
                    key: "drawGlyphScale",
                    value: function drawGlyphScale(e, t, n, i, r, a, o, s, l, c, u, h) {
                        var d, p, f, m, g, y, x, _, b = this.desc.glyphs[e];
                        void 0 !== b && (void 0 === b.width && (b.width = b.u2 - b.u1), void 0 === b.height && (b.height = b.v2 - b.v1), void 0 === a && (a = .5), void 0 === o && (o = .5), void 0 === i && (i = t + b.width), void 0 === r && (r = n + b.height), void 0 === l && (l = 1), void 0 === c && (c = 1), void 0 === u && (u = 1), void 0 === h && (h = 1), d = this.desc.imageWidth, p = this.desc.imageHeight, g = ((f = i - t) * s - f) * a, y = ((m = r - n) * s - m) * o, x = (f * s - f) * (1 - a), _ = (m * s - m) * (1 - o), this.blt(t - g, n - y, i + x, r + _, b.u1 / d, b.v1 / p, b.u2 / d, b.v2 / p, l, c, u, h))
                    }
                }, {
                    key: "drawGlyphPartial",
                    value: function drawGlyphPartial(e, t, n, i, r, a, o, s, l, c, u, h, d) {
                        var p, f, m = this.desc.glyphs[e];
                        void 0 !== m && (void 0 === m.width && (m.width = m.u2 - m.u1), void 0 === m.height && (m.height = m.v2 - m.v1), void 0 === i && (i = t + m.width), void 0 === r && (r = n + m.height), void 0 === c && (c = 1), void 0 === h && (h = 1), void 0 === u && (u = 1), void 0 === d && (d = 1), void 0 === a && (a = 1), void 0 === o && (o = 1), void 0 === s && (s = 1), void 0 === l && (l = 1), p = this.desc.imageWidth, f = this.desc.imageHeight, this.blt(lerp(i, t, c), lerp(r, n, u), lerp(t, i, h), lerp(n, r, d), lerp(m.u2, m.u1, c) / p, lerp(m.v2, m.v1, u) / f, lerp(m.u1, m.u2, h) / p, lerp(m.v1, m.v2, d) / f, a, o, s, l))
                    }
                }, {
                    key: "blt",
                    value: function blt(e, t, n, i, r, a, o, s, l, c, u, h) {
                        var d = this.array,
                            p = this.index,
                            f = 1;
                        d[p + 0] = e, d[p + 1] = -t, d[p + 2] = f, d[p + 3] = r, d[p + 4] = 1 - a, d[p + 5] = l, d[p + 6] = c, d[p + 7] = u, d[p + 8] = h, d[(p += 9) + 0] = n, d[p + 1] = -t, d[p + 2] = f, d[p + 3] = o, d[p + 4] = 1 - a, d[p + 5] = l, d[p + 6] = c, d[p + 7] = u, d[p + 8] = h, d[(p += 9) + 0] = e, d[p + 1] = -i, d[p + 2] = f, d[p + 3] = r, d[p + 4] = 1 - s, d[p + 5] = l, d[p + 6] = c, d[p + 7] = u, d[p + 8] = h, d[(p += 9) + 0] = n, d[p + 1] = -t, d[p + 2] = f, d[p + 3] = o, d[p + 4] = 1 - a, d[p + 5] = l, d[p + 6] = c, d[p + 7] = u, d[p + 8] = h, d[(p += 9) + 0] = n, d[p + 1] = -i, d[p + 2] = f, d[p + 3] = o, d[p + 4] = 1 - s, d[p + 5] = l, d[p + 6] = c, d[p + 7] = u, d[p + 8] = h, d[(p += 9) + 0] = e, d[p + 1] = -i, d[p + 2] = f, d[p + 3] = r, d[p + 4] = 1 - s, d[p + 5] = l, d[p + 6] = c, d[p + 7] = u, d[p + 8] = h, p += 9, this.index = p
                    }
                }, {
                    key: "begin",
                    value: function begin() {
                        this.index = 0
                    }
                }, {
                    key: "end",
                    value: function end() {
                        this.geometry.setDrawRange(0, this.index / 9), this.geometry.attributes.position.needsUpdate = !0, this.geometry.attributes.uv.needsUpdate = !0, this.geometry.attributes.color.needsUpdate = !0, this.interleavedBuffer.needsUpdate = !0
                    }
                }]), SpriteSet
            }(Mesh), C = {
                uniforms: {
                    tDiffuse: {
                        value: null
                    },
                    opacity: {
                        value: 1
                    }
                },
                vertexShader: "varying vec2 vUv;\nvoid main() {\n\tvUv = uv;\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
                fragmentShader: "uniform float opacity;\nuniform sampler2D tDiffuse;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texel = texture2D( tDiffuse, vUv );\n\tgl_FragColor = opacity * texel;\n}"
            }, P = function() {
                function Pass() {
                    classCallCheck_classCallCheck(this, Pass), this.enabled = !0, this.needsSwap = !0, this.clear = !1, this.renderToScreen = !1
                }
                return createClass_createClass(Pass, [{
                    key: "setSize",
                    value: function setSize() {}
                }, {
                    key: "render",
                    value: function render() {}
                }]), Pass
            }(), E = new OrthographicCamera(-1, 1, 1, -1, 0, 1), (I = new BufferGeometry).setAttribute("position", new Float32BufferAttribute([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3)), I.setAttribute("uv", new Float32BufferAttribute([0, 2, 0, 0, 2, 0], 2)), F = function() {
                function FullScreenQuad(e) {
                    classCallCheck_classCallCheck(this, FullScreenQuad), this._mesh = new Mesh(I, e)
                }
                return createClass_createClass(FullScreenQuad, [{
                    key: "dispose",
                    value: function dispose() {
                        this._mesh.geometry.dispose()
                    }
                }, {
                    key: "render",
                    value: function render(e) {
                        e.render(this._mesh, E)
                    }
                }, {
                    key: "material",
                    get: function get() {
                        return this._mesh.material
                    },
                    set: function set(e) {
                        this._mesh.material = e
                    }
                }]), FullScreenQuad
            }(), O = function(e) {
                function ShaderPass(e, n) {
                    var i;
                    return classCallCheck_classCallCheck(this, ShaderPass), (i = t.call(this)).textureID = void 0 !== n ? n : "tDiffuse", e instanceof ShaderMaterial ? (i.uniforms = e.uniforms, i.material = e) : e && (i.uniforms = ys.clone(e.uniforms), i.material = new ShaderMaterial({
                        defines: Object.assign({}, e.defines),
                        uniforms: i.uniforms,
                        vertexShader: e.vertexShader,
                        fragmentShader: e.fragmentShader
                    })), i.fsQuad = new F(i.material), i
                }
                _inherits(ShaderPass, e);
                var t = ShaderPass_createSuper(ShaderPass);
                return createClass_createClass(ShaderPass, [{
                    key: "render",
                    value: function render(e, t, n) {
                        this.uniforms[this.textureID] && (this.uniforms[this.textureID].value = n.texture), this.fsQuad.material = this.material, this.renderToScreen ? (e.setRenderTarget(null), this.fsQuad.render(e)) : (e.setRenderTarget(t), this.clear && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), this.fsQuad.render(e), e.setRenderTarget(null))
                    }
                }]), ShaderPass
            }(P), B = new Vector2, R = function() {
                function EffectComposer(e, t) {
                    var n, i;
                    classCallCheck_classCallCheck(this, EffectComposer), this.renderer = e, void 0 === t ? (n = {
                        minFilter: fi,
                        magFilter: fi,
                        format: Oi
                    }, i = e.getSize(new Vector2), this._pixelRatio = e.getPixelRatio(), this._width = i.width, this._height = i.height, (t = new WebGLRenderTarget(this._width * this._pixelRatio, this._height * this._pixelRatio, n)).texture.name = "EffectComposer.rt1") : (this._pixelRatio = 1, this._width = t.width, this._height = t.height), this.renderTarget1 = t, this.renderTarget2 = t.clone(), this.renderTarget2.texture.name = "EffectComposer.rt2", this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2, this.renderToScreen = !0, this.passes = [], this.copyPass = new O(C), this.clock = new Clock
                }
                return createClass_createClass(EffectComposer, [{
                    key: "swapBuffers",
                    value: function swapBuffers() {
                        var e = this.readBuffer;
                        this.readBuffer = this.writeBuffer, this.writeBuffer = e
                    }
                }, {
                    key: "addPass",
                    value: function addPass(e) {
                        this.passes.push(e), e.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio)
                    }
                }, {
                    key: "insertPass",
                    value: function insertPass(e, t) {
                        this.passes.splice(t, 0, e), e.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio)
                    }
                }, {
                    key: "removePass",
                    value: function removePass(e) {
                        var t = this.passes.indexOf(e); - 1 !== t && this.passes.splice(t, 1)
                    }
                }, {
                    key: "isLastEnabledPass",
                    value: function isLastEnabledPass(e) {
                        for (var t = e + 1; t < this.passes.length; t++)
                            if (this.passes[t].enabled) return !1;
                        return !0
                    }
                }, {
                    key: "render",
                    value: function render(e) {
                        var t, n, i, r;
                        for (void 0 === e && (e = this.clock.getDelta()), t = this.renderer.getRenderTarget(), n = 0, i = this.passes.length; n < i; n++) !1 !== (r = this.passes[n]).enabled && (r.renderToScreen = !1, r.render(this.renderer, this.writeBuffer, this.readBuffer, e, !1), r.needsSwap && this.swapBuffers());
                        this.renderToScreen && (this.copyPass.renderToScreen = !0, this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer)), this.renderer.setRenderTarget(t)
                    }
                }, {
                    key: "reset",
                    value: function reset(e) {
                        if (void 0 === e) {
                            var t = this.renderer.getSize(B);
                            this._pixelRatio = this.renderer.getPixelRatio(), this._width = t.width, this._height = t.height, renderTarget1.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio), renderTarget2.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio)
                        }
                        this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2
                    }
                }, {
                    key: "setSize",
                    value: function setSize(e, t) {
                        var n, i, r;
                        for (this._width = e, this._height = t, n = this._width * this._pixelRatio, i = this._height * this._pixelRatio, this.renderTarget1.setSize(n, i), this.renderTarget2.setSize(n, i), r = 0; r < this.passes.length; r++) this.passes[r].setSize(n, i)
                    }
                }, {
                    key: "setPixelRatio",
                    value: function setPixelRatio(e) {
                        this._pixelRatio = e, this.setSize(this._width, this._height)
                    }
                }]), EffectComposer
            }(), N = function(e) {
                function RenderPass(e, n, i, r, a) {
                    var o;
                    return classCallCheck_classCallCheck(this, RenderPass), (o = t.call(this)).scene = e, o.camera = n, o.overrideMaterial = i, o.clearColor = r, o.clearAlpha = r, o.clear = !1, o.clearDepth = !0, o.needsSwap = !1, o._oldClearColor = new Color, o
                }
                _inherits(RenderPass, e);
                var t = RenderPass_createSuper(RenderPass);
                return createClass_createClass(RenderPass, [{
                    key: "render",
                    value: function render(e, t, n) {
                        var i, r, a = e.autoClear;
                        e.autoClear = !1, void 0 !== this.overrideMaterial && (r = this.scene.overrideMaterial, this.scene.overrideMaterial = this.overrideMaterial), e.setRenderTarget(this.renderToScreen ? null : n), this.clearColor && (e.getClearColor(this._oldClearColor), i = e.getClearAlpha(), e.setClearColor(this.clearColor, this.clearAlpha)), this.clearDepth && e.clearDepth(), this.clear && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), e.render(this.scene, this.camera), e.setRenderTarget(null), this.clearColor && e.setClearColor(this._oldClearColor, i), void 0 !== this.overrideMaterial && (this.scene.overrideMaterial = r), e.autoClear = a
                    }
                }]), RenderPass
            }(P), D = {
                shaderID: "luminosityHighPass",
                uniforms: {
                    tDiffuse: {
                        value: null
                    },
                    luminosityThreshold: {
                        value: 1
                    },
                    smoothWidth: {
                        value: 1
                    },
                    defaultColor: {
                        value: new Color(0)
                    },
                    defaultOpacity: {
                        value: 0
                    }
                },
                vertexShader: "varying vec2 vUv;\nvoid main() {\n\tvUv = uv;\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
                fragmentShader: "uniform sampler2D tDiffuse;\nuniform vec3 defaultColor;\nuniform float defaultOpacity;\nuniform float luminosityThreshold;\nuniform float smoothWidth;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texel = texture2D( tDiffuse, vUv );\n\tvec3 luma = vec3( 0.299, 0.587, 0.114 );\n\tfloat v = dot( texel.xyz, luma );\n\tvec4 outputColor = vec4( defaultColor.rgb, defaultOpacity );\n\tfloat alpha = smoothstep( luminosityThreshold, luminosityThreshold + smoothWidth, v );\n\tgl_FragColor = mix( outputColor, texel, alpha );\n}"
            }, V = "uniform float opacity;\nuniform sampler2D tDiffuse;\nuniform sampler2D tBloom;\nvarying vec2 vUv;\nuniform float invToneFactor;\nvoid main() {\n\tvec4 texel = texture2D( tDiffuse, vUv );\n\tvec4 bloom = texture2D( tBloom, vUv );\n\tgl_FragColor = texel*invToneFactor + opacity * bloom;\n}", (U = function(e) {
                function UnrealBloomPass(e, n, i, r) {
                    var a, o, s, l, c, u, h, d, p, f, m, g;
                    for (classCallCheck_classCallCheck(this, UnrealBloomPass), (a = t.call(this)).strength = void 0 !== n ? n : 1, a.radius = i, a.threshold = r, a.resolution = void 0 !== e ? new Vector2(e.x, e.y) : new Vector2(256, 256), a.clearColor = new Color(0, 0, 0), o = {
                            minFilter: fi,
                            magFilter: fi,
                            format: Oi
                        }, a.renderTargetsHorizontal = [], a.renderTargetsVertical = [], a.nMips = 5, s = Math.round(a.resolution.x / 2), l = Math.round(a.resolution.y / 2), a.renderTargetBright = new WebGLRenderTarget(s, l, o), a.renderTargetBright.texture.name = "UnrealBloomPass.bright", a.renderTargetBright.texture.generateMipmaps = !1, c = 0; c < a.nMips; c++)(u = new WebGLRenderTarget(s, l, o)).texture.name = "UnrealBloomPass.h" + c, u.texture.generateMipmaps = !1, a.renderTargetsHorizontal.push(u), (h = new WebGLRenderTarget(s, l, o)).texture.name = "UnrealBloomPass.v" + c, h.texture.generateMipmaps = !1, a.renderTargetsVertical.push(h), s = Math.round(s / 2), l = Math.round(l / 2);
                    for (d = D, a.highPassUniforms = ys.clone(d.uniforms), a.highPassUniforms.luminosityThreshold.value = r, a.highPassUniforms.smoothWidth.value = .01, a.materialHighPassFilter = new ShaderMaterial({
                            uniforms: a.highPassUniforms,
                            vertexShader: d.vertexShader,
                            fragmentShader: d.fragmentShader,
                            defines: {}
                        }), a.separableBlurMaterials = [], p = [3, 5, 7, 9, 11], s = Math.round(a.resolution.x / 2), l = Math.round(a.resolution.y / 2), f = 0; f < a.nMips; f++) a.separableBlurMaterials.push(a.getSeperableBlurMaterial(p[f])), a.separableBlurMaterials[f].uniforms.texSize.value = new Vector2(s, l), s = Math.round(s / 2), l = Math.round(l / 2);
                    return a.compositeMaterial = a.getCompositeMaterial(a.nMips), a.compositeMaterial.uniforms.blurTexture1.value = a.renderTargetsVertical[0].texture, a.compositeMaterial.uniforms.blurTexture2.value = a.renderTargetsVertical[1].texture, a.compositeMaterial.uniforms.blurTexture3.value = a.renderTargetsVertical[2].texture, a.compositeMaterial.uniforms.blurTexture4.value = a.renderTargetsVertical[3].texture, a.compositeMaterial.uniforms.blurTexture5.value = a.renderTargetsVertical[4].texture, a.compositeMaterial.uniforms.bloomStrength.value = n, a.compositeMaterial.uniforms.bloomRadius.value = .1, a.compositeMaterial.needsUpdate = !0, m = [1, .8, .6, .4, .2], a.compositeMaterial.uniforms.bloomFactors.value = m, a.bloomTintColors = [new Vector3(1, 1, 1), new Vector3(1, 1, 1), new Vector3(1, 1, 1), new Vector3(1, 1, 1), new Vector3(1, 1, 1)], a.compositeMaterial.uniforms.bloomTintColors.value = a.bloomTintColors, g = C, a.copyUniforms = ys.merge([{
                        tDiffuse: {
                            value: null
                        },
                        tBloom: {
                            value: null
                        },
                        opacity: {
                            value: 1
                        }
                    }, Ss.tone]), a.copyUniforms.opacity.value = 1, a.materialCopy = new ShaderMaterial({
                        uniforms: a.copyUniforms,
                        vertexShader: g.vertexShader,
                        fragmentShader: V,
                        depthTest: !1,
                        depthWrite: !1,
                        transparent: !1
                    }), a.enabled = !0, a.needsSwap = !0, a._oldClearColor = new Color, a.oldClearAlpha = 1, a.basic = new MeshBasicMaterial, a.fsQuad = new F(null), a
                }
                _inherits(UnrealBloomPass, e);
                var t = UnrealBloomPass_createSuper(UnrealBloomPass);
                return createClass_createClass(UnrealBloomPass, [{
                    key: "dispose",
                    value: function dispose() {
                        var e, t;
                        for (e = 0; e < this.renderTargetsHorizontal.length; e++) this.renderTargetsHorizontal[e].dispose();
                        for (t = 0; t < this.renderTargetsVertical.length; t++) this.renderTargetsVertical[t].dispose();
                        this.renderTargetBright.dispose()
                    }
                }, {
                    key: "setSize",
                    value: function setSize(e, t) {
                        var n, i = Math.round(e / 2),
                            r = Math.round(t / 2);
                        for (this.renderTargetBright.setSize(i, r), n = 0; n < this.nMips; n++) this.renderTargetsHorizontal[n].setSize(i, r), this.renderTargetsVertical[n].setSize(i, r), this.separableBlurMaterials[n].uniforms.texSize.value = new Vector2(i, r), i = Math.round(i / 2), r = Math.round(r / 2)
                    }
                }, {
                    key: "render",
                    value: function render(e, t, n, i) {
                        var r, a, o;
                        for (e.getClearColor(this._oldClearColor), this.oldClearAlpha = e.getClearAlpha(), r = e.autoClear, e.autoClear = !1, e.setClearColor(this.clearColor, 0), this.renderToScreen && (this.fsQuad.material = this.basic, this.basic.map = n.texture, e.setRenderTarget(null), e.clear(), this.fsQuad.render(e)), this.highPassUniforms.tDiffuse.value = n.texture, this.highPassUniforms.luminosityThreshold.value = this.threshold, this.fsQuad.material = this.materialHighPassFilter, e.setRenderTarget(this.renderTargetBright), e.clear(), this.fsQuad.render(e), e.setRenderTarget(null), a = this.renderTargetBright, o = 0; o < this.nMips; o++) this.fsQuad.material = this.separableBlurMaterials[o], this.separableBlurMaterials[o].uniforms.colorTexture.value = a.texture, this.separableBlurMaterials[o].uniforms.direction.value = UnrealBloomPass.BlurDirectionX, e.setRenderTarget(this.renderTargetsHorizontal[o]), e.clear(), this.fsQuad.render(e), e.setRenderTarget(null), this.separableBlurMaterials[o].uniforms.colorTexture.value = this.renderTargetsHorizontal[o].texture, this.separableBlurMaterials[o].uniforms.direction.value = UnrealBloomPass.BlurDirectionY, e.setRenderTarget(this.renderTargetsVertical[o]), e.clear(), this.fsQuad.render(e), e.setRenderTarget(null), a = this.renderTargetsVertical[o];
                        this.fsQuad.material = this.compositeMaterial, this.compositeMaterial.uniforms.bloomStrength.value = this.strength, this.compositeMaterial.uniforms.bloomRadius.value = this.radius, this.compositeMaterial.uniforms.bloomTintColors.value = this.bloomTintColors, e.setRenderTarget(this.renderTargetsHorizontal[0]), e.clear(), this.fsQuad.render(e), e.setRenderTarget(null), this.fsQuad.material = this.materialCopy, this.copyUniforms.tDiffuse.value = n.texture, this.copyUniforms.tBloom.value = this.renderTargetsHorizontal[0].texture, this.renderToScreen ? (e.setRenderTarget(null), this.fsQuad.render(e)) : (e.setRenderTarget(t), this.fsQuad.render(e), e.setRenderTarget(null)), e.setClearColor(this._oldClearColor, this.oldClearAlpha), e.autoClear = r
                    }
                }, {
                    key: "getSeperableBlurMaterial",
                    value: function getSeperableBlurMaterial(e) {
                        return new ShaderMaterial({
                            defines: {
                                KERNEL_RADIUS: e,
                                SIGMA: e
                            },
                            uniforms: {
                                colorTexture: {
                                    value: null
                                },
                                texSize: {
                                    value: new Vector2(.5, .5)
                                },
                                direction: {
                                    value: new Vector2(.5, .5)
                                }
                            },
                            vertexShader: "varying vec2 vUv;\n\t\t\tvoid main() {\n\t\t\t\tvUv = uv;\n\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t}",
                            fragmentShader: "#include <common>\n\t\t\tvarying vec2 vUv;\n\t\t\tuniform sampler2D colorTexture;\n\t\t\tuniform vec2 texSize;\n\t\t\tuniform vec2 direction;\n\t\t\tfloat gaussianPdf(in float x, in float sigma) {\n\t\t\t\treturn 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\n\t\t\t}\n\t\t\tvoid main() {\n\t\t\t\tvec2 invSize = 1.0 / texSize;\n\t\t\t\tfloat fSigma = float(SIGMA);\n\t\t\t\tfloat weightSum = gaussianPdf(0.0, fSigma);\n\t\t\t\tvec4 diffuseSum = texture2D( colorTexture, vUv) * weightSum;\n\t\t\t\tfor( int i = 1; i < KERNEL_RADIUS; i ++ ) {\n\t\t\t\t\tfloat x = float(i);\n\t\t\t\t\tfloat w = gaussianPdf(x, fSigma);\n\t\t\t\t\tvec2 uvOffset = direction * invSize * x;\n\t\t\t\t\tvec4 sample1 = texture2D( colorTexture, vUv + uvOffset);\n\t\t\t\t\tvec4 sample2 = texture2D( colorTexture, vUv - uvOffset);\n\t\t\t\t\tdiffuseSum += (sample1 + sample2) * w;\n\t\t\t\t\tweightSum += 2.0 * w;\n\t\t\t\t}\n\t\t\t\tgl_FragColor = vec4(diffuseSum/weightSum);\n\t\t\t}"
                        })
                    }
                }, {
                    key: "getCompositeMaterial",
                    value: function getCompositeMaterial(e) {
                        return new ShaderMaterial({
                            defines: {
                                NUM_MIPS: e
                            },
                            uniforms: {
                                blurTexture1: {
                                    value: null
                                },
                                blurTexture2: {
                                    value: null
                                },
                                blurTexture3: {
                                    value: null
                                },
                                blurTexture4: {
                                    value: null
                                },
                                blurTexture5: {
                                    value: null
                                },
                                dirtTexture: {
                                    value: null
                                },
                                bloomStrength: {
                                    value: 1
                                },
                                bloomFactors: {
                                    value: null
                                },
                                bloomTintColors: {
                                    value: null
                                },
                                bloomRadius: {
                                    value: 0
                                }
                            },
                            vertexShader: "varying vec2 vUv;\n\t\t\tvoid main() {\n\t\t\t\tvUv = uv;\n\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t}",
                            fragmentShader: "varying vec2 vUv;\n\t\t\tuniform sampler2D blurTexture1;\n\t\t\tuniform sampler2D blurTexture2;\n\t\t\tuniform sampler2D blurTexture3;\n\t\t\tuniform sampler2D blurTexture4;\n\t\t\tuniform sampler2D blurTexture5;\n\t\t\tuniform sampler2D dirtTexture;\n\t\t\tuniform float bloomStrength;\n\t\t\tuniform float bloomRadius;\n\t\t\tuniform float bloomFactors[NUM_MIPS];\n\t\t\tuniform vec3 bloomTintColors[NUM_MIPS];\n\t\t\tfloat lerpBloomFactor(const in float factor) {\n\t\t\t\tfloat mirrorFactor = 1.2 - factor;\n\t\t\t\treturn mix(factor, mirrorFactor, bloomRadius);\n\t\t\t}\n\t\t\tvoid main() {\n\t\t\t\tgl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) +\n\t\t\t\t\tlerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) +\n\t\t\t\t\tlerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) +\n\t\t\t\t\tlerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) +\n\t\t\t\t\tlerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );\n\t\t\t}"
                        })
                    }
                }]), UnrealBloomPass
            }(P)).BlurDirectionX = new Vector2(1, 0), U.BlurDirectionY = new Vector2(0, 1), z = {
                uniforms: {
                    tDiffuse: {
                        value: null
                    },
                    resolution: {
                        value: new Vector2(1 / 1024, 1 / 512)
                    }
                },
                vertexShader: "varying vec2 vUv;\nvoid main() {\nvUv = uv;\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
                fragmentShader: 'precision highp float;\n\nuniform sampler2D tDiffuse;\n\nuniform vec2 resolution;\n\nvarying vec2 vUv;\n\n// FXAA 3.11 implementation by NVIDIA, ported to WebGL by Agost Biro (biro@archilogic.com)\n\n//----------------------------------------------------------------------------------\n// File:        es3-keplerFXAAassetsshaders/FXAA_DefaultES.frag\n// SDK Version: v3.00\n// Email:       gameworks@nvidia.com\n// Site:        http://developer.nvidia.com/\n//\n// Copyright (c) 2014-2015, NVIDIA CORPORATION. All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions\n// are met:\n//  * Redistributions of source code must retain the above copyright\n//    notice, this list of conditions and the following disclaimer.\n//  * Redistributions in binary form must reproduce the above copyright\n//    notice, this list of conditions and the following disclaimer in the\n//    documentation and/or other materials provided with the distribution.\n//  * Neither the name of NVIDIA CORPORATION nor the names of its\n//    contributors may be used to endorse or promote products derived\n//    from this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ``AS IS\'\' AND ANY\n// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n// PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n//----------------------------------------------------------------------------------\n\n#define FXAA_PC 1\n#define FXAA_GLSL_100 1\n#define FXAA_QUALITY_PRESET 12\n\n#define FXAA_GREEN_AS_LUMA 1\n\n/*--------------------------------------------------------------------------*/\n#ifndef FXAA_PC_CONSOLE\n    //\n    // The console algorithm for PC is included\n    // for developers targeting really low spec machines.\n    // Likely better to just run FXAA_PC, and use a really low preset.\n    //\n    #define FXAA_PC_CONSOLE 0\n#endif\n/*--------------------------------------------------------------------------*/\n#ifndef FXAA_GLSL_120\n    #define FXAA_GLSL_120 0\n#endif\n/*--------------------------------------------------------------------------*/\n#ifndef FXAA_GLSL_130\n    #define FXAA_GLSL_130 0\n#endif\n/*--------------------------------------------------------------------------*/\n#ifndef FXAA_HLSL_3\n    #define FXAA_HLSL_3 0\n#endif\n/*--------------------------------------------------------------------------*/\n#ifndef FXAA_HLSL_4\n    #define FXAA_HLSL_4 0\n#endif\n/*--------------------------------------------------------------------------*/\n#ifndef FXAA_HLSL_5\n    #define FXAA_HLSL_5 0\n#endif\n/*==========================================================================*/\n#ifndef FXAA_GREEN_AS_LUMA\n    //\n    // For those using non-linear color,\n    // and either not able to get luma in alpha, or not wanting to,\n    // this enables FXAA to run using green as a proxy for luma.\n    // So with this enabled, no need to pack luma in alpha.\n    //\n    // This will turn off AA on anything which lacks some amount of green.\n    // Pure red and blue or combination of only R and B, will get no AA.\n    //\n    // Might want to lower the settings for both,\n    //    fxaaConsoleEdgeThresholdMin\n    //    fxaaQualityEdgeThresholdMin\n    // In order to insure AA does not get turned off on colors\n    // which contain a minor amount of green.\n    //\n    // 1 = On.\n    // 0 = Off.\n    //\n    #define FXAA_GREEN_AS_LUMA 0\n#endif\n/*--------------------------------------------------------------------------*/\n#ifndef FXAA_EARLY_EXIT\n    //\n    // Controls algorithm\'s early exit path.\n    // On PS3 turning this ON adds 2 cycles to the shader.\n    // On 360 turning this OFF adds 10ths of a millisecond to the shader.\n    // Turning this off on console will result in a more blurry image.\n    // So this defaults to on.\n    //\n    // 1 = On.\n    // 0 = Off.\n    //\n    #define FXAA_EARLY_EXIT 1\n#endif\n/*--------------------------------------------------------------------------*/\n#ifndef FXAA_DISCARD\n    //\n    // Only valid for PC OpenGL currently.\n    // Probably will not work when FXAA_GREEN_AS_LUMA = 1.\n    //\n    // 1 = Use discard on pixels which don\'t need AA.\n    //     For APIs which enable concurrent TEX+ROP from same surface.\n    // 0 = Return unchanged color on pixels which don\'t need AA.\n    //\n    #define FXAA_DISCARD 0\n#endif\n/*--------------------------------------------------------------------------*/\n#ifndef FXAA_FAST_PIXEL_OFFSET\n    //\n    // Used for GLSL 120 only.\n    //\n    // 1 = GL API supports fast pixel offsets\n    // 0 = do not use fast pixel offsets\n    //\n    #ifdef GL_EXT_gpu_shader4\n        #define FXAA_FAST_PIXEL_OFFSET 1\n    #endif\n    #ifdef GL_NV_gpu_shader5\n        #define FXAA_FAST_PIXEL_OFFSET 1\n    #endif\n    #ifdef GL_ARB_gpu_shader5\n        #define FXAA_FAST_PIXEL_OFFSET 1\n    #endif\n    #ifndef FXAA_FAST_PIXEL_OFFSET\n        #define FXAA_FAST_PIXEL_OFFSET 0\n    #endif\n#endif\n/*--------------------------------------------------------------------------*/\n#ifndef FXAA_GATHER4_ALPHA\n    //\n    // 1 = API supports gather4 on alpha channel.\n    // 0 = API does not support gather4 on alpha channel.\n    //\n    #if (FXAA_HLSL_5 == 1)\n        #define FXAA_GATHER4_ALPHA 1\n    #endif\n    #ifdef GL_ARB_gpu_shader5\n        #define FXAA_GATHER4_ALPHA 1\n    #endif\n    #ifdef GL_NV_gpu_shader5\n        #define FXAA_GATHER4_ALPHA 1\n    #endif\n    #ifndef FXAA_GATHER4_ALPHA\n        #define FXAA_GATHER4_ALPHA 0\n    #endif\n#endif\n\n\n/*============================================================================\n                        FXAA QUALITY - TUNING KNOBS\n------------------------------------------------------------------------------\nNOTE the other tuning knobs are now in the shader function inputs!\n============================================================================*/\n#ifndef FXAA_QUALITY_PRESET\n    //\n    // Choose the quality preset.\n    // This needs to be compiled into the shader as it effects code.\n    // Best option to include multiple presets is to\n    // in each shader define the preset, then include this file.\n    //\n    // OPTIONS\n    // -----------------------------------------------------------------------\n    // 10 to 15 - default medium dither (10=fastest, 15=highest quality)\n    // 20 to 29 - less dither, more expensive (20=fastest, 29=highest quality)\n    // 39       - no dither, very expensive\n    //\n    // NOTES\n    // -----------------------------------------------------------------------\n    // 12 = slightly faster then FXAA 3.9 and higher edge quality (default)\n    // 13 = about same speed as FXAA 3.9 and better than 12\n    // 23 = closest to FXAA 3.9 visually and performance wise\n    //  _ = the lowest digit is directly related to performance\n    // _  = the highest digit is directly related to style\n    //\n    #define FXAA_QUALITY_PRESET 12\n#endif\n\n\n/*============================================================================\n\n                           FXAA QUALITY - PRESETS\n\n============================================================================*/\n\n/*============================================================================\n                     FXAA QUALITY - MEDIUM DITHER PRESETS\n============================================================================*/\n#if (FXAA_QUALITY_PRESET == 10)\n    #define FXAA_QUALITY_PS 3\n    #define FXAA_QUALITY_P0 1.5\n    #define FXAA_QUALITY_P1 3.0\n    #define FXAA_QUALITY_P2 12.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY_PRESET == 11)\n    #define FXAA_QUALITY_PS 4\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 3.0\n    #define FXAA_QUALITY_P3 12.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY_PRESET == 12)\n    #define FXAA_QUALITY_PS 5\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 4.0\n    #define FXAA_QUALITY_P4 12.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY_PRESET == 13)\n    #define FXAA_QUALITY_PS 6\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 4.0\n    #define FXAA_QUALITY_P5 12.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY_PRESET == 14)\n    #define FXAA_QUALITY_PS 7\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 4.0\n    #define FXAA_QUALITY_P6 12.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY_PRESET == 15)\n    #define FXAA_QUALITY_PS 8\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 2.0\n    #define FXAA_QUALITY_P6 4.0\n    #define FXAA_QUALITY_P7 12.0\n#endif\n\n/*============================================================================\n                     FXAA QUALITY - LOW DITHER PRESETS\n============================================================================*/\n#if (FXAA_QUALITY_PRESET == 20)\n    #define FXAA_QUALITY_PS 3\n    #define FXAA_QUALITY_P0 1.5\n    #define FXAA_QUALITY_P1 2.0\n    #define FXAA_QUALITY_P2 8.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY_PRESET == 21)\n    #define FXAA_QUALITY_PS 4\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 8.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY_PRESET == 22)\n    #define FXAA_QUALITY_PS 5\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 8.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY_PRESET == 23)\n    #define FXAA_QUALITY_PS 6\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 8.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY_PRESET == 24)\n    #define FXAA_QUALITY_PS 7\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 3.0\n    #define FXAA_QUALITY_P6 8.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY_PRESET == 25)\n    #define FXAA_QUALITY_PS 8\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 2.0\n    #define FXAA_QUALITY_P6 4.0\n    #define FXAA_QUALITY_P7 8.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY_PRESET == 26)\n    #define FXAA_QUALITY_PS 9\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 2.0\n    #define FXAA_QUALITY_P6 2.0\n    #define FXAA_QUALITY_P7 4.0\n    #define FXAA_QUALITY_P8 8.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY_PRESET == 27)\n    #define FXAA_QUALITY_PS 10\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 2.0\n    #define FXAA_QUALITY_P6 2.0\n    #define FXAA_QUALITY_P7 2.0\n    #define FXAA_QUALITY_P8 4.0\n    #define FXAA_QUALITY_P9 8.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY_PRESET == 28)\n    #define FXAA_QUALITY_PS 11\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 2.0\n    #define FXAA_QUALITY_P6 2.0\n    #define FXAA_QUALITY_P7 2.0\n    #define FXAA_QUALITY_P8 2.0\n    #define FXAA_QUALITY_P9 4.0\n    #define FXAA_QUALITY_P10 8.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY_PRESET == 29)\n    #define FXAA_QUALITY_PS 12\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 2.0\n    #define FXAA_QUALITY_P6 2.0\n    #define FXAA_QUALITY_P7 2.0\n    #define FXAA_QUALITY_P8 2.0\n    #define FXAA_QUALITY_P9 2.0\n    #define FXAA_QUALITY_P10 4.0\n    #define FXAA_QUALITY_P11 8.0\n#endif\n\n/*============================================================================\n                     FXAA QUALITY - EXTREME QUALITY\n============================================================================*/\n#if (FXAA_QUALITY_PRESET == 39)\n    #define FXAA_QUALITY_PS 12\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.0\n    #define FXAA_QUALITY_P2 1.0\n    #define FXAA_QUALITY_P3 1.0\n    #define FXAA_QUALITY_P4 1.0\n    #define FXAA_QUALITY_P5 1.5\n    #define FXAA_QUALITY_P6 2.0\n    #define FXAA_QUALITY_P7 2.0\n    #define FXAA_QUALITY_P8 2.0\n    #define FXAA_QUALITY_P9 2.0\n    #define FXAA_QUALITY_P10 4.0\n    #define FXAA_QUALITY_P11 8.0\n#endif\n\n\n\n/*============================================================================\n\n                                API PORTING\n\n============================================================================*/\n#if (FXAA_GLSL_100 == 1) || (FXAA_GLSL_120 == 1) || (FXAA_GLSL_130 == 1)\n    #define FxaaBool bool\n    #define FxaaDiscard discard\n    #define FxaaFloat float\n    #define FxaaFloat2 vec2\n    #define FxaaFloat3 vec3\n    #define FxaaFloat4 vec4\n    #define FxaaHalf float\n    #define FxaaHalf2 vec2\n    #define FxaaHalf3 vec3\n    #define FxaaHalf4 vec4\n    #define FxaaInt2 ivec2\n    #define FxaaSat(x) clamp(x, 0.0, 1.0)\n    #define FxaaTex sampler2D\n#else\n    #define FxaaBool bool\n    #define FxaaDiscard clip(-1)\n    #define FxaaFloat float\n    #define FxaaFloat2 float2\n    #define FxaaFloat3 float3\n    #define FxaaFloat4 float4\n    #define FxaaHalf half\n    #define FxaaHalf2 half2\n    #define FxaaHalf3 half3\n    #define FxaaHalf4 half4\n    #define FxaaSat(x) saturate(x)\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_GLSL_100 == 1)\n  #define FxaaTexTop(t, p) texture2D(t, p, 0.0)\n  #define FxaaTexOff(t, p, o, r) texture2D(t, p + (o * r), 0.0)\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_GLSL_120 == 1)\n    // Requires,\n    //  #version 120\n    // And at least,\n    //  #extension GL_EXT_gpu_shader4 : enable\n    //  (or set FXAA_FAST_PIXEL_OFFSET 1 to work like DX9)\n    #define FxaaTexTop(t, p) texture2DLod(t, p, 0.0)\n    #if (FXAA_FAST_PIXEL_OFFSET == 1)\n        #define FxaaTexOff(t, p, o, r) texture2DLodOffset(t, p, 0.0, o)\n    #else\n        #define FxaaTexOff(t, p, o, r) texture2DLod(t, p + (o * r), 0.0)\n    #endif\n    #if (FXAA_GATHER4_ALPHA == 1)\n        // use #extension GL_ARB_gpu_shader5 : enable\n        #define FxaaTexAlpha4(t, p) textureGather(t, p, 3)\n        #define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)\n        #define FxaaTexGreen4(t, p) textureGather(t, p, 1)\n        #define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)\n    #endif\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_GLSL_130 == 1)\n    // Requires "#version 130" or better\n    #define FxaaTexTop(t, p) textureLod(t, p, 0.0)\n    #define FxaaTexOff(t, p, o, r) textureLodOffset(t, p, 0.0, o)\n    #if (FXAA_GATHER4_ALPHA == 1)\n        // use #extension GL_ARB_gpu_shader5 : enable\n        #define FxaaTexAlpha4(t, p) textureGather(t, p, 3)\n        #define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)\n        #define FxaaTexGreen4(t, p) textureGather(t, p, 1)\n        #define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)\n    #endif\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_HLSL_3 == 1)\n    #define FxaaInt2 float2\n    #define FxaaTex sampler2D\n    #define FxaaTexTop(t, p) tex2Dlod(t, float4(p, 0.0, 0.0))\n    #define FxaaTexOff(t, p, o, r) tex2Dlod(t, float4(p + (o * r), 0, 0))\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_HLSL_4 == 1)\n    #define FxaaInt2 int2\n    struct FxaaTex { SamplerState smpl; Texture2D tex; };\n    #define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)\n    #define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_HLSL_5 == 1)\n    #define FxaaInt2 int2\n    struct FxaaTex { SamplerState smpl; Texture2D tex; };\n    #define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)\n    #define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)\n    #define FxaaTexAlpha4(t, p) t.tex.GatherAlpha(t.smpl, p)\n    #define FxaaTexOffAlpha4(t, p, o) t.tex.GatherAlpha(t.smpl, p, o)\n    #define FxaaTexGreen4(t, p) t.tex.GatherGreen(t.smpl, p)\n    #define FxaaTexOffGreen4(t, p, o) t.tex.GatherGreen(t.smpl, p, o)\n#endif\n\n\n/*============================================================================\n                   GREEN AS LUMA OPTION SUPPORT FUNCTION\n============================================================================*/\n#if (FXAA_GREEN_AS_LUMA == 0)\n    FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.w; }\n#else\n    FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.y; }\n#endif\n\n\n\n\n/*============================================================================\n\n                             FXAA3 QUALITY - PC\n\n============================================================================*/\n#if (FXAA_PC == 1)\n/*--------------------------------------------------------------------------*/\nFxaaFloat4 FxaaPixelShader(\n    //\n    // Use noperspective interpolation here (turn off perspective interpolation).\n    // {xy} = center of pixel\n    FxaaFloat2 pos,\n    //\n    // Used only for FXAA Console, and not used on the 360 version.\n    // Use noperspective interpolation here (turn off perspective interpolation).\n    // {xy_} = upper left of pixel\n    // {_zw} = lower right of pixel\n    FxaaFloat4 fxaaConsolePosPos,\n    //\n    // Input color texture.\n    // {rgb_} = color in linear or perceptual color space\n    // if (FXAA_GREEN_AS_LUMA == 0)\n    //     {__a} = luma in perceptual color space (not linear)\n    FxaaTex tex,\n    //\n    // Only used on the optimized 360 version of FXAA Console.\n    // For everything but 360, just use the same input here as for "tex".\n    // For 360, same texture, just alias with a 2nd sampler.\n    // This sampler needs to have an exponent bias of -1.\n    FxaaTex fxaaConsole360TexExpBiasNegOne,\n    //\n    // Only used on the optimized 360 version of FXAA Console.\n    // For everything but 360, just use the same input here as for "tex".\n    // For 360, same texture, just alias with a 3nd sampler.\n    // This sampler needs to have an exponent bias of -2.\n    FxaaTex fxaaConsole360TexExpBiasNegTwo,\n    //\n    // Only used on FXAA Quality.\n    // This must be from a constant/uniform.\n    // {x_} = 1.0/screenWidthInPixels\n    // {_y} = 1.0/screenHeightInPixels\n    FxaaFloat2 fxaaQualityRcpFrame,\n    //\n    // Only used on FXAA Console.\n    // This must be from a constant/uniform.\n    // This effects sub-pixel AA quality and inversely sharpness.\n    //   Where N ranges between,\n    //     N = 0.50 (default)\n    //     N = 0.33 (sharper)\n    // {x__} = -N/screenWidthInPixels\n    // {_y_} = -N/screenHeightInPixels\n    // {_z_} =  N/screenWidthInPixels\n    // {__w} =  N/screenHeightInPixels\n    FxaaFloat4 fxaaConsoleRcpFrameOpt,\n    //\n    // Only used on FXAA Console.\n    // Not used on 360, but used on PS3 and PC.\n    // This must be from a constant/uniform.\n    // {x__} = -2.0/screenWidthInPixels\n    // {_y_} = -2.0/screenHeightInPixels\n    // {_z_} =  2.0/screenWidthInPixels\n    // {__w} =  2.0/screenHeightInPixels\n    FxaaFloat4 fxaaConsoleRcpFrameOpt2,\n    //\n    // Only used on FXAA Console.\n    // Only used on 360 in place of fxaaConsoleRcpFrameOpt2.\n    // This must be from a constant/uniform.\n    // {x__} =  8.0/screenWidthInPixels\n    // {_y_} =  8.0/screenHeightInPixels\n    // {_z_} = -4.0/screenWidthInPixels\n    // {__w} = -4.0/screenHeightInPixels\n    FxaaFloat4 fxaaConsole360RcpFrameOpt2,\n    //\n    // Only used on FXAA Quality.\n    // This used to be the FXAA_QUALITY_SUBPIX define.\n    // It is here now to allow easier tuning.\n    // Choose the amount of sub-pixel aliasing removal.\n    // This can effect sharpness.\n    //   1.00 - upper limit (softer)\n    //   0.75 - default amount of filtering\n    //   0.50 - lower limit (sharper, less sub-pixel aliasing removal)\n    //   0.25 - almost off\n    //   0.00 - completely off\n    FxaaFloat fxaaQualitySubpix,\n    //\n    // Only used on FXAA Quality.\n    // This used to be the FXAA_QUALITY_EDGE_THRESHOLD define.\n    // It is here now to allow easier tuning.\n    // The minimum amount of local contrast required to apply algorithm.\n    //   0.333 - too little (faster)\n    //   0.250 - low quality\n    //   0.166 - default\n    //   0.125 - high quality\n    //   0.063 - overkill (slower)\n    FxaaFloat fxaaQualityEdgeThreshold,\n    //\n    // Only used on FXAA Quality.\n    // This used to be the FXAA_QUALITY_EDGE_THRESHOLD_MIN define.\n    // It is here now to allow easier tuning.\n    // Trims the algorithm from processing darks.\n    //   0.0833 - upper limit (default, the start of visible unfiltered edges)\n    //   0.0625 - high quality (faster)\n    //   0.0312 - visible limit (slower)\n    // Special notes when using FXAA_GREEN_AS_LUMA,\n    //   Likely want to set this to zero.\n    //   As colors that are mostly not-green\n    //   will appear very dark in the green channel!\n    //   Tune by looking at mostly non-green content,\n    //   then start at zero and increase until aliasing is a problem.\n    FxaaFloat fxaaQualityEdgeThresholdMin,\n    //\n    // Only used on FXAA Console.\n    // This used to be the FXAA_CONSOLE_EDGE_SHARPNESS define.\n    // It is here now to allow easier tuning.\n    // This does not effect PS3, as this needs to be compiled in.\n    //   Use FXAA_CONSOLE_PS3_EDGE_SHARPNESS for PS3.\n    //   Due to the PS3 being ALU bound,\n    //   there are only three safe values here: 2 and 4 and 8.\n    //   These options use the shaders ability to a free *|/ by 2|4|8.\n    // For all other platforms can be a non-power of two.\n    //   8.0 is sharper (default!!!)\n    //   4.0 is softer\n    //   2.0 is really soft (good only for vector graphics inputs)\n    FxaaFloat fxaaConsoleEdgeSharpness,\n    //\n    // Only used on FXAA Console.\n    // This used to be the FXAA_CONSOLE_EDGE_THRESHOLD define.\n    // It is here now to allow easier tuning.\n    // This does not effect PS3, as this needs to be compiled in.\n    //   Use FXAA_CONSOLE_PS3_EDGE_THRESHOLD for PS3.\n    //   Due to the PS3 being ALU bound,\n    //   there are only two safe values here: 1/4 and 1/8.\n    //   These options use the shaders ability to a free *|/ by 2|4|8.\n    // The console setting has a different mapping than the quality setting.\n    // Other platforms can use other values.\n    //   0.125 leaves less aliasing, but is softer (default!!!)\n    //   0.25 leaves more aliasing, and is sharper\n    FxaaFloat fxaaConsoleEdgeThreshold,\n    //\n    // Only used on FXAA Console.\n    // This used to be the FXAA_CONSOLE_EDGE_THRESHOLD_MIN define.\n    // It is here now to allow easier tuning.\n    // Trims the algorithm from processing darks.\n    // The console setting has a different mapping than the quality setting.\n    // This only applies when FXAA_EARLY_EXIT is 1.\n    // This does not apply to PS3,\n    // PS3 was simplified to avoid more shader instructions.\n    //   0.06 - faster but more aliasing in darks\n    //   0.05 - default\n    //   0.04 - slower and less aliasing in darks\n    // Special notes when using FXAA_GREEN_AS_LUMA,\n    //   Likely want to set this to zero.\n    //   As colors that are mostly not-green\n    //   will appear very dark in the green channel!\n    //   Tune by looking at mostly non-green content,\n    //   then start at zero and increase until aliasing is a problem.\n    FxaaFloat fxaaConsoleEdgeThresholdMin,\n    //\n    // Extra constants for 360 FXAA Console only.\n    // Use zeros or anything else for other platforms.\n    // These must be in physical constant registers and NOT immedates.\n    // Immedates will result in compiler un-optimizing.\n    // {xyzw} = float4(1.0, -1.0, 0.25, -0.25)\n    FxaaFloat4 fxaaConsole360ConstDir\n) {\n/*--------------------------------------------------------------------------*/\n    FxaaFloat2 posM;\n    posM.x = pos.x;\n    posM.y = pos.y;\n    #if (FXAA_GATHER4_ALPHA == 1)\n        #if (FXAA_DISCARD == 0)\n            FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);\n            #if (FXAA_GREEN_AS_LUMA == 0)\n                #define lumaM rgbyM.w\n            #else\n                #define lumaM rgbyM.y\n            #endif\n        #endif\n        #if (FXAA_GREEN_AS_LUMA == 0)\n            FxaaFloat4 luma4A = FxaaTexAlpha4(tex, posM);\n            FxaaFloat4 luma4B = FxaaTexOffAlpha4(tex, posM, FxaaInt2(-1, -1));\n        #else\n            FxaaFloat4 luma4A = FxaaTexGreen4(tex, posM);\n            FxaaFloat4 luma4B = FxaaTexOffGreen4(tex, posM, FxaaInt2(-1, -1));\n        #endif\n        #if (FXAA_DISCARD == 1)\n            #define lumaM luma4A.w\n        #endif\n        #define lumaE luma4A.z\n        #define lumaS luma4A.x\n        #define lumaSE luma4A.y\n        #define lumaNW luma4B.w\n        #define lumaN luma4B.z\n        #define lumaW luma4B.x\n    #else\n        FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);\n        #if (FXAA_GREEN_AS_LUMA == 0)\n            #define lumaM rgbyM.w\n        #else\n            #define lumaM rgbyM.y\n        #endif\n        #if (FXAA_GLSL_100 == 1)\n          FxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 0.0, 1.0), fxaaQualityRcpFrame.xy));\n          FxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0, 0.0), fxaaQualityRcpFrame.xy));\n          FxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 0.0,-1.0), fxaaQualityRcpFrame.xy));\n          FxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 0.0), fxaaQualityRcpFrame.xy));\n        #else\n          FxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0, 1), fxaaQualityRcpFrame.xy));\n          FxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 0), fxaaQualityRcpFrame.xy));\n          FxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0,-1), fxaaQualityRcpFrame.xy));\n          FxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 0), fxaaQualityRcpFrame.xy));\n        #endif\n    #endif\n/*--------------------------------------------------------------------------*/\n    FxaaFloat maxSM = max(lumaS, lumaM);\n    FxaaFloat minSM = min(lumaS, lumaM);\n    FxaaFloat maxESM = max(lumaE, maxSM);\n    FxaaFloat minESM = min(lumaE, minSM);\n    FxaaFloat maxWN = max(lumaN, lumaW);\n    FxaaFloat minWN = min(lumaN, lumaW);\n    FxaaFloat rangeMax = max(maxWN, maxESM);\n    FxaaFloat rangeMin = min(minWN, minESM);\n    FxaaFloat rangeMaxScaled = rangeMax * fxaaQualityEdgeThreshold;\n    FxaaFloat range = rangeMax - rangeMin;\n    FxaaFloat rangeMaxClamped = max(fxaaQualityEdgeThresholdMin, rangeMaxScaled);\n    FxaaBool earlyExit = range < rangeMaxClamped;\n/*--------------------------------------------------------------------------*/\n    if(earlyExit)\n        #if (FXAA_DISCARD == 1)\n            FxaaDiscard;\n        #else\n            return rgbyM;\n        #endif\n/*--------------------------------------------------------------------------*/\n    #if (FXAA_GATHER4_ALPHA == 0)\n        #if (FXAA_GLSL_100 == 1)\n          FxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0,-1.0), fxaaQualityRcpFrame.xy));\n          FxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0, 1.0), fxaaQualityRcpFrame.xy));\n          FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0,-1.0), fxaaQualityRcpFrame.xy));\n          FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 1.0), fxaaQualityRcpFrame.xy));\n        #else\n          FxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1,-1), fxaaQualityRcpFrame.xy));\n          FxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 1), fxaaQualityRcpFrame.xy));\n          FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1,-1), fxaaQualityRcpFrame.xy));\n          FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));\n        #endif\n    #else\n        FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(1, -1), fxaaQualityRcpFrame.xy));\n        FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));\n    #endif\n/*--------------------------------------------------------------------------*/\n    FxaaFloat lumaNS = lumaN + lumaS;\n    FxaaFloat lumaWE = lumaW + lumaE;\n    FxaaFloat subpixRcpRange = 1.0/range;\n    FxaaFloat subpixNSWE = lumaNS + lumaWE;\n    FxaaFloat edgeHorz1 = (-2.0 * lumaM) + lumaNS;\n    FxaaFloat edgeVert1 = (-2.0 * lumaM) + lumaWE;\n/*--------------------------------------------------------------------------*/\n    FxaaFloat lumaNESE = lumaNE + lumaSE;\n    FxaaFloat lumaNWNE = lumaNW + lumaNE;\n    FxaaFloat edgeHorz2 = (-2.0 * lumaE) + lumaNESE;\n    FxaaFloat edgeVert2 = (-2.0 * lumaN) + lumaNWNE;\n/*--------------------------------------------------------------------------*/\n    FxaaFloat lumaNWSW = lumaNW + lumaSW;\n    FxaaFloat lumaSWSE = lumaSW + lumaSE;\n    FxaaFloat edgeHorz4 = (abs(edgeHorz1) * 2.0) + abs(edgeHorz2);\n    FxaaFloat edgeVert4 = (abs(edgeVert1) * 2.0) + abs(edgeVert2);\n    FxaaFloat edgeHorz3 = (-2.0 * lumaW) + lumaNWSW;\n    FxaaFloat edgeVert3 = (-2.0 * lumaS) + lumaSWSE;\n    FxaaFloat edgeHorz = abs(edgeHorz3) + edgeHorz4;\n    FxaaFloat edgeVert = abs(edgeVert3) + edgeVert4;\n/*--------------------------------------------------------------------------*/\n    FxaaFloat subpixNWSWNESE = lumaNWSW + lumaNESE;\n    FxaaFloat lengthSign = fxaaQualityRcpFrame.x;\n    FxaaBool horzSpan = edgeHorz >= edgeVert;\n    FxaaFloat subpixA = subpixNSWE * 2.0 + subpixNWSWNESE;\n/*--------------------------------------------------------------------------*/\n    if(!horzSpan) lumaN = lumaW;\n    if(!horzSpan) lumaS = lumaE;\n    if(horzSpan) lengthSign = fxaaQualityRcpFrame.y;\n    FxaaFloat subpixB = (subpixA * (1.0/12.0)) - lumaM;\n/*--------------------------------------------------------------------------*/\n    FxaaFloat gradientN = lumaN - lumaM;\n    FxaaFloat gradientS = lumaS - lumaM;\n    FxaaFloat lumaNN = lumaN + lumaM;\n    FxaaFloat lumaSS = lumaS + lumaM;\n    FxaaBool pairN = abs(gradientN) >= abs(gradientS);\n    FxaaFloat gradient = max(abs(gradientN), abs(gradientS));\n    if(pairN) lengthSign = -lengthSign;\n    FxaaFloat subpixC = FxaaSat(abs(subpixB) * subpixRcpRange);\n/*--------------------------------------------------------------------------*/\n    FxaaFloat2 posB;\n    posB.x = posM.x;\n    posB.y = posM.y;\n    FxaaFloat2 offNP;\n    offNP.x = (!horzSpan) ? 0.0 : fxaaQualityRcpFrame.x;\n    offNP.y = ( horzSpan) ? 0.0 : fxaaQualityRcpFrame.y;\n    if(!horzSpan) posB.x += lengthSign * 0.5;\n    if( horzSpan) posB.y += lengthSign * 0.5;\n/*--------------------------------------------------------------------------*/\n    FxaaFloat2 posN;\n    posN.x = posB.x - offNP.x * FXAA_QUALITY_P0;\n    posN.y = posB.y - offNP.y * FXAA_QUALITY_P0;\n    FxaaFloat2 posP;\n    posP.x = posB.x + offNP.x * FXAA_QUALITY_P0;\n    posP.y = posB.y + offNP.y * FXAA_QUALITY_P0;\n    FxaaFloat subpixD = ((-2.0)*subpixC) + 3.0;\n    FxaaFloat lumaEndN = FxaaLuma(FxaaTexTop(tex, posN));\n    FxaaFloat subpixE = subpixC * subpixC;\n    FxaaFloat lumaEndP = FxaaLuma(FxaaTexTop(tex, posP));\n/*--------------------------------------------------------------------------*/\n    if(!pairN) lumaNN = lumaSS;\n    FxaaFloat gradientScaled = gradient * 1.0/4.0;\n    FxaaFloat lumaMM = lumaM - lumaNN * 0.5;\n    FxaaFloat subpixF = subpixD * subpixE;\n    FxaaBool lumaMLTZero = lumaMM < 0.0;\n/*--------------------------------------------------------------------------*/\n    lumaEndN -= lumaNN * 0.5;\n    lumaEndP -= lumaNN * 0.5;\n    FxaaBool doneN = abs(lumaEndN) >= gradientScaled;\n    FxaaBool doneP = abs(lumaEndP) >= gradientScaled;\n    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P1;\n    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P1;\n    FxaaBool doneNP = (!doneN) || (!doneP);\n    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P1;\n    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P1;\n/*--------------------------------------------------------------------------*/\n    if(doneNP) {\n        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n        doneN = abs(lumaEndN) >= gradientScaled;\n        doneP = abs(lumaEndP) >= gradientScaled;\n        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P2;\n        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P2;\n        doneNP = (!doneN) || (!doneP);\n        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P2;\n        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P2;\n/*--------------------------------------------------------------------------*/\n        #if (FXAA_QUALITY_PS > 3)\n        if(doneNP) {\n            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n            doneN = abs(lumaEndN) >= gradientScaled;\n            doneP = abs(lumaEndP) >= gradientScaled;\n            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P3;\n            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P3;\n            doneNP = (!doneN) || (!doneP);\n            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P3;\n            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P3;\n/*--------------------------------------------------------------------------*/\n            #if (FXAA_QUALITY_PS > 4)\n            if(doneNP) {\n                if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                doneN = abs(lumaEndN) >= gradientScaled;\n                doneP = abs(lumaEndP) >= gradientScaled;\n                if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P4;\n                if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P4;\n                doneNP = (!doneN) || (!doneP);\n                if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P4;\n                if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P4;\n/*--------------------------------------------------------------------------*/\n                #if (FXAA_QUALITY_PS > 5)\n                if(doneNP) {\n                    if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                    if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                    if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                    if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                    doneN = abs(lumaEndN) >= gradientScaled;\n                    doneP = abs(lumaEndP) >= gradientScaled;\n                    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P5;\n                    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P5;\n                    doneNP = (!doneN) || (!doneP);\n                    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P5;\n                    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P5;\n/*--------------------------------------------------------------------------*/\n                    #if (FXAA_QUALITY_PS > 6)\n                    if(doneNP) {\n                        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                        doneN = abs(lumaEndN) >= gradientScaled;\n                        doneP = abs(lumaEndP) >= gradientScaled;\n                        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P6;\n                        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P6;\n                        doneNP = (!doneN) || (!doneP);\n                        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P6;\n                        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P6;\n/*--------------------------------------------------------------------------*/\n                        #if (FXAA_QUALITY_PS > 7)\n                        if(doneNP) {\n                            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                            doneN = abs(lumaEndN) >= gradientScaled;\n                            doneP = abs(lumaEndP) >= gradientScaled;\n                            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P7;\n                            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P7;\n                            doneNP = (!doneN) || (!doneP);\n                            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P7;\n                            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P7;\n/*--------------------------------------------------------------------------*/\n    #if (FXAA_QUALITY_PS > 8)\n    if(doneNP) {\n        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n        doneN = abs(lumaEndN) >= gradientScaled;\n        doneP = abs(lumaEndP) >= gradientScaled;\n        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P8;\n        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P8;\n        doneNP = (!doneN) || (!doneP);\n        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P8;\n        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P8;\n/*--------------------------------------------------------------------------*/\n        #if (FXAA_QUALITY_PS > 9)\n        if(doneNP) {\n            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n            doneN = abs(lumaEndN) >= gradientScaled;\n            doneP = abs(lumaEndP) >= gradientScaled;\n            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P9;\n            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P9;\n            doneNP = (!doneN) || (!doneP);\n            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P9;\n            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P9;\n/*--------------------------------------------------------------------------*/\n            #if (FXAA_QUALITY_PS > 10)\n            if(doneNP) {\n                if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                doneN = abs(lumaEndN) >= gradientScaled;\n                doneP = abs(lumaEndP) >= gradientScaled;\n                if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P10;\n                if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P10;\n                doneNP = (!doneN) || (!doneP);\n                if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P10;\n                if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P10;\n/*--------------------------------------------------------------------------*/\n                #if (FXAA_QUALITY_PS > 11)\n                if(doneNP) {\n                    if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                    if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                    if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                    if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                    doneN = abs(lumaEndN) >= gradientScaled;\n                    doneP = abs(lumaEndP) >= gradientScaled;\n                    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P11;\n                    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P11;\n                    doneNP = (!doneN) || (!doneP);\n                    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P11;\n                    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P11;\n/*--------------------------------------------------------------------------*/\n                    #if (FXAA_QUALITY_PS > 12)\n                    if(doneNP) {\n                        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                        doneN = abs(lumaEndN) >= gradientScaled;\n                        doneP = abs(lumaEndP) >= gradientScaled;\n                        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P12;\n                        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P12;\n                        doneNP = (!doneN) || (!doneP);\n                        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P12;\n                        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P12;\n/*--------------------------------------------------------------------------*/\n                    }\n                    #endif\n/*--------------------------------------------------------------------------*/\n                }\n                #endif\n/*--------------------------------------------------------------------------*/\n            }\n            #endif\n/*--------------------------------------------------------------------------*/\n        }\n        #endif\n/*--------------------------------------------------------------------------*/\n    }\n    #endif\n/*--------------------------------------------------------------------------*/\n                        }\n                        #endif\n/*--------------------------------------------------------------------------*/\n                    }\n                    #endif\n/*--------------------------------------------------------------------------*/\n                }\n                #endif\n/*--------------------------------------------------------------------------*/\n            }\n            #endif\n/*--------------------------------------------------------------------------*/\n        }\n        #endif\n/*--------------------------------------------------------------------------*/\n    }\n/*--------------------------------------------------------------------------*/\n    FxaaFloat dstN = posM.x - posN.x;\n    FxaaFloat dstP = posP.x - posM.x;\n    if(!horzSpan) dstN = posM.y - posN.y;\n    if(!horzSpan) dstP = posP.y - posM.y;\n/*--------------------------------------------------------------------------*/\n    FxaaBool goodSpanN = (lumaEndN < 0.0) != lumaMLTZero;\n    FxaaFloat spanLength = (dstP + dstN);\n    FxaaBool goodSpanP = (lumaEndP < 0.0) != lumaMLTZero;\n    FxaaFloat spanLengthRcp = 1.0/spanLength;\n/*--------------------------------------------------------------------------*/\n    FxaaBool directionN = dstN < dstP;\n    FxaaFloat dst = min(dstN, dstP);\n    FxaaBool goodSpan = directionN ? goodSpanN : goodSpanP;\n    FxaaFloat subpixG = subpixF * subpixF;\n    FxaaFloat pixelOffset = (dst * (-spanLengthRcp)) + 0.5;\n    FxaaFloat subpixH = subpixG * fxaaQualitySubpix;\n/*--------------------------------------------------------------------------*/\n    FxaaFloat pixelOffsetGood = goodSpan ? pixelOffset : 0.0;\n    FxaaFloat pixelOffsetSubpix = max(pixelOffsetGood, subpixH);\n    if(!horzSpan) posM.x += pixelOffsetSubpix * lengthSign;\n    if( horzSpan) posM.y += pixelOffsetSubpix * lengthSign;\n    #if (FXAA_DISCARD == 1)\n        return FxaaTexTop(tex, posM);\n    #else\n        return FxaaFloat4(FxaaTexTop(tex, posM).xyz, lumaM);\n    #endif\n}\n/*==========================================================================*/\n#endif\n\nvoid main() {\n  gl_FragColor = FxaaPixelShader(\n    vUv,\n    vec4(0.0),\n    tDiffuse,\n    tDiffuse,\n    tDiffuse,\n    resolution,\n    vec4(0.0),\n    vec4(0.0),\n    vec4(0.0),\n    0.75,\n    0.166,\n    0.0833,\n    0.0,\n    0.0,\n    0.0,\n    vec4(0.0)\n  );\n\n  // TODO avoid querying texture twice for same texel\n  gl_FragColor.a = texture2D(tDiffuse, vUv).a;\n}'
            }, G = {
                uniforms: {
                    textureWidth: {
                        value: 1
                    },
                    textureHeight: {
                        value: 1
                    },
                    focalDepth: {
                        value: 1
                    },
                    focalLength: {
                        value: 35
                    },
                    fstop: {
                        value: 2.2
                    },
                    tColor: {
                        value: null
                    },
                    tDepth: {
                        value: null
                    },
                    maxblur: {
                        value: 2.5
                    },
                    showFocus: {
                        value: 0
                    },
                    manualdof: {
                        value: 1
                    },
                    vignetting: {
                        value: 0
                    },
                    depthblur: {
                        value: 0
                    },
                    threshold: {
                        value: .5
                    },
                    gain: {
                        value: 2
                    },
                    bias: {
                        value: .5
                    },
                    fringe: {
                        value: .7
                    },
                    znear: {
                        value: .1
                    },
                    zfar: {
                        value: 100
                    },
                    noise: {
                        value: 1
                    },
                    dithering: {
                        value: 1e-4
                    },
                    pentagon: {
                        value: 0
                    },
                    shaderFocus: {
                        value: 0
                    },
                    focusCoords: {
                        value: new Vector2
                    }
                },
                vertexShader: "varying vec2 vUv;\nvoid main() {\n\tvUv = uv;\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
                fragmentShader: "#include <common>\nvarying vec2 vUv;\nuniform sampler2D tColor;\nuniform sampler2D tDepth;\nuniform float textureWidth;\nuniform float textureHeight;\nuniform float focalDepth;  //focal distance value in meters, but you may use autofocus option below\nuniform float focalLength; //focal length in mm\nuniform float fstop; //f-stop value\nuniform bool showFocus; //show debug focus point and focal range (red = focal point, green = focal range)\n/*\nmake sure that these two values are the same for your camera, otherwise distances will be wrong.\n*/\nuniform float znear; // camera clipping start\nuniform float zfar; // camera clipping end\n//------------------------------------------\n//user variables\nconst int samples = SAMPLES; //samples on the first ring\nconst int rings = RINGS; //ring count\nconst int maxringsamples = rings * samples;\nuniform bool manualdof; // manual dof calculation\nfloat ndofstart = 1.0; // near dof blur start\nfloat ndofdist = 2.0; // near dof blur falloff distance\nfloat fdofstart = 1.0; // far dof blur start\nfloat fdofdist = 3.0; // far dof blur falloff distance\nfloat CoC = 0.03; //circle of confusion size in mm (35mm film = 0.03mm)\nuniform bool vignetting; // use optical lens vignetting\nfloat vignout = 1.3; // vignetting outer border\nfloat vignin = 0.0; // vignetting inner border\nfloat vignfade = 22.0; // f-stops till vignete fades\nuniform bool shaderFocus;\n// disable if you use external focalDepth value\nuniform vec2 focusCoords;\n// autofocus point on screen (0.0,0.0 - left lower corner, 1.0,1.0 - upper right)\n// if center of screen use vec2(0.5, 0.5);\nuniform float maxblur;\n//clamp value of max blur (0.0 = no blur, 1.0 default)\nuniform float threshold; // highlight threshold;\nuniform float gain; // highlight gain;\nuniform float bias; // bokeh edge bias\nuniform float fringe; // bokeh chromatic aberration / fringing\nuniform bool noise; //use noise instead of pattern for sample dithering\nuniform float dithering;\nuniform bool depthblur; // blur the depth buffer\nfloat dbsize = 1.25; // depth blur size\n/*\nnext part is experimental\nnot looking good with small sample and ring count\nlooks okay starting from samples = 4, rings = 4\n*/\nuniform bool pentagon; //use pentagon as bokeh shape?\nfloat feather = 0.4; //pentagon shape feather\n//------------------------------------------\nfloat penta(vec2 coords) {\n\t//pentagonal shape\n\tfloat scale = float(rings) - 1.3;\n\tvec4  HS0 = vec4( 1.0,         0.0,         0.0,  1.0);\n\tvec4  HS1 = vec4( 0.309016994, 0.951056516, 0.0,  1.0);\n\tvec4  HS2 = vec4(-0.809016994, 0.587785252, 0.0,  1.0);\n\tvec4  HS3 = vec4(-0.809016994,-0.587785252, 0.0,  1.0);\n\tvec4  HS4 = vec4( 0.309016994,-0.951056516, 0.0,  1.0);\n\tvec4  HS5 = vec4( 0.0        ,0.0         , 1.0,  1.0);\n\tvec4  one = vec4( 1.0 );\n\tvec4 P = vec4((coords),vec2(scale, scale));\n\tvec4 dist = vec4(0.0);\n\tfloat inorout = -4.0;\n\tdist.x = dot( P, HS0 );\n\tdist.y = dot( P, HS1 );\n\tdist.z = dot( P, HS2 );\n\tdist.w = dot( P, HS3 );\n\tdist = smoothstep( -feather, feather, dist );\n\tinorout += dot( dist, one );\n\tdist.x = dot( P, HS4 );\n\tdist.y = HS5.w - abs( P.z );\n\tdist = smoothstep( -feather, feather, dist );\n\tinorout += dist.x;\n\treturn clamp( inorout, 0.0, 1.0 );\n}\nfloat bdepth(vec2 coords) {\n\t// Depth buffer blur\n\tfloat d = 0.0;\n\tfloat kernel[9];\n\tvec2 offset[9];\n\tvec2 wh = vec2(1.0/textureWidth,1.0/textureHeight) * dbsize;\n\toffset[0] = vec2(-wh.x,-wh.y);\n\toffset[1] = vec2( 0.0, -wh.y);\n\toffset[2] = vec2( wh.x -wh.y);\n\toffset[3] = vec2(-wh.x,  0.0);\n\toffset[4] = vec2( 0.0,   0.0);\n\toffset[5] = vec2( wh.x,  0.0);\n\toffset[6] = vec2(-wh.x, wh.y);\n\toffset[7] = vec2( 0.0,  wh.y);\n\toffset[8] = vec2( wh.x, wh.y);\n\tkernel[0] = 1.0/16.0;   kernel[1] = 2.0/16.0;   kernel[2] = 1.0/16.0;\n\tkernel[3] = 2.0/16.0;   kernel[4] = 4.0/16.0;   kernel[5] = 2.0/16.0;\n\tkernel[6] = 1.0/16.0;   kernel[7] = 2.0/16.0;   kernel[8] = 1.0/16.0;\n\tfor( int i=0; i<9; i++ ) {\n\t\tfloat tmp = texture2D(tDepth, coords + offset[i]).r;\n\t\td += tmp * kernel[i];\n\t}\n\treturn d;\n}\nvec4 color(vec2 coords,float blur) {\n\t//processing the sample\n\tvec4 col = vec4(0.0);\n\tvec2 texel = vec2(1.0/textureWidth,1.0/textureHeight);\n\tcol.r = texture2D(tColor,coords + vec2(0.0,1.0)*texel*fringe*blur).r;\n\tcol.g = texture2D(tColor,coords + vec2(-0.866,-0.5)*texel*fringe*blur).g;\n\tcol.b = texture2D(tColor,coords + vec2(0.866,-0.5)*texel*fringe*blur).b;\n\tcol.a = texture2D(tColor,coords + vec2(0.866,-0.5)*texel*fringe*blur).a;\n\tvec3 lumcoeff = vec3(0.299,0.587,0.114);\n\tfloat lum = dot(col.rgb, lumcoeff);\n\tfloat thresh = max((lum-threshold)*gain, 0.0);\n\treturn col+mix(vec4(0.0),col,thresh*blur);\n}\nvec4 debugFocus(vec4 col, float blur, float depth) {\n\tfloat edge = 0.002*depth; //distance based edge smoothing\n\tfloat m = clamp(smoothstep(0.0,edge,blur),0.0,1.0);\n\tfloat e = clamp(smoothstep(1.0-edge,1.0,blur),0.0,1.0);\n\tcol = mix(col,vec4(1.0,0.5,0.0,1.0),(1.0-m)*0.6);\n\tcol = mix(col,vec4(0.0,0.5,1.0,1.0),((1.0-e)-(1.0-m))*0.2);\n\treturn col;\n}\nfloat linearize(float depth) {\n\treturn -zfar * znear / (depth * (zfar - znear) - zfar);\n}\nfloat vignette() {\n\tfloat dist = distance(vUv.xy, vec2(0.5,0.5));\n\tdist = smoothstep(vignout+(fstop/vignfade), vignin+(fstop/vignfade), dist);\n\treturn clamp(dist,0.0,1.0);\n}\nfloat gather(float i, float j, int ringsamples, inout vec4 col, float w, float h, float blur) {\n\tfloat rings2 = float(rings);\n\tfloat step = PI*2.0 / float(ringsamples);\n\tfloat pw = cos(j*step)*i;\n\tfloat ph = sin(j*step)*i;\n\tfloat p = 1.0;\n\tif (pentagon) {\n\t\tp = penta(vec2(pw,ph));\n\t}\n\tcol += color(vUv.xy + vec2(pw*w,ph*h), blur) * mix(1.0, i/rings2, bias) * p;\n\treturn 1.0 * mix(1.0, i /rings2, bias) * p;\n}\nvoid main() {\n\t//scene depth calculation\n  \tfloat texVal = texture2D(tDepth,vUv.xy).x;\n\tfloat depth = linearize(1.0-texVal);\n\t// Blur depth?\n\tif ( depthblur ) {\n\t\tdepth = linearize(bdepth(vUv.xy));\n\t}\n\t//focal plane calculation\n\tfloat fDepth = focalDepth;\n\tif (shaderFocus) {\n\t\tfDepth = linearize(1.0-texture2D(tDepth,focusCoords).x);\n\t}\n\t// dof blur factor calculation\n\tfloat blur = 0.0;\n \tblur = pow(texVal,10.0)*4.0;\n\tblur = clamp(blur,0.0,1.0);\n\t// calculation of pattern for dithering\n\tvec2 noise = vec2(rand(vUv.xy), rand( vUv.xy + vec2( 0.4, 0.6 ) ) )*dithering*blur;\n\t// getting blur x and y step factor\n\tfloat w = (1.0/textureWidth)*blur*maxblur+noise.x;\n\tfloat h = (1.0/textureHeight)*blur*maxblur+noise.y;\n\t// calculation of final color\n\tvec4 col = vec4(0.0);\n\tif(blur < 0.05) {\n\t\t//some optimization thingy\n\t\tcol = texture2D(tColor, vUv.xy);\n\t} else {\n\t\tcol = texture2D(tColor, vUv.xy);\n\t\tfloat s = 1.0;\n\t\tint ringsamples;\n\t\tfor (int i = 1; i <= rings; i++) {\n\t\t\t/*unboxstart*/\n\t\t\tringsamples = i * samples;\n\t\t\tfor (int j = 0 ; j < maxringsamples ; j++) {\n\t\t\t\tif (j >= ringsamples) break;\n\t\t\t\ts += gather(float(i), float(j), ringsamples, col, w, h, blur);\n\t\t\t}\n\t\t\t/*unboxend*/\n\t\t}\n\t\tcol /= s; //divide by sample count\n\t}\n\tif (showFocus) {\n\t\tcol = debugFocus(col, blur, depth);\n\t}\n\tif (vignetting) {\n\t\tcol *= vignette();\n\t}\n\tgl_FragColor = col;\n} "
            }, j = 3, W = 4, H = k = {
                uniforms: {
                    mNear: {
                        value: 1
                    },
                    mFar: {
                        value: 1e3
                    }
                },
                vertexShader: "varying float vViewZDepth;\n#include <uv_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tvViewZDepth = - mvPosition.z;\n}",
                fragmentShader: "uniform float mNear;\nuniform float mFar;\nvarying float vViewZDepth;\nvoid main() {\n\tfloat color = 1.0 - smoothstep( mNear, mFar, vViewZDepth );\n\tgl_FragColor = vec4( vec3( color ), 1.0 );\n} "
            }, (X = function DepthOfFieldPass(e, t, n) {
                var i, r;
                P.call(this), (n = n || {}).fstop = n.fstop || 2.2, n.maxblur = n.maxblur || 1, n.focalDepth = n.focalDepth || 2.8, n.threshold = n.threshold || .5, n.gain = n.gain || 2, n.focalLength = n.focalLength || 35, n.noise = n.noise || !0, n.pentagon = n.pentagon || !1, n.dithering = 1e-4, n.near = n.near || .01, n.far = n.far || .75, this.options = n, this.width = n.width || 512, this.height = n.height || 512, this.scene = e, this.camera = t, i = {
                    minFilter: fi,
                    magFilter: fi,
                    format: Fi
                }, this.rtTextureDepth = new WebGLRenderTarget(this.width, this.height, i), r = G, this.bokeh_uniforms = ys.clone(r.uniforms), this.bokeh_uniforms.tDepth.value = this.rtTextureDepth.texture, this.bokeh_uniforms.textureWidth.value = this.width, this.bokeh_uniforms.textureHeight.value = this.height, this.bokeh_uniforms.znear.value = n.near, this.bokeh_uniforms.zfar.value = n.far, this.materialDepth = new ShaderMaterial({
                    uniforms: H.uniforms,
                    vertexShader: H.vertexShader,
                    fragmentShader: H.fragmentShader
                }), this.materialDepthInstanced = new ShaderMaterial({
                    uniforms: H.uniforms,
                    vertexShader: H.vertexShader,
                    fragmentShader: H.fragmentShader,
                    defines: {
                        INSTANCE_TRANSFORM: ""
                    }
                }), this.materialDepth.uniforms.mNear.value = n.near, this.materialDepth.uniforms.mFar.value = n.far, this.materialBokeh = new ShaderMaterial({
                    uniforms: this.bokeh_uniforms,
                    vertexShader: r.vertexShader,
                    fragmentShader: r.fragmentShader,
                    defines: {
                        RINGS: j,
                        SAMPLES: W
                    }
                }), this.basic = new MeshBasicMaterial, this.fsQuad = new F(this.basic), this.enabled = !0, this.needsSwap = !0, this.updateOptions()
            }).prototype = Object.assign(Object.create(P.prototype), {
                constructor: X,
                dispose: function dispose() {},
                setSize: function setSize(e, t) {
                    this.width = e, this.height = t, this.windowHalfX = e / 2, this.windowHalfY = t / 2, this.rtTextureDepth.setSize(e, t), this.bokeh_uniforms.textureWidth.value = e, this.bokeh_uniforms.textureHeight.value = t
                },
                updateOptions: function updateOptions() {},
                linearize: function linearize(e) {
                    var t = this.options.far,
                        n = this.options.near;
                    return -t * n / (e * (t - n) - t)
                },
                render: function render(e, t, n, i, r) {
                    var a = this,
                        o = e.autoClear;
                    e.autoClear = !1, this.scene && this.camera && (e.setRenderTarget(this.rtTextureDepth), e.clear(), this.scene.traverse((function(e) {
                        e.isInstancedMesh ? (e.oldMaterial = e.material, e.customDOFMaterial ? e.material = e.customDOFMaterial : e.material = a.materialDepthInstanced) : e.isMesh && (e.oldMaterial = e.material, e.customDOFMaterial ? e.material = e.customDOFMaterial : e.material = a.materialDepth)
                    })), e.render(this.scene, this.camera), this.scene.traverse((function(e) {
                        e.isMesh && (e.material = e.oldMaterial, e.oldMaterial = void 0)
                    }))), this.fsQuad.material = this.materialBokeh, this.bokeh_uniforms.tColor.value = n.texture, this.bokeh_uniforms.tColor.needsUpdate = !0, this.bokeh_uniforms.focalDepth.needsUpdate = !0, this.renderToScreen ? (e.setRenderTarget(null), this.fsQuad.render(e)) : (e.setRenderTarget(t), this.fsQuad.render(e), e.setRenderTarget(null)), e.autoClear = o
                }
            }), Y = __webpack_require__(6445), q = __webpack_require__.n(Y), Q = __webpack_require__(2753), J = __webpack_require__.n(Q);
            class Mat3 {
                constructor(e = [0, 0, 0, 0, 0, 0, 0, 0, 0]) {
                    this.elements = void 0, this.elements = e
                }
                identity() {
                    const e = this.elements;
                    e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 1, e[5] = 0, e[6] = 0, e[7] = 0, e[8] = 1
                }
                setZero() {
                    const e = this.elements;
                    e[0] = 0, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = 0, e[6] = 0, e[7] = 0, e[8] = 0
                }
                setTrace(e) {
                    const t = this.elements;
                    t[0] = e.x, t[4] = e.y, t[8] = e.z
                }
                getTrace(e = new Vec3) {
                    const t = this.elements;
                    return e.x = t[0], e.y = t[4], e.z = t[8], e
                }
                vmult(e, t = new Vec3) {
                    const n = this.elements,
                        i = e.x,
                        r = e.y,
                        a = e.z;
                    return t.x = n[0] * i + n[1] * r + n[2] * a, t.y = n[3] * i + n[4] * r + n[5] * a, t.z = n[6] * i + n[7] * r + n[8] * a, t
                }
                smult(e) {
                    for (let t = 0; t < this.elements.length; t++) this.elements[t] *= e
                }
                mmult(e, t = new Mat3) {
                    const n = this.elements,
                        i = e.elements,
                        r = t.elements,
                        a = n[0],
                        o = n[1],
                        s = n[2],
                        l = n[3],
                        c = n[4],
                        u = n[5],
                        h = n[6],
                        d = n[7],
                        p = n[8],
                        f = i[0],
                        m = i[1],
                        g = i[2],
                        y = i[3],
                        x = i[4],
                        _ = i[5],
                        b = i[6],
                        M = i[7],
                        S = i[8];
                    return r[0] = a * f + o * y + s * b, r[1] = a * m + o * x + s * M, r[2] = a * g + o * _ + s * S, r[3] = l * f + c * y + u * b, r[4] = l * m + c * x + u * M, r[5] = l * g + c * _ + u * S, r[6] = h * f + d * y + p * b, r[7] = h * m + d * x + p * M, r[8] = h * g + d * _ + p * S, t
                }
                scale(e, t = new Mat3) {
                    const n = this.elements,
                        i = t.elements;
                    for (let t = 0; 3 !== t; t++) i[3 * t + 0] = e.x * n[3 * t + 0], i[3 * t + 1] = e.y * n[3 * t + 1], i[3 * t + 2] = e.z * n[3 * t + 2];
                    return t
                }
                solve(e, t = new Vec3) {
                    const n = [];
                    let i, r;
                    for (i = 0; i < 12; i++) n.push(0);
                    for (i = 0; i < 3; i++)
                        for (r = 0; r < 3; r++) n[i + 4 * r] = this.elements[i + 3 * r];
                    n[3] = e.x, n[7] = e.y, n[11] = e.z;
                    let a = 3;
                    const o = a;
                    let s;
                    let l;
                    do {
                        if (i = o - a, 0 === n[i + 4 * i])
                            for (r = i + 1; r < o; r++)
                                if (0 !== n[i + 4 * r]) {
                                    s = 4;
                                    do {
                                        l = 4 - s, n[l + 4 * i] += n[l + 4 * r]
                                    } while (--s);
                                    break
                                }
                        if (0 !== n[i + 4 * i])
                            for (r = i + 1; r < o; r++) {
                                const e = n[i + 4 * r] / n[i + 4 * i];
                                s = 4;
                                do {
                                    l = 4 - s, n[l + 4 * r] = l <= i ? 0 : n[l + 4 * r] - n[l + 4 * i] * e
                                } while (--s)
                            }
                    } while (--a);
                    if (t.z = n[11] / n[10], t.y = (n[7] - n[6] * t.z) / n[5], t.x = (n[3] - n[2] * t.z - n[1] * t.y) / n[0], isNaN(t.x) || isNaN(t.y) || isNaN(t.z) || t.x === 1 / 0 || t.y === 1 / 0 || t.z === 1 / 0) throw "Could not solve equation! Got x=[" + t.toString() + "], b=[" + e.toString() + "], A=[" + this.toString() + "]";
                    return t
                }
                e(e, t, n) {
                    if (void 0 === n) return this.elements[t + 3 * e];
                    this.elements[t + 3 * e] = n
                }
                copy(e) {
                    for (let t = 0; t < e.elements.length; t++) this.elements[t] = e.elements[t];
                    return this
                }
                toString() {
                    let e = "";
                    for (let t = 0; t < 9; t++) e += this.elements[t] + ",";
                    return e
                }
                reverse(e = new Mat3) {
                    const t = Zc;
                    let n, i;
                    for (n = 0; n < 3; n++)
                        for (i = 0; i < 3; i++) t[n + 6 * i] = this.elements[n + 3 * i];
                    t[3] = 1, t[9] = 0, t[15] = 0, t[4] = 0, t[10] = 1, t[16] = 0, t[5] = 0, t[11] = 0, t[17] = 1;
                    let r = 3;
                    const a = r;
                    let o;
                    let s;
                    do {
                        if (n = a - r, 0 === t[n + 6 * n])
                            for (i = n + 1; i < a; i++)
                                if (0 !== t[n + 6 * i]) {
                                    o = 6;
                                    do {
                                        s = 6 - o, t[s + 6 * n] += t[s + 6 * i]
                                    } while (--o);
                                    break
                                }
                        if (0 !== t[n + 6 * n])
                            for (i = n + 1; i < a; i++) {
                                const e = t[n + 6 * i] / t[n + 6 * n];
                                o = 6;
                                do {
                                    s = 6 - o, t[s + 6 * i] = s <= n ? 0 : t[s + 6 * i] - t[s + 6 * n] * e
                                } while (--o)
                            }
                    } while (--r);
                    n = 2;
                    do {
                        i = n - 1;
                        do {
                            const e = t[n + 6 * i] / t[n + 6 * n];
                            o = 6;
                            do {
                                s = 6 - o, t[s + 6 * i] = t[s + 6 * i] - t[s + 6 * n] * e
                            } while (--o)
                        } while (i--)
                    } while (--n);
                    n = 2;
                    do {
                        const e = 1 / t[n + 6 * n];
                        o = 6;
                        do {
                            s = 6 - o, t[s + 6 * n] = t[s + 6 * n] * e
                        } while (--o)
                    } while (n--);
                    n = 2;
                    do {
                        i = 2;
                        do {
                            if (s = t[3 + i + 6 * n], isNaN(s) || s === 1 / 0) throw "Could not reverse! A=[" + this.toString() + "]";
                            e.e(n, i, s)
                        } while (i--)
                    } while (n--);
                    return e
                }
                setRotationFromQuaternion(e) {
                    const t = e.x,
                        n = e.y,
                        i = e.z,
                        r = e.w,
                        a = t + t,
                        o = n + n,
                        s = i + i,
                        l = t * a,
                        c = t * o,
                        u = t * s,
                        h = n * o,
                        d = n * s,
                        p = i * s,
                        f = r * a,
                        m = r * o,
                        g = r * s,
                        y = this.elements;
                    return y[0] = 1 - (h + p), y[1] = c - g, y[2] = u + m, y[3] = c + g, y[4] = 1 - (l + p), y[5] = d - f, y[6] = u - m, y[7] = d + f, y[8] = 1 - (l + h), this
                }
                transpose(e = new Mat3) {
                    const t = this.elements,
                        n = e.elements;
                    let i;
                    return n[0] = t[0], n[4] = t[4], n[8] = t[8], i = t[1], n[1] = t[3], n[3] = i, i = t[2], n[2] = t[6], n[6] = i, i = t[5], n[5] = t[7], n[7] = i, e
                }
            }
            const Zc = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
            class Vec3 {
                constructor(e = 0, t = 0, n = 0) {
                    this.x = void 0, this.y = void 0, this.z = void 0, this.x = e, this.y = t, this.z = n
                }
                cross(e, t = new Vec3) {
                    const n = e.x,
                        i = e.y,
                        r = e.z,
                        a = this.x,
                        o = this.y,
                        s = this.z;
                    return t.x = o * r - s * i, t.y = s * n - a * r, t.z = a * i - o * n, t
                }
                set(e, t, n) {
                    return this.x = e, this.y = t, this.z = n, this
                }
                setZero() {
                    this.x = this.y = this.z = 0
                }
                vadd(e, t) {
                    if (!t) return new Vec3(this.x + e.x, this.y + e.y, this.z + e.z);
                    t.x = e.x + this.x, t.y = e.y + this.y, t.z = e.z + this.z
                }
                vsub(e, t) {
                    if (!t) return new Vec3(this.x - e.x, this.y - e.y, this.z - e.z);
                    t.x = this.x - e.x, t.y = this.y - e.y, t.z = this.z - e.z
                }
                crossmat() {
                    return new Mat3([0, -this.z, this.y, this.z, 0, -this.x, -this.y, this.x, 0])
                }
                normalize() {
                    const e = this.x,
                        t = this.y,
                        n = this.z,
                        i = Math.sqrt(e * e + t * t + n * n);
                    if (i > 0) {
                        const e = 1 / i;
                        this.x *= e, this.y *= e, this.z *= e
                    } else this.x = 0, this.y = 0, this.z = 0;
                    return i
                }
                unit(e = new Vec3) {
                    const t = this.x,
                        n = this.y,
                        i = this.z;
                    let r = Math.sqrt(t * t + n * n + i * i);
                    return r > 0 ? (r = 1 / r, e.x = t * r, e.y = n * r, e.z = i * r) : (e.x = 1, e.y = 0, e.z = 0), e
                }
                length() {
                    const e = this.x,
                        t = this.y,
                        n = this.z;
                    return Math.sqrt(e * e + t * t + n * n)
                }
                lengthSquared() {
                    return this.dot(this)
                }
                distanceTo(e) {
                    const t = this.x,
                        n = this.y,
                        i = this.z,
                        r = e.x,
                        a = e.y,
                        o = e.z;
                    return Math.sqrt((r - t) * (r - t) + (a - n) * (a - n) + (o - i) * (o - i))
                }
                distanceSquared(e) {
                    const t = this.x,
                        n = this.y,
                        i = this.z,
                        r = e.x,
                        a = e.y,
                        o = e.z;
                    return (r - t) * (r - t) + (a - n) * (a - n) + (o - i) * (o - i)
                }
                scale(e, t = new Vec3) {
                    const n = this.x,
                        i = this.y,
                        r = this.z;
                    return t.x = e * n, t.y = e * i, t.z = e * r, t
                }
                vmul(e, t = new Vec3) {
                    return t.x = e.x * this.x, t.y = e.y * this.y, t.z = e.z * this.z, t
                }
                addScaledVector(e, t, n = new Vec3) {
                    return n.x = this.x + e * t.x, n.y = this.y + e * t.y, n.z = this.z + e * t.z, n
                }
                dot(e) {
                    return this.x * e.x + this.y * e.y + this.z * e.z
                }
                isZero() {
                    return 0 === this.x && 0 === this.y && 0 === this.z
                }
                negate(e = new Vec3) {
                    return e.x = -this.x, e.y = -this.y, e.z = -this.z, e
                }
                tangents(e, t) {
                    const n = this.length();
                    if (n > 0) {
                        const i = Kc,
                            r = 1 / n;
                        i.set(this.x * r, this.y * r, this.z * r);
                        const a = $c;
                        Math.abs(i.x) < .9 ? (a.set(1, 0, 0), i.cross(a, e)) : (a.set(0, 1, 0), i.cross(a, e)), i.cross(e, t)
                    } else e.set(1, 0, 0), t.set(0, 1, 0)
                }
                toString() {
                    return this.x + "," + this.y + "," + this.z
                }
                toArray() {
                    return [this.x, this.y, this.z]
                }
                copy(e) {
                    return this.x = e.x, this.y = e.y, this.z = e.z, this
                }
                lerp(e, t, n) {
                    const i = this.x,
                        r = this.y,
                        a = this.z;
                    n.x = i + (e.x - i) * t, n.y = r + (e.y - r) * t, n.z = a + (e.z - a) * t
                }
                almostEquals(e, t = 1e-6) {
                    return !(Math.abs(this.x - e.x) > t || Math.abs(this.y - e.y) > t || Math.abs(this.z - e.z) > t)
                }
                almostZero(e = 1e-6) {
                    return !(Math.abs(this.x) > e || Math.abs(this.y) > e || Math.abs(this.z) > e)
                }
                isAntiparallelTo(e, t) {
                    return this.negate(eu), eu.almostEquals(e, t)
                }
                clone() {
                    return new Vec3(this.x, this.y, this.z)
                }
            }
            Vec3.ZERO = void 0, Vec3.UNIT_X = void 0, Vec3.UNIT_Y = void 0, Vec3.UNIT_Z = void 0, Vec3.ZERO = new Vec3(0, 0, 0), Vec3.UNIT_X = new Vec3(1, 0, 0), Vec3.UNIT_Y = new Vec3(0, 1, 0), Vec3.UNIT_Z = new Vec3(0, 0, 1);
            const Kc = new Vec3,
                $c = new Vec3,
                eu = new Vec3;
            class AABB {
                constructor(e = {}) {
                    this.lowerBound = void 0, this.upperBound = void 0, this.lowerBound = new Vec3, this.upperBound = new Vec3, e.lowerBound && this.lowerBound.copy(e.lowerBound), e.upperBound && this.upperBound.copy(e.upperBound)
                }
                setFromPoints(e, t, n, i) {
                    const r = this.lowerBound,
                        a = this.upperBound,
                        o = n;
                    r.copy(e[0]), o && o.vmult(r, r), a.copy(r);
                    for (let t = 1; t < e.length; t++) {
                        let n = e[t];
                        o && (o.vmult(n, tu), n = tu), n.x > a.x && (a.x = n.x), n.x < r.x && (r.x = n.x), n.y > a.y && (a.y = n.y), n.y < r.y && (r.y = n.y), n.z > a.z && (a.z = n.z), n.z < r.z && (r.z = n.z)
                    }
                    return t && (t.vadd(r, r), t.vadd(a, a)), i && (r.x -= i, r.y -= i, r.z -= i, a.x += i, a.y += i, a.z += i), this
                }
                copy(e) {
                    return this.lowerBound.copy(e.lowerBound), this.upperBound.copy(e.upperBound), this
                }
                clone() {
                    return (new AABB).copy(this)
                }
                extend(e) {
                    this.lowerBound.x = Math.min(this.lowerBound.x, e.lowerBound.x), this.upperBound.x = Math.max(this.upperBound.x, e.upperBound.x), this.lowerBound.y = Math.min(this.lowerBound.y, e.lowerBound.y), this.upperBound.y = Math.max(this.upperBound.y, e.upperBound.y), this.lowerBound.z = Math.min(this.lowerBound.z, e.lowerBound.z), this.upperBound.z = Math.max(this.upperBound.z, e.upperBound.z)
                }
                overlaps(e) {
                    const t = this.lowerBound,
                        n = this.upperBound,
                        i = e.lowerBound,
                        r = e.upperBound,
                        a = i.x <= n.x && n.x <= r.x || t.x <= r.x && r.x <= n.x,
                        o = i.y <= n.y && n.y <= r.y || t.y <= r.y && r.y <= n.y,
                        s = i.z <= n.z && n.z <= r.z || t.z <= r.z && r.z <= n.z;
                    return a && o && s
                }
                volume() {
                    const e = this.lowerBound,
                        t = this.upperBound;
                    return (t.x - e.x) * (t.y - e.y) * (t.z - e.z)
                }
                contains(e) {
                    const t = this.lowerBound,
                        n = this.upperBound,
                        i = e.lowerBound,
                        r = e.upperBound;
                    return t.x <= i.x && n.x >= r.x && t.y <= i.y && n.y >= r.y && t.z <= i.z && n.z >= r.z
                }
                getCorners(e, t, n, i, r, a, o, s) {
                    const l = this.lowerBound,
                        c = this.upperBound;
                    e.copy(l), t.set(c.x, l.y, l.z), n.set(c.x, c.y, l.z), i.set(l.x, c.y, c.z), r.set(c.x, l.y, c.z), a.set(l.x, c.y, l.z), o.set(l.x, l.y, c.z), s.copy(c)
                }
                toLocalFrame(e, t) {
                    const n = nu,
                        i = n[0],
                        r = n[1],
                        a = n[2],
                        o = n[3],
                        s = n[4],
                        l = n[5],
                        c = n[6],
                        u = n[7];
                    this.getCorners(i, r, a, o, s, l, c, u);
                    for (let t = 0; 8 !== t; t++) {
                        const i = n[t];
                        e.pointToLocal(i, i)
                    }
                    return t.setFromPoints(n)
                }
                toWorldFrame(e, t) {
                    const n = nu,
                        i = n[0],
                        r = n[1],
                        a = n[2],
                        o = n[3],
                        s = n[4],
                        l = n[5],
                        c = n[6],
                        u = n[7];
                    this.getCorners(i, r, a, o, s, l, c, u);
                    for (let t = 0; 8 !== t; t++) {
                        const i = n[t];
                        e.pointToWorld(i, i)
                    }
                    return t.setFromPoints(n)
                }
                overlapsRay(e) {
                    const {
                        direction: t,
                        from: n
                    } = e, i = 1 / t.x, r = 1 / t.y, a = 1 / t.z, o = (this.lowerBound.x - n.x) * i, s = (this.upperBound.x - n.x) * i, l = (this.lowerBound.y - n.y) * r, c = (this.upperBound.y - n.y) * r, u = (this.lowerBound.z - n.z) * a, h = (this.upperBound.z - n.z) * a, d = Math.max(Math.max(Math.min(o, s), Math.min(l, c)), Math.min(u, h)), p = Math.min(Math.min(Math.max(o, s), Math.max(l, c)), Math.max(u, h));
                    return !(p < 0) && !(d > p)
                }
            }
            const tu = new Vec3,
                nu = [new Vec3, new Vec3, new Vec3, new Vec3, new Vec3, new Vec3, new Vec3, new Vec3];
            class EventTarget {
                constructor() {
                    this._listeners = void 0
                }
                addEventListener(e, t) {
                    void 0 === this._listeners && (this._listeners = {});
                    const n = this._listeners;
                    return void 0 === n[e] && (n[e] = []), n[e].includes(t) || n[e].push(t), this
                }
                hasEventListener(e, t) {
                    if (void 0 === this._listeners) return !1;
                    const n = this._listeners;
                    return !(void 0 === n[e] || !n[e].includes(t))
                }
                hasAnyEventListener(e) {
                    if (void 0 === this._listeners) return !1;
                    return void 0 !== this._listeners[e]
                }
                removeEventListener(e, t) {
                    if (void 0 === this._listeners) return this;
                    const n = this._listeners;
                    if (void 0 === n[e]) return this;
                    const i = n[e].indexOf(t);
                    return -1 !== i && n[e].splice(i, 1), this
                }
                dispatchEvent(e) {
                    if (void 0 === this._listeners) return this;
                    const t = this._listeners[e.type];
                    if (void 0 !== t) {
                        e.target = this;
                        for (let n = 0, i = t.length; n < i; n++) t[n].call(this, e)
                    }
                    return this
                }
            }
            class cannon_es_Quaternion {
                constructor(e = 0, t = 0, n = 0, i = 1) {
                    this.x = void 0, this.y = void 0, this.z = void 0, this.w = void 0, this.x = e, this.y = t, this.z = n, this.w = i
                }
                set(e, t, n, i) {
                    return this.x = e, this.y = t, this.z = n, this.w = i, this
                }
                toString() {
                    return this.x + "," + this.y + "," + this.z + "," + this.w
                }
                toArray() {
                    return [this.x, this.y, this.z, this.w]
                }
                setFromAxisAngle(e, t) {
                    const n = Math.sin(.5 * t);
                    return this.x = e.x * n, this.y = e.y * n, this.z = e.z * n, this.w = Math.cos(.5 * t), this
                }
                toAxisAngle(e = new Vec3) {
                    this.normalize();
                    const t = 2 * Math.acos(this.w),
                        n = Math.sqrt(1 - this.w * this.w);
                    return n < .001 ? (e.x = this.x, e.y = this.y, e.z = this.z) : (e.x = this.x / n, e.y = this.y / n, e.z = this.z / n), [e, t]
                }
                setFromVectors(e, t) {
                    if (e.isAntiparallelTo(t)) {
                        const t = iu,
                            n = ru;
                        e.tangents(t, n), this.setFromAxisAngle(t, Math.PI)
                    } else {
                        const n = e.cross(t);
                        this.x = n.x, this.y = n.y, this.z = n.z, this.w = Math.sqrt(e.length() ** 2 * t.length() ** 2) + e.dot(t), this.normalize()
                    }
                    return this
                }
                mult(e, t = new cannon_es_Quaternion) {
                    const n = this.x,
                        i = this.y,
                        r = this.z,
                        a = this.w,
                        o = e.x,
                        s = e.y,
                        l = e.z,
                        c = e.w;
                    return t.x = n * c + a * o + i * l - r * s, t.y = i * c + a * s + r * o - n * l, t.z = r * c + a * l + n * s - i * o, t.w = a * c - n * o - i * s - r * l, t
                }
                inverse(e = new cannon_es_Quaternion) {
                    const t = this.x,
                        n = this.y,
                        i = this.z,
                        r = this.w;
                    this.conjugate(e);
                    const a = 1 / (t * t + n * n + i * i + r * r);
                    return e.x *= a, e.y *= a, e.z *= a, e.w *= a, e
                }
                conjugate(e = new cannon_es_Quaternion) {
                    return e.x = -this.x, e.y = -this.y, e.z = -this.z, e.w = this.w, e
                }
                normalize() {
                    let e = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
                    return 0 === e ? (this.x = 0, this.y = 0, this.z = 0, this.w = 0) : (e = 1 / e, this.x *= e, this.y *= e, this.z *= e, this.w *= e), this
                }
                normalizeFast() {
                    const e = (3 - (this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)) / 2;
                    return 0 === e ? (this.x = 0, this.y = 0, this.z = 0, this.w = 0) : (this.x *= e, this.y *= e, this.z *= e, this.w *= e), this
                }
                vmult(e, t = new Vec3) {
                    const n = e.x,
                        i = e.y,
                        r = e.z,
                        a = this.x,
                        o = this.y,
                        s = this.z,
                        l = this.w,
                        c = l * n + o * r - s * i,
                        u = l * i + s * n - a * r,
                        h = l * r + a * i - o * n,
                        d = -a * n - o * i - s * r;
                    return t.x = c * l + d * -a + u * -s - h * -o, t.y = u * l + d * -o + h * -a - c * -s, t.z = h * l + d * -s + c * -o - u * -a, t
                }
                copy(e) {
                    return this.x = e.x, this.y = e.y, this.z = e.z, this.w = e.w, this
                }
                toEuler(e, t = "YZX") {
                    let n, i, r;
                    const a = this.x,
                        o = this.y,
                        s = this.z,
                        l = this.w;
                    if ("YZX" !== t) throw Error("Euler order " + t + " not supported yet."); {
                        const e = a * o + s * l;
                        if (e > .499 && (n = 2 * Math.atan2(a, l), i = Math.PI / 2, r = 0), e < -.499 && (n = -2 * Math.atan2(a, l), i = -Math.PI / 2, r = 0), void 0 === n) {
                            const t = a * a,
                                c = s * s;
                            n = Math.atan2(2 * o * l - 2 * a * s, 1 - 2 * (o * o) - 2 * c), i = Math.asin(2 * e), r = Math.atan2(2 * a * l - 2 * o * s, 1 - 2 * t - 2 * c)
                        }
                    }
                    e.y = n, e.z = i, e.x = r
                }
                setFromEuler(e, t, n, i = "XYZ") {
                    const r = Math.cos(e / 2),
                        a = Math.cos(t / 2),
                        o = Math.cos(n / 2),
                        s = Math.sin(e / 2),
                        l = Math.sin(t / 2),
                        c = Math.sin(n / 2);
                    return "XYZ" === i ? (this.x = s * a * o + r * l * c, this.y = r * l * o - s * a * c, this.z = r * a * c + s * l * o, this.w = r * a * o - s * l * c) : "YXZ" === i ? (this.x = s * a * o + r * l * c, this.y = r * l * o - s * a * c, this.z = r * a * c - s * l * o, this.w = r * a * o + s * l * c) : "ZXY" === i ? (this.x = s * a * o - r * l * c, this.y = r * l * o + s * a * c, this.z = r * a * c + s * l * o, this.w = r * a * o - s * l * c) : "ZYX" === i ? (this.x = s * a * o - r * l * c, this.y = r * l * o + s * a * c, this.z = r * a * c - s * l * o, this.w = r * a * o + s * l * c) : "YZX" === i ? (this.x = s * a * o + r * l * c, this.y = r * l * o + s * a * c, this.z = r * a * c - s * l * o, this.w = r * a * o - s * l * c) : "XZY" === i && (this.x = s * a * o - r * l * c, this.y = r * l * o - s * a * c, this.z = r * a * c + s * l * o, this.w = r * a * o + s * l * c), this
                }
                clone() {
                    return new cannon_es_Quaternion(this.x, this.y, this.z, this.w)
                }
                slerp(e, t, n = new cannon_es_Quaternion) {
                    const i = this.x,
                        r = this.y,
                        a = this.z,
                        o = this.w;
                    let s, l, c, u, h, d = e.x,
                        p = e.y,
                        f = e.z,
                        m = e.w;
                    return l = i * d + r * p + a * f + o * m, l < 0 && (l = -l, d = -d, p = -p, f = -f, m = -m), 1 - l > 1e-6 ? (s = Math.acos(l), c = Math.sin(s), u = Math.sin((1 - t) * s) / c, h = Math.sin(t * s) / c) : (u = 1 - t, h = t), n.x = u * i + h * d, n.y = u * r + h * p, n.z = u * a + h * f, n.w = u * o + h * m, n
                }
                integrate(e, t, n, i = new cannon_es_Quaternion) {
                    const r = e.x * n.x,
                        a = e.y * n.y,
                        o = e.z * n.z,
                        s = this.x,
                        l = this.y,
                        c = this.z,
                        u = this.w,
                        h = .5 * t;
                    return i.x += h * (r * u + a * c - o * l), i.y += h * (a * u + o * s - r * c), i.z += h * (o * u + r * l - a * s), i.w += h * (-r * s - a * l - o * c), i
                }
            }
            const iu = new Vec3,
                ru = new Vec3;
            class cannon_es_Shape {
                constructor(e = {}) {
                    this.id = void 0, this.type = void 0, this.boundingSphereRadius = void 0, this.collisionResponse = void 0, this.collisionFilterGroup = void 0, this.collisionFilterMask = void 0, this.material = void 0, this.body = void 0, this.id = cannon_es_Shape.idCounter++, this.type = e.type || 0, this.boundingSphereRadius = 0, this.collisionResponse = !e.collisionResponse || e.collisionResponse, this.collisionFilterGroup = void 0 !== e.collisionFilterGroup ? e.collisionFilterGroup : 1, this.collisionFilterMask = void 0 !== e.collisionFilterMask ? e.collisionFilterMask : -1, this.material = e.material ? e.material : null, this.body = null
                }
                updateBoundingSphereRadius() {
                    throw "computeBoundingSphereRadius() not implemented for shape type " + this.type
                }
                volume() {
                    throw "volume() not implemented for shape type " + this.type
                }
                calculateLocalInertia(e, t) {
                    throw "calculateLocalInertia() not implemented for shape type " + this.type
                }
                calculateWorldAABB(e, t, n, i) {
                    throw "calculateWorldAABB() not implemented for shape type " + this.type
                }
            }
            cannon_es_Shape.idCounter = 0, cannon_es_Shape.types = {
                SPHERE: 1,
                PLANE: 2,
                BOX: 4,
                COMPOUND: 8,
                CONVEXPOLYHEDRON: 16,
                HEIGHTFIELD: 32,
                PARTICLE: 64,
                CYLINDER: 128,
                TRIMESH: 256
            };
            class Transform {
                constructor(e = {}) {
                    this.position = void 0, this.quaternion = void 0, this.position = new Vec3, this.quaternion = new cannon_es_Quaternion, e.position && this.position.copy(e.position), e.quaternion && this.quaternion.copy(e.quaternion)
                }
                pointToLocal(e, t) {
                    return Transform.pointToLocalFrame(this.position, this.quaternion, e, t)
                }
                pointToWorld(e, t) {
                    return Transform.pointToWorldFrame(this.position, this.quaternion, e, t)
                }
                vectorToWorldFrame(e, t = new Vec3) {
                    return this.quaternion.vmult(e, t), t
                }
                static pointToLocalFrame(e, t, n, i = new Vec3) {
                    return n.vsub(e, i), t.conjugate(au), au.vmult(i, i), i
                }
                static pointToWorldFrame(e, t, n, i = new Vec3) {
                    return t.vmult(n, i), i.vadd(e, i), i
                }
                static vectorToWorldFrame(e, t, n = new Vec3) {
                    return e.vmult(t, n), n
                }
                static vectorToLocalFrame(e, t, n, i = new Vec3) {
                    return t.w *= -1, t.vmult(n, i), t.w *= -1, i
                }
            }
            const au = new cannon_es_Quaternion;
            class ConvexPolyhedron extends cannon_es_Shape {
                constructor(e = {}) {
                    const {
                        vertices: t = [],
                        faces: n = [],
                        normals: i = [],
                        axes: r,
                        boundingSphereRadius: a
                    } = e;
                    super({
                        type: cannon_es_Shape.types.CONVEXPOLYHEDRON
                    }), this.vertices = void 0, this.faces = void 0, this.faceNormals = void 0, this.worldVertices = void 0, this.worldVerticesNeedsUpdate = void 0, this.worldFaceNormals = void 0, this.worldFaceNormalsNeedsUpdate = void 0, this.uniqueAxes = void 0, this.uniqueEdges = void 0, this.vertices = t, this.faces = n, this.faceNormals = i, 0 === this.faceNormals.length && this.computeNormals(), a ? this.boundingSphereRadius = a : this.updateBoundingSphereRadius(), this.worldVertices = [], this.worldVerticesNeedsUpdate = !0, this.worldFaceNormals = [], this.worldFaceNormalsNeedsUpdate = !0, this.uniqueAxes = r ? r.slice() : null, this.uniqueEdges = [], this.computeEdges()
                }
                computeEdges() {
                    const e = this.faces,
                        t = this.vertices,
                        n = this.uniqueEdges;
                    n.length = 0;
                    const i = new Vec3;
                    for (let r = 0; r !== e.length; r++) {
                        const a = e[r],
                            o = a.length;
                        for (let e = 0; e !== o; e++) {
                            const r = (e + 1) % o;
                            t[a[e]].vsub(t[a[r]], i), i.normalize();
                            let s = !1;
                            for (let e = 0; e !== n.length; e++)
                                if (n[e].almostEquals(i) || n[e].almostEquals(i)) {
                                    s = !0;
                                    break
                                }
                            s || n.push(i.clone())
                        }
                    }
                }
                computeNormals() {
                    this.faceNormals.length = this.faces.length;
                    for (let e = 0; e < this.faces.length; e++) {
                        for (let t = 0; t < this.faces[e].length; t++)
                            if (!this.vertices[this.faces[e][t]]) throw Error("Vertex " + this.faces[e][t] + " not found!");
                        const t = this.faceNormals[e] || new Vec3;
                        this.getFaceNormal(e, t), t.negate(t), this.faceNormals[e] = t;
                        const n = this.vertices[this.faces[e][0]];
                        if (t.dot(n) < 0)
                            for (let t = 0; t < this.faces[e].length; t++);
                    }
                }
                getFaceNormal(e, t) {
                    const n = this.faces[e],
                        i = this.vertices[n[0]],
                        r = this.vertices[n[1]],
                        a = this.vertices[n[2]];
                    ConvexPolyhedron.computeNormal(i, r, a, t)
                }
                static computeNormal(e, t, n, i) {
                    const r = new Vec3,
                        a = new Vec3;
                    t.vsub(e, a), n.vsub(t, r), r.cross(a, i), i.isZero() || i.normalize()
                }
                clipAgainstHull(e, t, n, i, r, a, o, s, l) {
                    const c = new Vec3;
                    let u = -1,
                        h = -Number.MAX_VALUE;
                    for (let e = 0; e < n.faces.length; e++) {
                        c.copy(n.faceNormals[e]), r.vmult(c, c);
                        const t = c.dot(a);
                        t > h && (h = t, u = e)
                    }
                    const d = [];
                    for (let e = 0; e < n.faces[u].length; e++) {
                        const t = n.vertices[n.faces[u][e]],
                            a = new Vec3;
                        a.copy(t), r.vmult(a, a), i.vadd(a, a), d.push(a)
                    }
                    u >= 0 && this.clipFaceAgainstHull(a, e, t, d, o, s, l)
                }
                findSeparatingAxis(e, t, n, i, r, a, o, s) {
                    const l = new Vec3,
                        c = new Vec3,
                        u = new Vec3,
                        h = new Vec3,
                        d = new Vec3,
                        p = new Vec3;
                    let f = Number.MAX_VALUE;
                    const m = this;
                    if (m.uniqueAxes)
                        for (let o = 0; o !== m.uniqueAxes.length; o++) {
                            n.vmult(m.uniqueAxes[o], l);
                            const s = m.testSepAxis(l, e, t, n, i, r);
                            if (!1 === s) return !1;
                            s < f && (f = s, a.copy(l))
                        } else {
                            const s = o ? o.length : m.faces.length;
                            for (let c = 0; c < s; c++) {
                                const s = o ? o[c] : c;
                                l.copy(m.faceNormals[s]), n.vmult(l, l);
                                const u = m.testSepAxis(l, e, t, n, i, r);
                                if (!1 === u) return !1;
                                u < f && (f = u, a.copy(l))
                            }
                        }
                    if (e.uniqueAxes)
                        for (let o = 0; o !== e.uniqueAxes.length; o++) {
                            r.vmult(e.uniqueAxes[o], c);
                            const s = m.testSepAxis(c, e, t, n, i, r);
                            if (!1 === s) return !1;
                            s < f && (f = s, a.copy(c))
                        } else {
                            const o = s ? s.length : e.faces.length;
                            for (let l = 0; l < o; l++) {
                                const o = s ? s[l] : l;
                                c.copy(e.faceNormals[o]), r.vmult(c, c);
                                const u = m.testSepAxis(c, e, t, n, i, r);
                                if (!1 === u) return !1;
                                u < f && (f = u, a.copy(c))
                            }
                        }
                    for (let o = 0; o !== m.uniqueEdges.length; o++) {
                        n.vmult(m.uniqueEdges[o], h);
                        for (let o = 0; o !== e.uniqueEdges.length; o++)
                            if (r.vmult(e.uniqueEdges[o], d), h.cross(d, p), !p.almostZero()) {
                                p.normalize();
                                const o = m.testSepAxis(p, e, t, n, i, r);
                                if (!1 === o) return !1;
                                o < f && (f = o, a.copy(p))
                            }
                    }
                    return i.vsub(t, u), u.dot(a) > 0 && a.negate(a), !0
                }
                testSepAxis(e, t, n, i, r, a) {
                    ConvexPolyhedron.project(this, e, n, i, ou), ConvexPolyhedron.project(t, e, r, a, su);
                    const o = ou[0],
                        s = ou[1],
                        l = su[0],
                        c = su[1];
                    if (o < c || l < s) return !1;
                    const u = o - c,
                        h = l - s;
                    return u < h ? u : h
                }
                calculateLocalInertia(e, t) {
                    const n = new Vec3,
                        i = new Vec3;
                    this.computeLocalAABB(i, n);
                    const r = n.x - i.x,
                        a = n.y - i.y,
                        o = n.z - i.z;
                    t.x = 1 / 12 * e * (2 * a * 2 * a + 2 * o * 2 * o), t.y = 1 / 12 * e * (2 * r * 2 * r + 2 * o * 2 * o), t.z = 1 / 12 * e * (2 * a * 2 * a + 2 * r * 2 * r)
                }
                getPlaneConstantOfFace(e) {
                    const t = this.faces[e],
                        n = this.faceNormals[e],
                        i = this.vertices[t[0]];
                    return -n.dot(i)
                }
                clipFaceAgainstHull(e, t, n, i, r, a, o) {
                    const s = new Vec3,
                        l = new Vec3,
                        c = new Vec3,
                        u = new Vec3,
                        h = new Vec3,
                        d = new Vec3,
                        p = new Vec3,
                        f = new Vec3,
                        m = this,
                        g = i,
                        y = [];
                    let x = -1,
                        _ = Number.MAX_VALUE;
                    for (let t = 0; t < m.faces.length; t++) {
                        s.copy(m.faceNormals[t]), n.vmult(s, s);
                        const i = s.dot(e);
                        i < _ && (_ = i, x = t)
                    }
                    if (x < 0) return;
                    const b = m.faces[x];
                    b.connectedFaces = [];
                    for (let e = 0; e < m.faces.length; e++)
                        for (let t = 0; t < m.faces[e].length; t++) - 1 !== b.indexOf(m.faces[e][t]) && e !== x && -1 === b.connectedFaces.indexOf(e) && b.connectedFaces.push(e);
                    const M = b.length;
                    for (let e = 0; e < M; e++) {
                        const i = m.vertices[b[e]],
                            r = m.vertices[b[(e + 1) % M]];
                        i.vsub(r, l), c.copy(l), n.vmult(c, c), t.vadd(c, c), u.copy(this.faceNormals[x]), n.vmult(u, u), t.vadd(u, u), c.cross(u, h), h.negate(h), d.copy(i), n.vmult(d, d), t.vadd(d, d);
                        const a = b.connectedFaces[e];
                        p.copy(this.faceNormals[a]);
                        const o = this.getPlaneConstantOfFace(a);
                        f.copy(p), n.vmult(f, f);
                        const s = o - f.dot(t);
                        for (this.clipFaceAgainstPlane(g, y, f, s); g.length;) g.shift();
                        for (; y.length;) g.push(y.shift())
                    }
                    p.copy(this.faceNormals[x]);
                    const S = this.getPlaneConstantOfFace(x);
                    f.copy(p), n.vmult(f, f);
                    const A = S - f.dot(t);
                    for (let e = 0; e < g.length; e++) {
                        let t = f.dot(g[e]) + A;
                        if (t <= r && (t = r), t <= a) {
                            const n = g[e];
                            if (t <= 1e-6) {
                                const e = {
                                    point: n,
                                    normal: f,
                                    depth: t
                                };
                                o.push(e)
                            }
                        }
                    }
                }
                clipFaceAgainstPlane(e, t, n, i) {
                    let r, a;
                    const o = e.length;
                    if (o < 2) return t;
                    let s = e[e.length - 1],
                        l = e[0];
                    r = n.dot(s) + i;
                    for (let c = 0; c < o; c++) {
                        if (l = e[c], a = n.dot(l) + i, r < 0)
                            if (a < 0) {
                                const e = new Vec3;
                                e.copy(l), t.push(e)
                            } else {
                                const e = new Vec3;
                                s.lerp(l, r / (r - a), e), t.push(e)
                            }
                        else if (a < 0) {
                            const e = new Vec3;
                            s.lerp(l, r / (r - a), e), t.push(e), t.push(l)
                        }
                        s = l, r = a
                    }
                    return t
                }
                computeWorldVertices(e, t) {
                    for (; this.worldVertices.length < this.vertices.length;) this.worldVertices.push(new Vec3);
                    const n = this.vertices,
                        i = this.worldVertices;
                    for (let r = 0; r !== this.vertices.length; r++) t.vmult(n[r], i[r]), e.vadd(i[r], i[r]);
                    this.worldVerticesNeedsUpdate = !1
                }
                computeLocalAABB(e, t) {
                    const n = this.vertices;
                    e.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), t.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
                    for (let i = 0; i < this.vertices.length; i++) {
                        const r = n[i];
                        r.x < e.x ? e.x = r.x : r.x > t.x && (t.x = r.x), r.y < e.y ? e.y = r.y : r.y > t.y && (t.y = r.y), r.z < e.z ? e.z = r.z : r.z > t.z && (t.z = r.z)
                    }
                }
                computeWorldFaceNormals(e) {
                    const t = this.faceNormals.length;
                    for (; this.worldFaceNormals.length < t;) this.worldFaceNormals.push(new Vec3);
                    const n = this.faceNormals,
                        i = this.worldFaceNormals;
                    for (let r = 0; r !== t; r++) e.vmult(n[r], i[r]);
                    this.worldFaceNormalsNeedsUpdate = !1
                }
                updateBoundingSphereRadius() {
                    let e = 0;
                    const t = this.vertices;
                    for (let n = 0; n !== t.length; n++) {
                        const i = t[n].lengthSquared();
                        i > e && (e = i)
                    }
                    this.boundingSphereRadius = Math.sqrt(e)
                }
                calculateWorldAABB(e, t, n, i) {
                    const r = this.vertices;
                    let a, o, s, l, c, u, h = new Vec3;
                    for (let n = 0; n < r.length; n++) {
                        h.copy(r[n]), t.vmult(h, h), e.vadd(h, h);
                        const i = h;
                        (void 0 === a || i.x < a) && (a = i.x), (void 0 === l || i.x > l) && (l = i.x), (void 0 === o || i.y < o) && (o = i.y), (void 0 === c || i.y > c) && (c = i.y), (void 0 === s || i.z < s) && (s = i.z), (void 0 === u || i.z > u) && (u = i.z)
                    }
                    n.set(a, o, s), i.set(l, c, u)
                }
                volume() {
                    return 4 * Math.PI * this.boundingSphereRadius / 3
                }
                getAveragePointLocal(e = new Vec3) {
                    const t = this.vertices;
                    for (let n = 0; n < t.length; n++) e.vadd(t[n], e);
                    return e.scale(1 / t.length, e), e
                }
                transformAllPoints(e, t) {
                    const n = this.vertices.length,
                        i = this.vertices;
                    if (t) {
                        for (let e = 0; e < n; e++) {
                            const n = i[e];
                            t.vmult(n, n)
                        }
                        for (let e = 0; e < this.faceNormals.length; e++) {
                            const n = this.faceNormals[e];
                            t.vmult(n, n)
                        }
                    }
                    if (e)
                        for (let t = 0; t < n; t++) {
                            const n = i[t];
                            n.vadd(e, n)
                        }
                }
                pointIsInside(e) {
                    const t = this.vertices,
                        n = this.faces,
                        i = this.faceNormals,
                        r = new Vec3;
                    this.getAveragePointLocal(r);
                    for (let a = 0; a < this.faces.length; a++) {
                        let o = i[a];
                        const s = t[n[a][0]],
                            l = new Vec3;
                        e.vsub(s, l);
                        const c = o.dot(l),
                            u = new Vec3;
                        r.vsub(s, u);
                        const h = o.dot(u);
                        if (c < 0 && h > 0 || c > 0 && h < 0) return !1
                    }
                    return -1
                }
                static project(e, t, n, i, r) {
                    const a = e.vertices.length,
                        o = lu;
                    let s = 0,
                        l = 0;
                    const c = cu,
                        u = e.vertices;
                    c.setZero(), Transform.vectorToLocalFrame(n, i, t, o), Transform.pointToLocalFrame(n, i, c, c);
                    const h = c.dot(o);
                    l = s = u[0].dot(o);
                    for (let e = 1; e < a; e++) {
                        const t = u[e].dot(o);
                        t > s && (s = t), t < l && (l = t)
                    }
                    if (l -= h, s -= h, l > s) {
                        const e = l;
                        l = s, s = e
                    }
                    r[0] = s, r[1] = l
                }
            }
            const ou = [],
                su = [],
                lu = new Vec3,
                cu = new Vec3;
            class Box extends cannon_es_Shape {
                constructor(e) {
                    super({
                        type: cannon_es_Shape.types.BOX
                    }), this.halfExtents = void 0, this.convexPolyhedronRepresentation = void 0, this.halfExtents = e, this.convexPolyhedronRepresentation = null, this.updateConvexPolyhedronRepresentation(), this.updateBoundingSphereRadius()
                }
                updateConvexPolyhedronRepresentation() {
                    const e = this.halfExtents.x,
                        t = this.halfExtents.y,
                        n = this.halfExtents.z,
                        i = Vec3,
                        r = [new i(-e, -t, -n), new i(e, -t, -n), new i(e, t, -n), new i(-e, t, -n), new i(-e, -t, n), new i(e, -t, n), new i(e, t, n), new i(-e, t, n)],
                        a = [new i(0, 0, 1), new i(0, 1, 0), new i(1, 0, 0)],
                        o = new ConvexPolyhedron({
                            vertices: r,
                            faces: [
                                [3, 2, 1, 0],
                                [4, 5, 6, 7],
                                [5, 4, 0, 1],
                                [2, 3, 7, 6],
                                [0, 4, 7, 3],
                                [1, 2, 6, 5]
                            ],
                            axes: a
                        });
                    this.convexPolyhedronRepresentation = o, o.material = this.material
                }
                calculateLocalInertia(e, t = new Vec3) {
                    return Box.calculateInertia(this.halfExtents, e, t), t
                }
                static calculateInertia(e, t, n) {
                    const i = e;
                    n.x = 1 / 12 * t * (2 * i.y * 2 * i.y + 2 * i.z * 2 * i.z), n.y = 1 / 12 * t * (2 * i.x * 2 * i.x + 2 * i.z * 2 * i.z), n.z = 1 / 12 * t * (2 * i.y * 2 * i.y + 2 * i.x * 2 * i.x)
                }
                getSideNormals(e, t) {
                    const n = e,
                        i = this.halfExtents;
                    if (n[0].set(i.x, 0, 0), n[1].set(0, i.y, 0), n[2].set(0, 0, i.z), n[3].set(-i.x, 0, 0), n[4].set(0, -i.y, 0), n[5].set(0, 0, -i.z), void 0 !== t)
                        for (let e = 0; e !== n.length; e++) t.vmult(n[e], n[e]);
                    return n
                }
                volume() {
                    return 8 * this.halfExtents.x * this.halfExtents.y * this.halfExtents.z
                }
                updateBoundingSphereRadius() {
                    this.boundingSphereRadius = this.halfExtents.length()
                }
                forEachWorldCorner(e, t, n) {
                    const i = this.halfExtents,
                        r = [
                            [i.x, i.y, i.z],
                            [-i.x, i.y, i.z],
                            [-i.x, -i.y, i.z],
                            [-i.x, -i.y, -i.z],
                            [i.x, -i.y, -i.z],
                            [i.x, i.y, -i.z],
                            [-i.x, i.y, -i.z],
                            [i.x, -i.y, i.z]
                        ];
                    for (let i = 0; i < r.length; i++) uu.set(r[i][0], r[i][1], r[i][2]), t.vmult(uu, uu), e.vadd(uu, uu), n(uu.x, uu.y, uu.z)
                }
                calculateWorldAABB(e, t, n, i) {
                    const r = this.halfExtents;
                    hu[0].set(r.x, r.y, r.z), hu[1].set(-r.x, r.y, r.z), hu[2].set(-r.x, -r.y, r.z), hu[3].set(-r.x, -r.y, -r.z), hu[4].set(r.x, -r.y, -r.z), hu[5].set(r.x, r.y, -r.z), hu[6].set(-r.x, r.y, -r.z), hu[7].set(r.x, -r.y, r.z);
                    const a = hu[0];
                    t.vmult(a, a), e.vadd(a, a), i.copy(a), n.copy(a);
                    for (let r = 1; r < 8; r++) {
                        const a = hu[r];
                        t.vmult(a, a), e.vadd(a, a);
                        const o = a.x,
                            s = a.y,
                            l = a.z;
                        o > i.x && (i.x = o), s > i.y && (i.y = s), l > i.z && (i.z = l), o < n.x && (n.x = o), s < n.y && (n.y = s), l < n.z && (n.z = l)
                    }
                }
            }
            const uu = new Vec3,
                hu = [new Vec3, new Vec3, new Vec3, new Vec3, new Vec3, new Vec3, new Vec3, new Vec3],
                du = 1,
                pu = 2,
                fu = 4,
                mu = 0,
                gu = 1,
                vu = 2;
            class Body extends EventTarget {
                constructor(e = {}) {
                    super(), this.id = void 0, this.index = void 0, this.world = void 0, this.preStep = void 0, this.postStep = void 0, this.vlambda = void 0, this.collisionFilterGroup = void 0, this.collisionFilterMask = void 0, this.collisionResponse = void 0, this.position = void 0, this.previousPosition = void 0, this.interpolatedPosition = void 0, this.initPosition = void 0, this.velocity = void 0, this.initVelocity = void 0, this.force = void 0, this.mass = void 0, this.invMass = void 0, this.material = void 0, this.linearDamping = void 0, this.type = void 0, this.allowSleep = void 0, this.sleepState = void 0, this.sleepSpeedLimit = void 0, this.sleepTimeLimit = void 0, this.timeLastSleepy = void 0, this.wakeUpAfterNarrowphase = void 0, this.torque = void 0, this.quaternion = void 0, this.initQuaternion = void 0, this.previousQuaternion = void 0, this.interpolatedQuaternion = void 0, this.angularVelocity = void 0, this.initAngularVelocity = void 0, this.shapes = void 0, this.shapeOffsets = void 0, this.shapeOrientations = void 0, this.inertia = void 0, this.invInertia = void 0, this.invInertiaWorld = void 0, this.invMassSolve = void 0, this.invInertiaSolve = void 0, this.invInertiaWorldSolve = void 0, this.fixedRotation = void 0, this.angularDamping = void 0, this.linearFactor = void 0, this.angularFactor = void 0, this.aabb = void 0, this.aabbNeedsUpdate = void 0, this.boundingRadius = void 0, this.wlambda = void 0, this.isTrigger = void 0, this.id = Body.idCounter++, this.index = -1, this.world = null, this.preStep = null, this.postStep = null, this.vlambda = new Vec3, this.collisionFilterGroup = "number" == typeof e.collisionFilterGroup ? e.collisionFilterGroup : 1, this.collisionFilterMask = "number" == typeof e.collisionFilterMask ? e.collisionFilterMask : -1, this.collisionResponse = "boolean" != typeof e.collisionResponse || e.collisionResponse, this.position = new Vec3, this.previousPosition = new Vec3, this.interpolatedPosition = new Vec3, this.initPosition = new Vec3, e.position && (this.position.copy(e.position), this.previousPosition.copy(e.position), this.interpolatedPosition.copy(e.position), this.initPosition.copy(e.position)), this.velocity = new Vec3, e.velocity && this.velocity.copy(e.velocity), this.initVelocity = new Vec3, this.force = new Vec3;
                    const t = "number" == typeof e.mass ? e.mass : 0;
                    this.mass = t, this.invMass = t > 0 ? 1 / t : 0, this.material = e.material || null, this.linearDamping = "number" == typeof e.linearDamping ? e.linearDamping : .01, this.type = t <= 0 ? Body.STATIC : Body.DYNAMIC, typeof e.type == typeof Body.STATIC && (this.type = e.type), this.allowSleep = void 0 === e.allowSleep || e.allowSleep, this.sleepState = Body.AWAKE, this.sleepSpeedLimit = void 0 !== e.sleepSpeedLimit ? e.sleepSpeedLimit : .1, this.sleepTimeLimit = void 0 !== e.sleepTimeLimit ? e.sleepTimeLimit : 1, this.timeLastSleepy = 0, this.wakeUpAfterNarrowphase = !1, this.torque = new Vec3, this.quaternion = new cannon_es_Quaternion, this.initQuaternion = new cannon_es_Quaternion, this.previousQuaternion = new cannon_es_Quaternion, this.interpolatedQuaternion = new cannon_es_Quaternion, e.quaternion && (this.quaternion.copy(e.quaternion), this.initQuaternion.copy(e.quaternion), this.previousQuaternion.copy(e.quaternion), this.interpolatedQuaternion.copy(e.quaternion)), this.angularVelocity = new Vec3, e.angularVelocity && this.angularVelocity.copy(e.angularVelocity), this.initAngularVelocity = new Vec3, this.shapes = [], this.shapeOffsets = [], this.shapeOrientations = [], this.inertia = new Vec3, this.invInertia = new Vec3, this.invInertiaWorld = new Mat3, this.invMassSolve = 0, this.invInertiaSolve = new Vec3, this.invInertiaWorldSolve = new Mat3, this.fixedRotation = void 0 !== e.fixedRotation && e.fixedRotation, this.angularDamping = void 0 !== e.angularDamping ? e.angularDamping : .01, this.linearFactor = new Vec3(1, 1, 1), e.linearFactor && this.linearFactor.copy(e.linearFactor), this.angularFactor = new Vec3(1, 1, 1), e.angularFactor && this.angularFactor.copy(e.angularFactor), this.aabb = new AABB, this.aabbNeedsUpdate = !0, this.boundingRadius = 0, this.wlambda = new Vec3, this.isTrigger = !!e.isTrigger, e.shape && this.addShape(e.shape), this.updateMassProperties()
                }
                wakeUp() {
                    const e = this.sleepState;
                    this.sleepState = Body.AWAKE, this.wakeUpAfterNarrowphase = !1, e === Body.SLEEPING && this.dispatchEvent(Body.wakeupEvent)
                }
                sleep() {
                    this.sleepState = Body.SLEEPING, this.velocity.set(0, 0, 0), this.angularVelocity.set(0, 0, 0), this.wakeUpAfterNarrowphase = !1
                }
                sleepTick(e) {
                    if (this.allowSleep) {
                        const t = this.sleepState,
                            n = this.velocity.lengthSquared() + this.angularVelocity.lengthSquared(),
                            i = this.sleepSpeedLimit ** 2;
                        t === Body.AWAKE && n < i ? (this.sleepState = Body.SLEEPY, this.timeLastSleepy = e, this.dispatchEvent(Body.sleepyEvent)) : t === Body.SLEEPY && n > i ? this.wakeUp() : t === Body.SLEEPY && e - this.timeLastSleepy > this.sleepTimeLimit && (this.sleep(), this.dispatchEvent(Body.sleepEvent))
                    }
                }
                updateSolveMassProperties() {
                    this.sleepState === Body.SLEEPING || this.type === Body.KINEMATIC ? (this.invMassSolve = 0, this.invInertiaSolve.setZero(), this.invInertiaWorldSolve.setZero()) : (this.invMassSolve = this.invMass, this.invInertiaSolve.copy(this.invInertia), this.invInertiaWorldSolve.copy(this.invInertiaWorld))
                }
                pointToLocalFrame(e, t = new Vec3) {
                    return e.vsub(this.position, t), this.quaternion.conjugate().vmult(t, t), t
                }
                vectorToLocalFrame(e, t = new Vec3) {
                    return this.quaternion.conjugate().vmult(e, t), t
                }
                pointToWorldFrame(e, t = new Vec3) {
                    return this.quaternion.vmult(e, t), t.vadd(this.position, t), t
                }
                vectorToWorldFrame(e, t = new Vec3) {
                    return this.quaternion.vmult(e, t), t
                }
                addShape(e, t, n) {
                    const i = new Vec3,
                        r = new cannon_es_Quaternion;
                    return t && i.copy(t), n && r.copy(n), this.shapes.push(e), this.shapeOffsets.push(i), this.shapeOrientations.push(r), this.updateMassProperties(), this.updateBoundingRadius(), this.aabbNeedsUpdate = !0, e.body = this, this
                }
                removeShape(e) {
                    const t = this.shapes.indexOf(e);
                    return -1 === t || (this.shapes.splice(t, 1), this.shapeOffsets.splice(t, 1), this.shapeOrientations.splice(t, 1), this.updateMassProperties(), this.updateBoundingRadius(), this.aabbNeedsUpdate = !0, e.body = null), this
                }
                updateBoundingRadius() {
                    const e = this.shapes,
                        t = this.shapeOffsets,
                        n = e.length;
                    let i = 0;
                    for (let r = 0; r !== n; r++) {
                        const n = e[r];
                        n.updateBoundingSphereRadius();
                        const a = t[r].length(),
                            o = n.boundingSphereRadius;
                        a + o > i && (i = a + o)
                    }
                    this.boundingRadius = i
                }
                updateAABB() {
                    const e = this.shapes,
                        t = this.shapeOffsets,
                        n = this.shapeOrientations,
                        i = e.length,
                        r = yu,
                        a = xu,
                        o = this.quaternion,
                        s = this.aabb,
                        l = _u;
                    for (let c = 0; c !== i; c++) {
                        const i = e[c];
                        o.vmult(t[c], r), r.vadd(this.position, r), o.mult(n[c], a), i.calculateWorldAABB(r, a, l.lowerBound, l.upperBound), 0 === c ? s.copy(l) : s.extend(l)
                    }
                    this.aabbNeedsUpdate = !1
                }
                updateInertiaWorld(e) {
                    const t = this.invInertia;
                    if (t.x !== t.y || t.y !== t.z || e) {
                        const e = bu,
                            n = Mu;
                        e.setRotationFromQuaternion(this.quaternion), e.transpose(n), e.scale(t, e), e.mmult(n, this.invInertiaWorld)
                    } else;
                }
                applyForce(e, t = new Vec3) {
                    if (this.type !== Body.DYNAMIC) return;
                    this.sleepState === Body.SLEEPING && this.wakeUp();
                    const n = Su;
                    t.cross(e, n), this.force.vadd(e, this.force), this.torque.vadd(n, this.torque)
                }
                applyLocalForce(e, t = new Vec3) {
                    if (this.type !== Body.DYNAMIC) return;
                    const n = Au,
                        i = wu;
                    this.vectorToWorldFrame(e, n), this.vectorToWorldFrame(t, i), this.applyForce(n, i)
                }
                applyTorque(e) {
                    this.type === Body.DYNAMIC && (this.sleepState === Body.SLEEPING && this.wakeUp(), this.torque.vadd(e, this.torque))
                }
                applyImpulse(e, t = new Vec3) {
                    if (this.type !== Body.DYNAMIC) return;
                    this.sleepState === Body.SLEEPING && this.wakeUp();
                    const n = t,
                        i = Tu;
                    i.copy(e), i.scale(this.invMass, i), this.velocity.vadd(i, this.velocity);
                    const r = Lu;
                    n.cross(e, r), this.invInertiaWorld.vmult(r, r), this.angularVelocity.vadd(r, this.angularVelocity)
                }
                applyLocalImpulse(e, t = new Vec3) {
                    if (this.type !== Body.DYNAMIC) return;
                    const n = Cu,
                        i = Pu;
                    this.vectorToWorldFrame(e, n), this.vectorToWorldFrame(t, i), this.applyImpulse(n, i)
                }
                updateMassProperties() {
                    const e = Eu;
                    this.invMass = this.mass > 0 ? 1 / this.mass : 0;
                    const t = this.inertia,
                        n = this.fixedRotation;
                    this.updateAABB(), e.set((this.aabb.upperBound.x - this.aabb.lowerBound.x) / 2, (this.aabb.upperBound.y - this.aabb.lowerBound.y) / 2, (this.aabb.upperBound.z - this.aabb.lowerBound.z) / 2), Box.calculateInertia(e, this.mass, t), this.invInertia.set(t.x > 0 && !n ? 1 / t.x : 0, t.y > 0 && !n ? 1 / t.y : 0, t.z > 0 && !n ? 1 / t.z : 0), this.updateInertiaWorld(!0)
                }
                getVelocityAtWorldPoint(e, t) {
                    const n = new Vec3;
                    return e.vsub(this.position, n), this.angularVelocity.cross(n, t), this.velocity.vadd(t, t), t
                }
                integrate(e, t, n) {
                    if (this.previousPosition.copy(this.position), this.previousQuaternion.copy(this.quaternion), this.type !== Body.DYNAMIC && this.type !== Body.KINEMATIC || this.sleepState === Body.SLEEPING) return;
                    const i = this.velocity,
                        r = this.angularVelocity,
                        a = this.position,
                        o = this.force,
                        s = this.torque,
                        l = this.quaternion,
                        c = this.invMass,
                        u = this.invInertiaWorld,
                        h = this.linearFactor,
                        d = c * e;
                    i.x += o.x * d * h.x, i.y += o.y * d * h.y, i.z += o.z * d * h.z;
                    const p = u.elements,
                        f = this.angularFactor,
                        m = s.x * f.x,
                        g = s.y * f.y,
                        y = s.z * f.z;
                    r.x += e * (p[0] * m + p[1] * g + p[2] * y), r.y += e * (p[3] * m + p[4] * g + p[5] * y), r.z += e * (p[6] * m + p[7] * g + p[8] * y), a.x += i.x * e, a.y += i.y * e, a.z += i.z * e, l.integrate(this.angularVelocity, e, this.angularFactor, l), t && (n ? l.normalizeFast() : l.normalize()), this.aabbNeedsUpdate = !0, this.updateInertiaWorld()
                }
            }
            Body.idCounter = 0, Body.COLLIDE_EVENT_NAME = "collide", Body.DYNAMIC = du, Body.STATIC = pu, Body.KINEMATIC = fu, Body.AWAKE = mu, Body.SLEEPY = gu, Body.SLEEPING = vu, Body.wakeupEvent = {
                type: "wakeup"
            }, Body.sleepyEvent = {
                type: "sleepy"
            }, Body.sleepEvent = {
                type: "sleep"
            };
            const yu = new Vec3,
                xu = new cannon_es_Quaternion,
                _u = new AABB,
                bu = new Mat3,
                Mu = new Mat3,
                Su = new Vec3,
                Au = new Vec3,
                wu = new Vec3,
                Tu = new Vec3,
                Lu = new Vec3,
                Cu = new Vec3,
                Pu = new Vec3,
                Eu = new Vec3;
            new Vec3;
            new Vec3;
            class RaycastResult {
                constructor() {
                    this.rayFromWorld = void 0, this.rayToWorld = void 0, this.hitNormalWorld = void 0, this.hitPointWorld = void 0, this.hasHit = void 0, this.shape = void 0, this.body = void 0, this.hitFaceIndex = void 0, this.distance = void 0, this.shouldStop = void 0, this.rayFromWorld = new Vec3, this.rayToWorld = new Vec3, this.hitNormalWorld = new Vec3, this.hitPointWorld = new Vec3, this.hasHit = !1, this.shape = null, this.body = null, this.hitFaceIndex = -1, this.distance = -1, this.shouldStop = !1
                }
                reset() {
                    this.rayFromWorld.setZero(), this.rayToWorld.setZero(), this.hitNormalWorld.setZero(), this.hitPointWorld.setZero(), this.hasHit = !1, this.shape = null, this.body = null, this.hitFaceIndex = -1, this.distance = -1, this.shouldStop = !1
                }
                abort() {
                    this.shouldStop = !0
                }
                set(e, t, n, i, r, a, o) {
                    this.rayFromWorld.copy(e), this.rayToWorld.copy(t), this.hitNormalWorld.copy(n), this.hitPointWorld.copy(i), this.shape = r, this.body = a, this.distance = o
                }
            }
            let Iu, Fu, Ou, Bu, Ru, Nu, Du;
            const Vu = 1,
                Uu = 2,
                zu = 4;
            Iu = cannon_es_Shape.types.SPHERE, Fu = cannon_es_Shape.types.PLANE, Ou = cannon_es_Shape.types.BOX, Bu = cannon_es_Shape.types.CYLINDER, Ru = cannon_es_Shape.types.CONVEXPOLYHEDRON, Nu = cannon_es_Shape.types.HEIGHTFIELD, Du = cannon_es_Shape.types.TRIMESH;
            class cannon_es_Ray {
                get[Iu]() {
                    return this._intersectSphere
                }
                get[Fu]() {
                    return this._intersectPlane
                }
                get[Ou]() {
                    return this._intersectBox
                }
                get[Bu]() {
                    return this._intersectConvex
                }
                get[Ru]() {
                    return this._intersectConvex
                }
                get[Nu]() {
                    return this._intersectHeightfield
                }
                get[Du]() {
                    return this._intersectTrimesh
                }
                constructor(e = new Vec3, t = new Vec3) {
                    this.from = void 0, this.to = void 0, this.direction = void 0, this.precision = void 0, this.checkCollisionResponse = void 0, this.skipBackfaces = void 0, this.collisionFilterMask = void 0, this.collisionFilterGroup = void 0, this.mode = void 0, this.result = void 0, this.hasHit = void 0, this.callback = void 0, this.from = e.clone(), this.to = t.clone(), this.direction = new Vec3, this.precision = 1e-4, this.checkCollisionResponse = !0, this.skipBackfaces = !1, this.collisionFilterMask = -1, this.collisionFilterGroup = -1, this.mode = cannon_es_Ray.ANY, this.result = new RaycastResult, this.hasHit = !1, this.callback = e => {}
                }
                intersectWorld(e, t) {
                    return this.mode = t.mode || cannon_es_Ray.ANY, this.result = t.result || new RaycastResult, this.skipBackfaces = !!t.skipBackfaces, this.collisionFilterMask = void 0 !== t.collisionFilterMask ? t.collisionFilterMask : -1, this.collisionFilterGroup = void 0 !== t.collisionFilterGroup ? t.collisionFilterGroup : -1, this.checkCollisionResponse = void 0 === t.checkCollisionResponse || t.checkCollisionResponse, t.from && this.from.copy(t.from), t.to && this.to.copy(t.to), this.callback = t.callback || (() => {}), this.hasHit = !1, this.result.reset(), this.updateDirection(), this.getAABB(Gu), ku.length = 0, e.broadphase.aabbQuery(e, Gu, ku), this.intersectBodies(ku), this.hasHit
                }
                intersectBody(e, t) {
                    t && (this.result = t, this.updateDirection());
                    const n = this.checkCollisionResponse;
                    if (n && !e.collisionResponse) return;
                    if (0 == (this.collisionFilterGroup & e.collisionFilterMask) || 0 == (e.collisionFilterGroup & this.collisionFilterMask)) return;
                    const i = Hu,
                        r = Xu;
                    for (let t = 0, a = e.shapes.length; t < a; t++) {
                        const a = e.shapes[t];
                        if ((!n || a.collisionResponse) && (e.quaternion.mult(e.shapeOrientations[t], r), e.quaternion.vmult(e.shapeOffsets[t], i), i.vadd(e.position, i), this.intersectShape(a, r, i, e), this.result.shouldStop)) break
                    }
                }
                intersectBodies(e, t) {
                    t && (this.result = t, this.updateDirection());
                    for (let t = 0, n = e.length; !this.result.shouldStop && t < n; t++) this.intersectBody(e[t])
                }
                updateDirection() {
                    this.to.vsub(this.from, this.direction), this.direction.normalize()
                }
                intersectShape(e, t, n, i) {
                    const r = function distanceFromIntersection(e, t, n) {
                        n.vsub(e, ph);
                        const i = ph.dot(t);
                        return t.scale(i, fh), fh.vadd(e, fh), n.distanceTo(fh)
                    }(this.from, this.direction, n);
                    if (r > e.boundingSphereRadius) return;
                    const a = this[e.type];
                    a && a.call(this, e, t, n, i, e)
                }
                _intersectBox(e, t, n, i, r) {
                    return this._intersectConvex(e.convexPolyhedronRepresentation, t, n, i, r)
                }
                _intersectPlane(e, t, n, i, r) {
                    const a = this.from,
                        o = this.to,
                        s = this.direction,
                        l = new Vec3(0, 0, 1);
                    t.vmult(l, l);
                    const c = new Vec3;
                    a.vsub(n, c);
                    const u = c.dot(l);
                    o.vsub(n, c);
                    if (u * c.dot(l) > 0) return;
                    if (a.distanceTo(o) < u) return;
                    const h = l.dot(s);
                    if (Math.abs(h) < this.precision) return;
                    const d = new Vec3,
                        p = new Vec3,
                        f = new Vec3;
                    a.vsub(n, d);
                    const m = -l.dot(d) / h;
                    s.scale(m, p), a.vadd(p, f), this.reportIntersection(l, f, r, i, -1)
                }
                getAABB(e) {
                    const {
                        lowerBound: t,
                        upperBound: n
                    } = e, i = this.to, r = this.from;
                    t.x = Math.min(i.x, r.x), t.y = Math.min(i.y, r.y), t.z = Math.min(i.z, r.z), n.x = Math.max(i.x, r.x), n.y = Math.max(i.y, r.y), n.z = Math.max(i.z, r.z)
                }
                _intersectHeightfield(e, t, n, i, r) {
                    e.data, e.elementSize;
                    const a = $u;
                    a.from.copy(this.from), a.to.copy(this.to), Transform.pointToLocalFrame(n, t, a.from, a.from), Transform.pointToLocalFrame(n, t, a.to, a.to), a.updateDirection();
                    const o = eh;
                    let s, l, c, u;
                    s = l = 0, c = u = e.data.length - 1;
                    const h = new AABB;
                    a.getAABB(h), e.getIndexOfPosition(h.lowerBound.x, h.lowerBound.y, o, !0), s = Math.max(s, o[0]), l = Math.max(l, o[1]), e.getIndexOfPosition(h.upperBound.x, h.upperBound.y, o, !0), c = Math.min(c, o[0] + 1), u = Math.min(u, o[1] + 1);
                    for (let o = s; o < c; o++)
                        for (let s = l; s < u; s++) {
                            if (this.result.shouldStop) return;
                            if (e.getAabbAtIndex(o, s, h), h.overlapsRay(a)) {
                                if (e.getConvexTrianglePillar(o, s, !1), Transform.pointToWorldFrame(n, t, e.pillarOffset, Ku), this._intersectConvex(e.pillarConvex, t, Ku, i, r, Zu), this.result.shouldStop) return;
                                e.getConvexTrianglePillar(o, s, !0), Transform.pointToWorldFrame(n, t, e.pillarOffset, Ku), this._intersectConvex(e.pillarConvex, t, Ku, i, r, Zu)
                            }
                        }
                }
                _intersectSphere(e, t, n, i, r) {
                    const a = this.from,
                        o = this.to,
                        s = e.radius,
                        l = (o.x - a.x) ** 2 + (o.y - a.y) ** 2 + (o.z - a.z) ** 2,
                        c = 2 * ((o.x - a.x) * (a.x - n.x) + (o.y - a.y) * (a.y - n.y) + (o.z - a.z) * (a.z - n.z)),
                        u = c ** 2 - 4 * l * ((a.x - n.x) ** 2 + (a.y - n.y) ** 2 + (a.z - n.z) ** 2 - s ** 2),
                        h = th,
                        d = nh;
                    if (!(u < 0))
                        if (0 === u) a.lerp(o, u, h), h.vsub(n, d), d.normalize(), this.reportIntersection(d, h, r, i, -1);
                        else {
                            const e = (-c - Math.sqrt(u)) / (2 * l),
                                t = (-c + Math.sqrt(u)) / (2 * l);
                            if (e >= 0 && e <= 1 && (a.lerp(o, e, h), h.vsub(n, d), d.normalize(), this.reportIntersection(d, h, r, i, -1)), this.result.shouldStop) return;
                            t >= 0 && t <= 1 && (a.lerp(o, t, h), h.vsub(n, d), d.normalize(), this.reportIntersection(d, h, r, i, -1))
                        }
                }
                _intersectConvex(e, t, n, i, r, a) {
                    const o = ih,
                        s = rh,
                        l = a && a.faceList || null,
                        c = e.faces,
                        u = e.vertices,
                        h = e.faceNormals,
                        d = this.direction,
                        p = this.from,
                        f = this.to,
                        m = p.distanceTo(f),
                        g = l ? l.length : c.length,
                        y = this.result;
                    for (let e = 0; !y.shouldStop && e < g; e++) {
                        const a = l ? l[e] : e,
                            f = c[a],
                            g = h[a],
                            x = t,
                            _ = n;
                        s.copy(u[f[0]]), x.vmult(s, s), s.vadd(_, s), s.vsub(p, s), x.vmult(g, o);
                        const b = d.dot(o);
                        if (Math.abs(b) < this.precision) continue;
                        const M = o.dot(s) / b;
                        if (!(M < 0)) {
                            d.scale(M, Yu), Yu.vadd(p, Yu), qu.copy(u[f[0]]), x.vmult(qu, qu), _.vadd(qu, qu);
                            for (let e = 1; !y.shouldStop && e < f.length - 1; e++) {
                                Qu.copy(u[f[e]]), Ju.copy(u[f[e + 1]]), x.vmult(Qu, Qu), x.vmult(Ju, Ju), _.vadd(Qu, Qu), _.vadd(Ju, Ju);
                                const t = Yu.distanceTo(p);
                                !cannon_es_Ray.pointInTriangle(Yu, qu, Qu, Ju) && !cannon_es_Ray.pointInTriangle(Yu, Qu, qu, Ju) || t > m || this.reportIntersection(o, Yu, r, i, a)
                            }
                        }
                    }
                }
                _intersectTrimesh(e, t, n, i, r, a) {
                    const o = ah,
                        s = hh,
                        l = dh,
                        c = rh,
                        u = oh,
                        h = sh,
                        d = lh,
                        p = uh,
                        f = ch,
                        m = e.indices;
                    e.vertices;
                    const g = this.from,
                        y = this.to,
                        x = this.direction;
                    l.position.copy(n), l.quaternion.copy(t), Transform.vectorToLocalFrame(n, t, x, u), Transform.pointToLocalFrame(n, t, g, h), Transform.pointToLocalFrame(n, t, y, d), d.x *= e.scale.x, d.y *= e.scale.y, d.z *= e.scale.z, h.x *= e.scale.x, h.y *= e.scale.y, h.z *= e.scale.z, d.vsub(h, u), u.normalize();
                    const _ = h.distanceSquared(d);
                    e.tree.rayQuery(this, l, s);
                    for (let a = 0, l = s.length; !this.result.shouldStop && a !== l; a++) {
                        const l = s[a];
                        e.getNormal(l, o), e.getVertex(m[3 * l], qu), qu.vsub(h, c);
                        const d = u.dot(o),
                            g = o.dot(c) / d;
                        if (g < 0) continue;
                        u.scale(g, Yu), Yu.vadd(h, Yu), e.getVertex(m[3 * l + 1], Qu), e.getVertex(m[3 * l + 2], Ju);
                        const y = Yu.distanceSquared(h);
                        !cannon_es_Ray.pointInTriangle(Yu, Qu, qu, Ju) && !cannon_es_Ray.pointInTriangle(Yu, qu, Qu, Ju) || y > _ || (Transform.vectorToWorldFrame(t, o, f), Transform.pointToWorldFrame(n, t, Yu, p), this.reportIntersection(f, p, r, i, l))
                    }
                    s.length = 0
                }
                reportIntersection(e, t, n, i, r) {
                    const a = this.from,
                        o = this.to,
                        s = a.distanceTo(t),
                        l = this.result;
                    if (!(this.skipBackfaces && e.dot(this.direction) > 0)) switch (l.hitFaceIndex = void 0 !== r ? r : -1, this.mode) {
                        case cannon_es_Ray.ALL:
                            this.hasHit = !0, l.set(a, o, e, t, n, i, s), l.hasHit = !0, this.callback(l);
                            break;
                        case cannon_es_Ray.CLOSEST:
                            (s < l.distance || !l.hasHit) && (this.hasHit = !0, l.hasHit = !0, l.set(a, o, e, t, n, i, s));
                            break;
                        case cannon_es_Ray.ANY:
                            this.hasHit = !0, l.hasHit = !0, l.set(a, o, e, t, n, i, s), l.shouldStop = !0
                    }
                }
                static pointInTriangle(e, t, n, i) {
                    i.vsub(t, ph), n.vsub(t, ju), e.vsub(t, Wu);
                    const r = ph.dot(ph),
                        a = ph.dot(ju),
                        o = ph.dot(Wu),
                        s = ju.dot(ju),
                        l = ju.dot(Wu);
                    let c, u;
                    return (c = s * o - a * l) >= 0 && (u = r * l - a * o) >= 0 && c + u < r * s - a * a
                }
            }
            cannon_es_Ray.CLOSEST = Vu, cannon_es_Ray.ANY = Uu, cannon_es_Ray.ALL = zu;
            const Gu = new AABB,
                ku = [],
                ju = new Vec3,
                Wu = new Vec3,
                Hu = new Vec3,
                Xu = new cannon_es_Quaternion,
                Yu = new Vec3,
                qu = new Vec3,
                Qu = new Vec3,
                Ju = new Vec3,
                Zu = {
                    faceList: [0]
                },
                Ku = new Vec3,
                $u = new cannon_es_Ray,
                eh = [],
                th = new Vec3,
                nh = new Vec3,
                ih = new Vec3,
                rh = new Vec3,
                ah = new Vec3,
                oh = new Vec3,
                sh = new Vec3,
                lh = new Vec3,
                ch = new Vec3,
                uh = new Vec3;
            new AABB;
            const hh = [],
                dh = new Transform,
                ph = new Vec3,
                fh = new Vec3;
            class Utils {
                static defaults(e = {}, t) {
                    for (let n in t) n in e || (e[n] = t[n]);
                    return e
                }
            }
            class Constraint {
                constructor(e, t, n = {}) {
                    this.equations = void 0, this.bodyA = void 0, this.bodyB = void 0, this.id = void 0, this.collideConnected = void 0, n = Utils.defaults(n, {
                        collideConnected: !0,
                        wakeUpBodies: !0
                    }), this.equations = [], this.bodyA = e, this.bodyB = t, this.id = Constraint.idCounter++, this.collideConnected = n.collideConnected, n.wakeUpBodies && (e && e.wakeUp(), t && t.wakeUp())
                }
                update() {
                    throw Error("method update() not implmemented in this Constraint subclass!")
                }
                enable() {
                    const e = this.equations;
                    for (let t = 0; t < e.length; t++) e[t].enabled = !0
                }
                disable() {
                    const e = this.equations;
                    for (let t = 0; t < e.length; t++) e[t].enabled = !1
                }
            }
            Constraint.idCounter = 0;
            class JacobianElement {
                constructor() {
                    this.spatial = void 0, this.rotational = void 0, this.spatial = new Vec3, this.rotational = new Vec3
                }
                multiplyElement(e) {
                    return e.spatial.dot(this.spatial) + e.rotational.dot(this.rotational)
                }
                multiplyVectors(e, t) {
                    return e.dot(this.spatial) + t.dot(this.rotational)
                }
            }
            class Equation {
                constructor(e, t, n = -1e6, i = 1e6) {
                    this.id = void 0, this.minForce = void 0, this.maxForce = void 0, this.bi = void 0, this.bj = void 0, this.si = void 0, this.sj = void 0, this.a = void 0, this.b = void 0, this.eps = void 0, this.jacobianElementA = void 0, this.jacobianElementB = void 0, this.enabled = void 0, this.multiplier = void 0, this.id = Equation.idCounter++, this.minForce = n, this.maxForce = i, this.bi = e, this.bj = t, this.a = 0, this.b = 0, this.eps = 0, this.jacobianElementA = new JacobianElement, this.jacobianElementB = new JacobianElement, this.enabled = !0, this.multiplier = 0, this.setSpookParams(1e7, 4, 1 / 60)
                }
                setSpookParams(e, t, n) {
                    const i = t,
                        r = e,
                        a = n;
                    this.a = 4 / (a * (1 + 4 * i)), this.b = 4 * i / (1 + 4 * i), this.eps = 4 / (a * a * r * (1 + 4 * i))
                }
                computeB(e, t, n) {
                    const i = this.computeGW();
                    return -this.computeGq() * e - i * t - this.computeGiMf() * n
                }
                computeGq() {
                    const e = this.jacobianElementA,
                        t = this.jacobianElementB,
                        n = this.bi,
                        i = this.bj,
                        r = n.position,
                        a = i.position;
                    return e.spatial.dot(r) + t.spatial.dot(a)
                }
                computeGW() {
                    const e = this.jacobianElementA,
                        t = this.jacobianElementB,
                        n = this.bi,
                        i = this.bj,
                        r = n.velocity,
                        a = i.velocity,
                        o = n.angularVelocity,
                        s = i.angularVelocity;
                    return e.multiplyVectors(r, o) + t.multiplyVectors(a, s)
                }
                computeGWlambda() {
                    const e = this.jacobianElementA,
                        t = this.jacobianElementB,
                        n = this.bi,
                        i = this.bj,
                        r = n.vlambda,
                        a = i.vlambda,
                        o = n.wlambda,
                        s = i.wlambda;
                    return e.multiplyVectors(r, o) + t.multiplyVectors(a, s)
                }
                computeGiMf() {
                    const e = this.jacobianElementA,
                        t = this.jacobianElementB,
                        n = this.bi,
                        i = this.bj,
                        r = n.force,
                        a = n.torque,
                        o = i.force,
                        s = i.torque,
                        l = n.invMassSolve,
                        c = i.invMassSolve;
                    return r.scale(l, mh), o.scale(c, gh), n.invInertiaWorldSolve.vmult(a, vh), i.invInertiaWorldSolve.vmult(s, yh), e.multiplyVectors(mh, vh) + t.multiplyVectors(gh, yh)
                }
                computeGiMGt() {
                    const e = this.jacobianElementA,
                        t = this.jacobianElementB,
                        n = this.bi,
                        i = this.bj,
                        r = n.invMassSolve,
                        a = i.invMassSolve,
                        o = n.invInertiaWorldSolve,
                        s = i.invInertiaWorldSolve;
                    let l = r + a;
                    return o.vmult(e.rotational, xh), l += xh.dot(e.rotational), s.vmult(t.rotational, xh), l += xh.dot(t.rotational), l
                }
                addToWlambda(e) {
                    const t = this.jacobianElementA,
                        n = this.jacobianElementB,
                        i = this.bi,
                        r = this.bj,
                        a = _h;
                    i.vlambda.addScaledVector(i.invMassSolve * e, t.spatial, i.vlambda), r.vlambda.addScaledVector(r.invMassSolve * e, n.spatial, r.vlambda), i.invInertiaWorldSolve.vmult(t.rotational, a), i.wlambda.addScaledVector(e, a, i.wlambda), r.invInertiaWorldSolve.vmult(n.rotational, a), r.wlambda.addScaledVector(e, a, r.wlambda)
                }
                computeC() {
                    return this.computeGiMGt() + this.eps
                }
            }
            Equation.idCounter = 0;
            const mh = new Vec3,
                gh = new Vec3,
                vh = new Vec3,
                yh = new Vec3,
                xh = new Vec3,
                _h = new Vec3;
            new Vec3, new Vec3, new Vec3, new Vec3, new Vec3, new Vec3, new Vec3, new Vec3;
            new Vec3, new Vec3;
            new Vec3, new Vec3;
            new Vec3, new Vec3;
            new Vec3, new Vec3;
            class ContactMaterial {
                constructor(e, t, n) {
                    this.id = void 0, this.materials = void 0, this.friction = void 0, this.restitution = void 0, this.contactEquationStiffness = void 0, this.contactEquationRelaxation = void 0, this.frictionEquationStiffness = void 0, this.frictionEquationRelaxation = void 0, n = Utils.defaults(n, {
                        friction: .3,
                        restitution: .3,
                        contactEquationStiffness: 1e7,
                        contactEquationRelaxation: 3,
                        frictionEquationStiffness: 1e7,
                        frictionEquationRelaxation: 3
                    }), this.id = ContactMaterial.idCounter++, this.materials = [e, t], this.friction = n.friction, this.restitution = n.restitution, this.contactEquationStiffness = n.contactEquationStiffness, this.contactEquationRelaxation = n.contactEquationRelaxation, this.frictionEquationStiffness = n.frictionEquationStiffness, this.frictionEquationRelaxation = n.frictionEquationRelaxation
                }
            }
            ContactMaterial.idCounter = 0;
            class cannon_es_Material {
                constructor(e = {}) {
                    this.name = void 0, this.id = void 0, this.friction = void 0, this.restitution = void 0;
                    let t = "";
                    "string" == typeof e && (t = e, e = {}), this.name = t, this.id = cannon_es_Material.idCounter++, this.friction = void 0 !== e.friction ? e.friction : -1, this.restitution = void 0 !== e.restitution ? e.restitution : -1
                }
            }
            cannon_es_Material.idCounter = 0;
            new Vec3, new Vec3, new Vec3, new Vec3, new Vec3, new Vec3, new Vec3, new Vec3, new Vec3, new Vec3, new Vec3;
            new Vec3, new Vec3;
            new Vec3, new Vec3, new Vec3;
            new cannon_es_Ray;
            new Vec3, new Vec3, new Vec3(1, 0, 0), new Vec3(0, 1, 0), new Vec3(0, 0, 1), new Vec3, new Vec3, new Vec3, new Vec3, new Vec3, new Vec3, new Vec3, new Vec3, new Vec3, new Vec3, new Vec3;
            new Vec3, new Vec3;
            new Vec3, new Vec3, new Vec3, new Vec3, new Vec3, new Vec3, new Vec3;
            new Vec3;
            new Vec3, new Vec3, new Vec3, new Vec3, new Vec3, new Vec3, new Vec3, new Vec3, new Vec3;
            new Vec3, new AABB;
            new Vec3, new AABB, new Vec3, new Vec3, new Vec3, new Vec3, new Vec3, new Vec3, new Vec3, new AABB, new Vec3, new Transform, new AABB;
            Body.STATIC;
            let bh, Mh, Sh, Ah, wh, Th, Lh, Ch, Ph, Eh, Ih, Fh, Oh, Bh, Rh, Nh, Dh, Vh, Uh, zh, Gh, kh, jh, Wh, Hh;
            const Xh = {
                sphereSphere: cannon_es_Shape.types.SPHERE,
                spherePlane: cannon_es_Shape.types.SPHERE | cannon_es_Shape.types.PLANE,
                boxBox: cannon_es_Shape.types.BOX | cannon_es_Shape.types.BOX,
                sphereBox: cannon_es_Shape.types.SPHERE | cannon_es_Shape.types.BOX,
                planeBox: cannon_es_Shape.types.PLANE | cannon_es_Shape.types.BOX,
                convexConvex: cannon_es_Shape.types.CONVEXPOLYHEDRON,
                sphereConvex: cannon_es_Shape.types.SPHERE | cannon_es_Shape.types.CONVEXPOLYHEDRON,
                planeConvex: cannon_es_Shape.types.PLANE | cannon_es_Shape.types.CONVEXPOLYHEDRON,
                boxConvex: cannon_es_Shape.types.BOX | cannon_es_Shape.types.CONVEXPOLYHEDRON,
                sphereHeightfield: cannon_es_Shape.types.SPHERE | cannon_es_Shape.types.HEIGHTFIELD,
                boxHeightfield: cannon_es_Shape.types.BOX | cannon_es_Shape.types.HEIGHTFIELD,
                convexHeightfield: cannon_es_Shape.types.CONVEXPOLYHEDRON | cannon_es_Shape.types.HEIGHTFIELD,
                sphereParticle: cannon_es_Shape.types.PARTICLE | cannon_es_Shape.types.SPHERE,
                planeParticle: cannon_es_Shape.types.PLANE | cannon_es_Shape.types.PARTICLE,
                boxParticle: cannon_es_Shape.types.BOX | cannon_es_Shape.types.PARTICLE,
                convexParticle: cannon_es_Shape.types.PARTICLE | cannon_es_Shape.types.CONVEXPOLYHEDRON,
                cylinderCylinder: cannon_es_Shape.types.CYLINDER,
                sphereCylinder: cannon_es_Shape.types.SPHERE | cannon_es_Shape.types.CYLINDER,
                planeCylinder: cannon_es_Shape.types.PLANE | cannon_es_Shape.types.CYLINDER,
                boxCylinder: cannon_es_Shape.types.BOX | cannon_es_Shape.types.CYLINDER,
                convexCylinder: cannon_es_Shape.types.CONVEXPOLYHEDRON | cannon_es_Shape.types.CYLINDER,
                heightfieldCylinder: cannon_es_Shape.types.HEIGHTFIELD | cannon_es_Shape.types.CYLINDER,
                particleCylinder: cannon_es_Shape.types.PARTICLE | cannon_es_Shape.types.CYLINDER,
                sphereTrimesh: cannon_es_Shape.types.SPHERE | cannon_es_Shape.types.TRIMESH,
                planeTrimesh: cannon_es_Shape.types.PLANE | cannon_es_Shape.types.TRIMESH
            };
            bh = Xh.sphereSphere, Mh = Xh.spherePlane, Sh = Xh.boxBox, Ah = Xh.sphereBox, wh = Xh.planeBox, Th = Xh.convexConvex, Lh = Xh.sphereConvex, Ch = Xh.planeConvex, Ph = Xh.boxConvex, Eh = Xh.sphereHeightfield, Ih = Xh.boxHeightfield, Fh = Xh.convexHeightfield, Oh = Xh.sphereParticle, Bh = Xh.planeParticle, Rh = Xh.boxParticle, Nh = Xh.convexParticle, Dh = Xh.cylinderCylinder, Vh = Xh.sphereCylinder, Uh = Xh.planeCylinder, zh = Xh.boxCylinder, Gh = Xh.convexCylinder, kh = Xh.heightfieldCylinder, jh = Xh.particleCylinder, Wh = Xh.sphereTrimesh, Hh = Xh.planeTrimesh;
            new Vec3, new Vec3, new Vec3, new Vec3, new Vec3, new cannon_es_Quaternion, new cannon_es_Quaternion, new Vec3, new Vec3, new Vec3, new Vec3, new Vec3, new Vec3, new Vec3, new Vec3, new Vec3, new Vec3, new Vec3, new Vec3, new Vec3, new Vec3, new Vec3, new Vec3, new AABB, new Vec3, new Vec3, new Vec3, new Vec3, new Vec3, new Vec3, new Vec3, new Vec3, new Vec3, new Vec3, new Vec3, new Vec3, new Vec3, new Vec3, new Vec3, new Vec3, new Vec3, new Vec3, new Vec3, new Vec3, new Vec3, new Vec3, new Vec3, new Vec3, new Vec3, new Vec3, new Vec3, new Vec3, new Vec3, new Vec3, new Vec3, new Vec3, new Vec3, new Vec3, new Vec3, new Vec3, new Vec3, new Vec3, new Vec3, new cannon_es_Quaternion, new Vec3, new Vec3, new Vec3, new Vec3, new Vec3, new Vec3, new Vec3, new Vec3;
            new AABB;
            new cannon_es_Ray;
            const Yh = globalThis.performance || {};
            if (!Yh.now) {
                let e = Date.now();
                Yh.timing && Yh.timing.navigationStart && (e = Yh.timing.navigationStart), Yh.now = () => Date.now() - e
            }
            Body.COLLIDE_EVENT_NAME;
            Z = 5, K = new Vec3, $ = [new AABB({
                    lowerBound: new Vec3(0, 0, 0)
                }), new AABB({
                    lowerBound: new Vec3(1, 0, 0)
                }), new AABB({
                    lowerBound: new Vec3(1, 1, 0)
                }), new AABB({
                    lowerBound: new Vec3(1, 1, 1)
                }), new AABB({
                    lowerBound: new Vec3(0, 1, 1)
                }), new AABB({
                    lowerBound: new Vec3(0, 0, 1)
                }), new AABB({
                    lowerBound: new Vec3(1, 0, 1)
                }), new AABB({
                    lowerBound: new Vec3(0, 1, 0)
                })], (ee = []).length = 100, te = new AABB, ne = function() {
                    function LooseOctreeNode() {
                        classCallCheck_classCallCheck(this, LooseOctreeNode), this.aabb = new AABB, this.center = new Vec3, this.data = void 0, this.maxIndex = 0, this.children = void 0
                    }
                    return createClass_createClass(LooseOctreeNode, [{
                        key: "reset",
                        value: function reset(e) {
                            this.children = void 0, this.data = void 0
                        }
                    }, {
                        key: "insert",
                        value: function insert(e, t, n) {
                            var i, r, a, o, s, l, c, u, h;
                            if (n = n || 0, this.aabb.overlaps(e))
                                if (this.maxIndex = Math.max(this.maxIndex, t), n < (this.maxDepth || this.root.maxDepth)) {
                                    for (i = this.aabb.lowerBound, r = this.aabb.upperBound, a = function getChildAABB(e) {
                                            r.vsub(i, K), K.scale(.5, K), te.copy($[e]);
                                            var t = te.lowerBound;
                                            t.x *= K.x, t.y *= K.y, t.z *= K.z, t.vadd(i, t), t.vadd(K, te.upperBound)
                                        }, o = this.root || this, s = [], l = 0; 8 !== l; l++) this.children && this.children[l] ? te.copy(this.children[l].aabb) : a(l), te.overlaps(e) && s.push(l);
                                    if (s.length <= 4)
                                        for (c = 0; c < s.length; c++) u = s[c], void 0 === this.children && (this.children = []), (h = this.children[u]) ? te.copy(h.aabb) : (h = new LooseOctreeNode, this.children[u] = h, a(u), h.aabb.copy(te), h.root = o), h.insert(e, t, n + 1);
                                    else void 0 === this.data && (this.data = []), this.data.push(t)
                                } else void 0 === this.data && (this.data = []), this.data.push(t)
                        }
                    }, {
                        key: "aabbQuery",
                        value: function aabbQuery(e, t) {
                            var n, i, r, a, o, s, l, c, u, h, d, p, f, m, g = this.bitSetData;
                            for (g.fill(0), i = 1, (n = ee)[0] = this, r = e.lowerBound, a = e.upperBound; i;)
                                if (s = (o = n[--i]).aabb.lowerBound, l = o.aabb.upperBound, (r.x <= l.x && l.x <= a.x || s.x <= a.x && a.x <= l.x) && (r.y <= l.y && l.y <= a.y || s.y <= a.y && a.y <= l.y) && (r.z <= l.z && l.z <= a.z || s.z <= a.z && a.z <= l.z)) {
                                    if (c = o.data, u = o.children, c)
                                        for (h = 0, d = c.length; h < d; h++) 0 == (g[(p = c[h]) >>> Z] >>> p & 1) && (t.push(c[h]), g[p >>> Z] |= 1 << p);
                                    if (u)
                                        for (f = 0, m = u.length; f < m; f++) u[f] && (n[i] = u[f], i++)
                                }
                            return t
                        }
                    }, {
                        key: "rayQuery",
                        value: function rayQuery(e, t, n) {
                            return e.getAABB(te), te.toLocalFrame(t, te), this.aabbQuery(te, n), n
                        }
                    }, {
                        key: "prepare",
                        value: function prepare() {
                            this.bitSetData = [], this.bitSetData.length = this.maxIndex >>> Z
                        }
                    }]), LooseOctreeNode
                }(), ie = function(e) {
                    function LooseOctree(e, n) {
                        var i;
                        return classCallCheck_classCallCheck(this, LooseOctree), i = t.call(this), n = n || {}, e && (i.aabb.copy(e), i.updateCenter()), i.root = null, i.aabbResultTriangles = void 0, i.maxDepth = void 0 !== n.maxDepth ? n.maxDepth : 6, i
                    }
                    _inherits(LooseOctree, e);
                    var t = LooseOctree_createSuper(LooseOctree);
                    return createClass_createClass(LooseOctree, [{
                        key: "updateCenter",
                        value: function updateCenter() {
                            var e = this.aabb.lowerBound,
                                t = this.aabb.upperBound;
                            this.center.x = .5 * (e.x + t.x), this.center.y = .5 * (e.y + t.y), this.center.z = .5 * (e.z + t.z)
                        }
                    }]), LooseOctree
                }(ne), re = new Vec3, ae = new AABB, oe = new Vec3, se = new Vec3, le = new Vec3, ce = new Vec3, ue = new Vec3, he = new Vec3, de = new Vec3, pe = new AABB, fe = new Vec3, me = new AABB, ge = new Transform, ve = function(e) {
                    function LooseTrimesh(e, n) {
                        var i;
                        return classCallCheck_classCallCheck(this, LooseTrimesh), (i = t.call(this)).type = cannon_es_Shape.types.TRIMESH, i.vertices = new Float32Array(e), i.indices = new Int32Array(n), i.normals = new Float32Array(n.length), i.aabb = new AABB, i.edges = null, i.scale = new Vec3(1, 1, 1), i.tree = void 0, i.updateNormals(), i.updateAABB(), i.updateBoundingSphereRadius(), i
                    }
                    _inherits(LooseTrimesh, e);
                    var t = LooseTrimesh_createSuper(LooseTrimesh);
                    return createClass_createClass(LooseTrimesh, [{
                        key: "loadTree",
                        value: function loadTree(e, t) {
                            this.tree = new ie, this.tree.loadFromBuffer(e, t), this.tree.prepare()
                        }
                    }, {
                        key: "createTree",
                        value: function createTree(e) {
                            this.tree = new ie(e), this.updateTree()
                        }
                    }, {
                        key: "updateTree",
                        value: function updateTree() {
                            var e, t, n, i, r, a, o, s, l, c, u, h, d, p = this.tree;
                            for (p.reset(), p.aabb.copy(this.aabb), e = this.scale, p.aabb.lowerBound.x *= 1 / e.x, p.aabb.lowerBound.y *= 1 / e.y, p.aabb.lowerBound.z *= 1 / e.z, p.aabb.upperBound.x *= 1 / e.x, p.aabb.upperBound.y *= 1 / e.y, p.aabb.upperBound.z *= 1 / e.z, p.updateCenter(), t = new AABB, n = new Vec3, i = new Vec3, r = new Vec3, a = this.indices.length / 3, o = this.indices, s = this.vertices, l = t.lowerBound, c = t.upperBound, u = 0; u < a; u++) d = 3 * o[h = 3 * u], n.x = s[d], n.y = s[d + 1], n.z = s[d + 2], d = 3 * o[h + 1], i.x = s[d], i.y = s[d + 1], i.z = s[d + 2], d = 3 * o[h + 2], r.x = s[d], r.y = s[d + 1], r.z = s[d + 2], l.copy(n), c.copy(n), i.x > c.x && (c.x = i.x), i.x < l.x && (l.x = i.x), i.y > c.y && (c.y = i.y), i.y < l.y && (l.y = i.y), i.z > c.z && (c.z = i.z), i.z < l.z && (l.z = i.z), r.x > c.x && (c.x = r.x), r.x < l.x && (l.x = r.x), r.y > c.y && (c.y = r.y), r.y < l.y && (l.y = r.y), r.z > c.z && (c.z = r.z), r.z < l.z && (l.z = r.z), p.insert(t, u);
                            p.prepare()
                        }
                    }, {
                        key: "getTrianglesInAABB",
                        value: function getTrianglesInAABB(e, t) {
                            var n, i, r, a, o, s;
                            return ae.copy(e), i = (n = this.scale).x, r = n.y, a = n.z, o = ae.lowerBound, s = ae.upperBound, o.x /= i, o.y /= r, o.z /= a, s.x /= i, s.y /= r, s.z /= a, this.tree.aabbQuery(ae, t)
                        }
                    }, {
                        key: "setScale",
                        value: function setScale(e) {
                            var t = this.scale.x === this.scale.y === this.scale.z,
                                n = e.x === e.y === e.z;
                            t && n || this.updateNormals(), this.scale.copy(e), this.updateAABB(), this.updateBoundingSphereRadius()
                        }
                    }, {
                        key: "updateNormals",
                        value: function updateNormals() {
                            var e, t, n, i, r, a = re,
                                o = this.normals;
                            for (e = 0; e < this.indices.length / 3; e++) t = 3 * e, n = this.indices[t], i = this.indices[t + 1], r = this.indices[t + 2], this.getVertex(n, ue), this.getVertex(i, he), this.getVertex(r, de), LooseTrimesh.computeNormal(he, ue, de, a), o[t] = a.x, o[t + 1] = a.y, o[t + 2] = a.z
                        }
                    }, {
                        key: "updateEdges",
                        value: function updateEdges() {
                            var e, t, n, i, r, a, o, s = {},
                                l = function add(e, t) {
                                    s[n < i ? n + "_" + i : i + "_" + n] = !0
                                };
                            for (e = 0; e < this.indices.length / 3; e++) t = 3 * e, n = this.indices[t], i = this.indices[t + 1], r = this.indices[t + 2], l(n, i), l(i, r), l(r, n);
                            for (a = Object.keys(s), this.edges = new Int16Array(2 * a.length), e = 0; e < a.length; e++) o = a[e].split("_"), this.edges[2 * e] = parseInt(o[0], 10), this.edges[2 * e + 1] = parseInt(o[1], 10)
                        }
                    }, {
                        key: "getEdgeVertex",
                        value: function getEdgeVertex(e, t, n) {
                            var i = this.edges[2 * e + (t ? 1 : 0)];
                            this.getVertex(i, n)
                        }
                    }, {
                        key: "getEdgeVector",
                        value: function getEdgeVector(e, t) {
                            var n = oe,
                                i = se;
                            this.getEdgeVertex(e, 0, n), this.getEdgeVertex(e, 1, i), i.vsub(n, t)
                        }
                    }, {
                        key: "getVertex",
                        value: function getVertex(e, t) {
                            var n = this.scale,
                                i = 3 * e,
                                r = this.vertices;
                            return t.set(r[i] * n.x, r[i + 1] * n.y, r[i + 2] * n.z), t
                        }
                    }, {
                        key: "_getUnscaledVertex",
                        value: function _getUnscaledVertex(e, t) {
                            var n = 3 * e,
                                i = this.vertices;
                            return t.set(i[n], i[n + 1], i[n + 2])
                        }
                    }, {
                        key: "getWorldVertex",
                        value: function getWorldVertex(e, t, n, i) {
                            return this.getVertex(e, i), Transform.pointToWorldFrame(t, n, i, i), i
                        }
                    }, {
                        key: "getTriangleVertices",
                        value: function getTriangleVertices(e, t, n, i) {
                            var r = 3 * e;
                            this.getVertex(this.indices[r], t), this.getVertex(this.indices[r + 1], n), this.getVertex(this.indices[r + 2], i)
                        }
                    }, {
                        key: "getNormal",
                        value: function getNormal(e, t) {
                            var n = 3 * e;
                            return t.set(this.normals[n], this.normals[n + 1], this.normals[n + 2])
                        }
                    }, {
                        key: "calculateLocalInertia",
                        value: function calculateLocalInertia(e, t) {
                            this.computeLocalAABB(pe);
                            var n = pe.upperBound.x - pe.lowerBound.x,
                                i = pe.upperBound.y - pe.lowerBound.y,
                                r = pe.upperBound.z - pe.lowerBound.z;
                            return t.set(1 / 12 * e * (2 * i * 2 * i + 2 * r * 2 * r), 1 / 12 * e * (2 * n * 2 * n + 2 * r * 2 * r), 1 / 12 * e * (2 * i * 2 * i + 2 * n * 2 * n))
                        }
                    }, {
                        key: "computeLocalAABB",
                        value: function computeLocalAABB(e) {
                            var t, n = e.lowerBound,
                                i = e.upperBound,
                                r = this.vertices.length,
                                a = fe;
                            for (this.getVertex(0, a), n.copy(a), i.copy(a), t = 0; t !== r; t++) this.getVertex(t, a), a.x < n.x ? n.x = a.x : a.x > i.x && (i.x = a.x), a.y < n.y ? n.y = a.y : a.y > i.y && (i.y = a.y), a.z < n.z ? n.z = a.z : a.z > i.z && (i.z = a.z)
                        }
                    }, {
                        key: "updateAABB",
                        value: function updateAABB() {
                            this.computeLocalAABB(this.aabb)
                        }
                    }, {
                        key: "updateBoundingSphereRadius",
                        value: function updateBoundingSphereRadius() {
                            var e, t, n, i = 0,
                                r = this.vertices,
                                a = new Vec3;
                            for (e = 0, t = r.length / 3; e !== t; e++) this.getVertex(e, a), (n = a.lengthSquared()) > i && (i = n);
                            this.boundingSphereRadius = Math.sqrt(i)
                        }
                    }, {
                        key: "calculateWorldAABB",
                        value: function calculateWorldAABB(e, t, n, i) {
                            var r = ge,
                                a = me;
                            r.position = e, r.quaternion = t, this.aabb.toWorldFrame(r, a), n.copy(a.lowerBound), i.copy(a.upperBound)
                        }
                    }, {
                        key: "volume",
                        value: function volume() {
                            return 4 * Math.PI * this.boundingSphereRadius / 3
                        }
                    }], [{
                        key: "computeNormal",
                        value: function computeNormal(e, t, n, i) {
                            t.vsub(e, ce), n.vsub(t, le), le.cross(ce, i), i.isZero() || i.normalize()
                        }
                    }]), LooseTrimesh
                }(cannon_es_Shape), ye = {
                    physics: {
                        materials: {
                            world: new cannon_es_Material({
                                friction: .6,
                                restitution: .6
                            }),
                            player: new cannon_es_Material({
                                friction: 0,
                                restitution: -1
                            }),
                            grenade: new cannon_es_Material({
                                friction: .6,
                                restitution: 1
                            })
                        }
                    }
                }, xe = function() {
                    function TriMesh(e, t) {
                        var n, i, r, a, o, s;
                        if (classCallCheck_classCallCheck(this, TriMesh), this.mesh = e.clone(), n = {
                                mass: 0,
                                position: e.position,
                                friction: .3
                            }, t = Ze.setDefaults(t, n), this.options = t, !this.mesh.geometry.isBufferGeometry) throw Error("Expecting buffer geometry");
                        r = (i = this.mesh.geometry).attributes.position.array, a = i.index.array, (o = new ve(r, a)).material = ye.physics.materials.world, s = new Body({
                            mass: t.mass,
                            position: t.position,
                            shape: o
                        }), this.shape = o, s.material = o.material, this.physical = s
                    }
                    return createClass_createClass(TriMesh, [{
                        key: "getVisualModel",
                        value: function getVisualModel(e) {
                            var t, n, i = {
                                visible: !0,
                                wireframe: !0
                            };
                            return t = new MeshLambertMaterial({
                                color: 13421772,
                                wireframe: (e = Ze.setDefaults(e, i)).wireframe
                            }), (n = this.mesh.clone()).material = t, n.visible = e.visible, e.wireframe || (n.castShadow = !0, n.receiveShadow = !0), n
                        }
                    }]), TriMesh
                }(), _e = {
                    TriMesh: xe
                }, be = function() {
                    function SimplePool(e, t, n) {
                        classCallCheck_classCallCheck(this, SimplePool), this.ctor = e, this.initFunction = t || e.prototype.init, this.destroyFunction = n || e.prototype.destroy;
                        for (var i = arguments.length, r = Array(i > 3 ? i - 3 : 0), a = 3; a < i; a++) r[a - 3] = arguments[a];
                        this.ctorArgs = r, this.available = []
                    }
                    return createClass_createClass(SimplePool, [{
                        key: "obtain",
                        value: function obtain() {
                            var e, t, n, i;
                            if (0 === this.available.length && this.available.push(_construct(this.ctor, _toConsumableArray(this.ctorArgs))), e = this.available.pop(), this.initFunction) {
                                for (n = Array(t = arguments.length), i = 0; i < t; i++) n[i] = arguments[i];
                                this.initFunction.apply(e, n)
                            }
                            return e
                        }
                    }, {
                        key: "release",
                        value: function release(e) {
                            this.destroyFunction && this.destroyFunction.apply(e), this.available.push(e)
                        }
                    }]), SimplePool
                }(), Me = function() {
                    function Component() {
                        classCallCheck_classCallCheck(this, Component), this._entityID = void 0
                    }
                    return createClass_createClass(Component, [{
                        key: "entityId",
                        get: function get() {
                            return this._entityID
                        }
                    }, {
                        key: "attachToEntity",
                        value: function attachToEntity(e) {
                            this._entityID = e
                        }
                    }, {
                        key: "detachFromEntity",
                        value: function detachFromEntity() {
                            this._entityID = void 0
                        }
                    }, {
                        key: "getEntity",
                        value: function getEntity(e) {
                            return e.getEntity(this._entityID)
                        }
                    }, {
                        key: "getSibling",
                        value: function getSibling(e, t) {
                            var n = e.getEntity(this._entityID);
                            if (n) return n.getComponent(t)
                        }
                    }]), Component
                }(), Se = {
                    tickTimeStep: 1 / 30,
                    frameTimeStep: 1 / 30,
                    inputFramesPerTick: 1
                },
                function(e) {
                    e[e.teamDeathmatch = 1] = "teamDeathmatch", e[e.roundVote = 2] = "roundVote", e[e.elimination = 3] = "elimination"
                }(Ae || (Ae = {})), (we = {})[Ae.roundVote] = {
                    name: "Free For All",
                    image: "img/stickers/MercZone_sticker_HOLA.png"
                }, we[Ae.teamDeathmatch] = {
                    name: "Team",
                    image: "img/stickers/MercZone_sticker_GOODSHOW.png"
                }, we[Ae.elimination] = {
                    name: "Last Merc Standing",
                    image: "img/stickers/MercZone_sticker_HA.png"
                },
                function(e) {
                    e[e.Searching = 0] = "Searching", e[e.CreatingRoom = 1] = "CreatingRoom", e[e.CreatingServer = 2] = "CreatingServer", e[e.Connecting = 3] = "Connecting", e[e.LoadingLevel = 4] = "LoadingLevel", e[e.TransferringRoom = 5] = "TransferringRoom", e[e.WaitingForServer = 6] = "WaitingForServer", e[e.Leaving = 7] = "Leaving"
                }(Te || (Te = {})), Le = function() {
                    function InputState() {
                        classCallCheck_classCallCheck(this, InputState), this.buttonStates = 0, this.buttonPressed = 0, this.buttonReleased = 0, this.mouseX = 0, this.mouseY = 0, this.wheelDelta = 0, this.phi = 0, this.theta = 0
                    }
                    return createClass_createClass(InputState, [{
                        key: "init",
                        value: function init() {
                            this.buttonStates = 0, this.buttonPressed = 0, this.buttonReleased = 0, this.mouseX = 0, this.mouseY = 0, this.wheelDelta = 0, this.phi = 0, this.theta = 0, this.extra = 0
                        }
                    }, {
                        key: "copy",
                        value: function copy(e) {
                            return this.buttonStates = e.buttonStates, this.buttonPressed = e.buttonPressed, this.buttonReleased = e.buttonReleased, this.mouseX = e.mouseX, this.mouseY = e.mouseY, this.phi = e.phi, this.theta = e.theta, this.wheelDelta = e.wheelDelta, this.timeStep = e.timeStep, this.extra = e.extra, this
                        }
                    }, {
                        key: "add",
                        value: function add(e) {
                            return this.buttonStates |= e.buttonStates, this.buttonPressed |= e.buttonPressed, this.buttonReleased |= e.buttonReleased, this.wheelDelta += e.wheelDelta, this.extra || (this.extra = e.extra), this.mouseX = e.mouseX, this.mouseY = e.mouseY, this.timeStep += e.timeStep, this.phi = e.phi, this.theta = e.theta, this
                        }
                    }, {
                        key: "equals",
                        value: function equals(e) {
                            return this.buttonStates == e.buttonStates && this.buttonPressed == e.buttonPressed && this.buttonReleased == e.buttonReleased && this.mouseX == e.mouseX && this.mouseY == e.mouseY && this.extra == e.extra
                        }
                    }, {
                        key: "isButtonDown",
                        value: function isButtonDown(e) {
                            var t = 1 << e;
                            return 0 != (this.buttonStates & t)
                        }
                    }, {
                        key: "isButtonUp",
                        value: function isButtonUp(e) {
                            var t = 1 << e;
                            return 0 == (this.buttonStates & t)
                        }
                    }, {
                        key: "isButtonJustPressed",
                        value: function isButtonJustPressed(e) {
                            var t = 1 << e;
                            return 0 != (this.buttonPressed & t)
                        }
                    }, {
                        key: "isButtonJustReleased",
                        value: function isButtonJustReleased(e) {
                            var t = 1 << e;
                            return 0 != (this.buttonReleased & t)
                        }
                    }, {
                        key: "writeButtonState",
                        value: function writeButtonState(e, t) {
                            var n = 1 << e;
                            this.buttonStates = t ? this.buttonStates | n : this.buttonStates & ~n
                        }
                    }, {
                        key: "writeButtonPressed",
                        value: function writeButtonPressed(e) {
                            var t = 1 << e;
                            this.buttonPressed |= t
                        }
                    }, {
                        key: "writeButtonReleased",
                        value: function writeButtonReleased(e) {
                            var t = 1 << e;
                            this.buttonReleased |= t
                        }
                    }]), InputState
                }(), Ce = function(e) {
                    function ConnectionComponent() {
                        var e, n, i, r;
                        for (classCallCheck_classCallCheck(this, ConnectionComponent), i = Array(n = arguments.length), r = 0; r < n; r++) i[r] = arguments[r];
                        return _defineProperty(_assertThisInitialized(e = t.call.apply(t, [this].concat(i))), "settingCrouchToggle", !1), _defineProperty(_assertThisInitialized(e), "settingAutoRun", !0), _defineProperty(_assertThisInitialized(e), "lastInput", new Le), e
                    }
                    _inherits(ConnectionComponent, e);
                    var t = ConnectionComponent_createSuper(ConnectionComponent);
                    return createClass_createClass(ConnectionComponent, [{
                        key: "init",
                        value: function init(e, t) {
                            this.uId = e, this.username = t, this.stringId = "conn_" + e, this.frame = 0, this.attachedKernel = void 0, this.launchAt = void 0, this.idleTime = 0
                        }
                    }, {
                        key: "destroy",
                        value: function destroy() {
                            this.attachedKernel = void 0
                        }
                    }]), ConnectionComponent
                }(Me), Pe = function(e) {
                    function SingletonComponent() {
                        return classCallCheck_classCallCheck(this, SingletonComponent), t.apply(this, arguments)
                    }
                    _inherits(SingletonComponent, e);
                    var t = SingletonComponent_createSuper(SingletonComponent);
                    return createClass_createClass(SingletonComponent, [{
                        key: "init",
                        value: function init() {
                            throw Error("Don't use init() with singleton components!")
                        }
                    }]), SingletonComponent
                }(Me), Ee = function() {
                    function AudioSource() {
                        classCallCheck_classCallCheck(this, AudioSource), this.cueList = [], this.attachedCueList = []
                    }
                    return createClass_createClass(AudioSource, [{
                        key: "init",
                        value: function init(e) {
                            this.sourceFile = e, this.cueList.length = 0, this.attachedCueList.length = 0
                        }
                    }, {
                        key: "destroy",
                        value: function destroy() {}
                    }, {
                        key: "addCue",
                        value: function addCue(e) {
                            this.cueList.push(e)
                        }
                    }, {
                        key: "removeCue",
                        value: function removeCue(e) {
                            var t, n = this.cueList.indexOf(e); - 1 !== n && (t = this.cueList.length - 1, this.cueList[n] = this.cueList[t], this.cueList.length = t)
                        }
                    }, {
                        key: "addAttachedCue",
                        value: function addAttachedCue(e) {
                            this.attachedCueList.push(e)
                        }
                    }, {
                        key: "removeAttachedCue",
                        value: function removeAttachedCue(e) {
                            var t, n = this.attachedCueList.indexOf(e); - 1 !== n && (t = this.attachedCueList.length - 1, this.attachedCueList[n] = this.attachedCueList[t], this.attachedCueList.length = t)
                        }
                    }]), AudioSource
                }(), Ie = function() {
                    function AudioCue() {
                        classCallCheck_classCallCheck(this, AudioCue), this.position = new Vector3, this.worldPosition = new Vector3
                    }
                    return createClass_createClass(AudioCue, [{
                        key: "init",
                        value: function init(e) {
                            this.audioSource = e, this.audioObject = void 0, this.position.set(0, 0, 0), this.worldPosition.set(0, 0, 0), this.needsUpdate = !1, this.needsVolumeUpdate = !1, this.stopped = !1, this.volume = 1, this.playbackRate = 1, this.delay = void 0
                        }
                    }, {
                        key: "destroy",
                        value: function destroy() {
                            this.audioSource = void 0
                        }
                    }, {
                        key: "setVolume",
                        value: function setVolume(e) {
                            this.volume != e && (this.volume = e, this.needsVolumeUpdate = !0)
                        }
                    }, {
                        key: "setPlaybackRate",
                        value: function setPlaybackRate(e) {
                            e != this.playbackRate && (this.playbackRate = e, this.needsVolumeUpdate = !0)
                        }
                    }, {
                        key: "stop",
                        value: function stop() {
                            this.audioObject && (this.audioObject.source && this.audioObject.stop(), this.audioObject.onEnded && this.audioObject.onEnded(), this.audioObject = void 0), this.stopped = !0
                        }
                    }]), AudioCue
                }(), Fe = __webpack_require__(7253), Oe = __webpack_require__.n(Fe), Be = function(e) {
                    function SingletonAudioComponent() {
                        var e;
                        return classCallCheck_classCallCheck(this, SingletonAudioComponent), (e = t.call(this)).audioSourcePool = new be(Ee), e.audioCuePool = new be(Ie), e.audioSources = new Map, e.newSounds = [], e.curSounds = [], e
                    }
                    _inherits(SingletonAudioComponent, e);
                    var t = SingletonAudioComponent_createSuper(SingletonAudioComponent);
                    return createClass_createClass(SingletonAudioComponent, [{
                        key: "destroy",
                        value: function destroy() {}
                    }, {
                        key: "addSound",
                        value: function addSound(e, t) {
                            var n, i, r, a = this.audioSources.get(e);
                            if (void 0 === a && (a = this.audioSourcePool.obtain(e), this.audioSources.set(e, a)), (n = this.audioCuePool.obtain(a)).stopped = !1, a.addCue(n), n.attach = t.attach, n.soundFile = e, Oe()(e) && (n.soundFile = Ze.chooseRandom(e)), n.firstPerson = t.firstPerson || !1, n.loop = t.loop || !1, n.follow = t.follow || !1, n.rolloff = t.rolloff || 1, n.delay = t.delay, void 0 === t.cutoff ? n.cutoff = 40 : n.cutoff = t.cutoff, i = t.volume || [.95, 1.05], Oe()(i)) {
                                if (2 !== i.length) throw Error("Audio volume range must contain 2 elements!");
                                n.volume = Ze.randomRange(i[0], i[1])
                            } else n.volume = i;
                            return r = n.playbackRate || [.95, 1.05], Oe()(r) ? n.playbackRate = Ze.randomRange(r[0], r[1]) : n.playbackRate = r, n.autoKill = void 0 === t.autoKill || t.autoKill, t.position && n.position.copy(t.position), this.newSounds.push(n), n
                        }
                    }, {
                        key: "removeSound",
                        value: function removeSound(e) {
                            var t = e.audioSource;
                            t.removeCue(e), e.audioObject && (e.audioObject = void 0), t.removeAttachedCue(e), this.audioCuePool.release(e)
                        }
                    }]), SingletonAudioComponent
                }(Pe), Re = __webpack_require__(6705), Ne = __webpack_require__.n(Re), De = new Vector3, Ve = new Vector3, Ue = new Vector3, ze = new Vector3, Ge = new Quaternion, ke = new Quaternion, je = new Quaternion(0, 0, 0, 1), We = new SkinnedMesh, He = new Mesh, Xe = new Object3D, Ye = new Group, qe = new Object3D, Qe = new(Ne()), Je = "undefined" != typeof window ? window : "undefined" != typeof WorkerGlobalScope ? WorkerGlobalScope : __webpack_require__.g, Ze = function() {
                    function Utilities() {
                        classCallCheck_classCallCheck(this, Utilities)
                    }
                    return createClass_createClass(Utilities, null, [{
                        key: "createCapsuleGeometry",
                        value: function createCapsuleGeometry() {
                            var e, t, n, i, r, a, o, s, l, c, u, h, d, p, f, m, g, y, x, _ = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1,
                                b = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 2,
                                M = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 32,
                                S = new Geometry,
                                A = 2 * Math.PI,
                                w = 1.5707963267948966,
                                T = [];
                            for (e = 0; e <= M / 4; e++)
                                for (t = 0; t <= M; t++) n = t * A / M, i = Math.PI * e / (M / 2) - w, r = new Vector3, a = new Vector3, r.x = _ * Math.cos(i) * Math.cos(n), r.y = _ * Math.cos(i) * Math.sin(n), r.z = _ * Math.sin(i), r.z -= b / 2, a.x = r.x, a.y = r.y, a.z = r.z, S.vertices.push(r), T.push(a);
                            for (o = M / 4; o <= M / 2; o++)
                                for (s = 0; s <= M; s++) l = s * A / M, c = Math.PI * o / (M / 2) - w, u = new Vector3, h = new Vector3, u.x = _ * Math.cos(c) * Math.cos(l), u.y = _ * Math.cos(c) * Math.sin(l), u.z = _ * Math.sin(c), u.z += b / 2, h.x = u.x, h.y = u.y, h.z = u.z, S.vertices.push(u), T.push(h);
                            for (d = 0; d <= M / 2; d++)
                                for (p = 0; p < M; p++) f = new Vector4(d * (M + 1) + p, d * (M + 1) + (p + 1), (d + 1) * (M + 1) + (p + 1), (d + 1) * (M + 1) + p), d == M / 4 ? (m = new Face3(f.x, f.y, f.z, [T[f.x], T[f.y], T[f.z]]), g = new Face3(f.x, f.z, f.w, [T[f.x], T[f.z], T[f.w]]), S.faces.push(g), S.faces.push(m)) : (y = new Face3(f.x, f.y, f.z, [T[f.x], T[f.y], T[f.z]]), x = new Face3(f.x, f.z, f.w, [T[f.x], T[f.z], T[f.w]]), S.faces.push(y), S.faces.push(x));
                            return S.rotateX(Math.PI / 2), S.computeVertexNormals(), S.computeFaceNormals(), S
                        }
                    }, {
                        key: "applyVectorMatrixXZ",
                        value: function applyVectorMatrixXZ(e, t) {
                            return t.set((e.x * t.z + e.z * t.x) / 2, t.y, (e.z * t.z + -e.x * t.x) / 2)
                        }
                    }, {
                        key: "round",
                        value: function round(e) {
                            var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                            return Math.round(e * Math.pow(10, t)) / Math.pow(10, t)
                        }
                    }, {
                        key: "roundVector",
                        value: function roundVector(e) {
                            var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                            return new Vector3(this.round(e.x, t), this.round(e.y, t), this.round(e.z, t))
                        }
                    }, {
                        key: "getAngleBetweenVectors",
                        value: function getAngleBetweenVectors(e, t) {
                            var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 5e-4,
                                i = e.dot(t);
                            return i > 1 - n ? 0 : i < -1 + n ? Math.PI / 2 : Math.acos(i)
                        }
                    }, {
                        key: "getSignedAngleBetweenVectors",
                        value: function getSignedAngleBetweenVectors(e, t) {
                            var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : new Vector3(0, 1, 0),
                                i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 5e-4,
                                r = this.getAngleBetweenVectors(e, t, i),
                                a = ze.crossVectors(e, t);
                            return n.dot(a) < 0 && (r = -r), r
                        }
                    }, {
                        key: "haveSameSigns",
                        value: function haveSameSigns(e, t) {
                            return e < 0 == t < 0
                        }
                    }, {
                        key: "haveDifferentSigns",
                        value: function haveDifferentSigns(e, t) {
                            return e < 0 != t < 0
                        }
                    }, {
                        key: "setDefaults",
                        value: function setDefaults(e, t) {
                            return q()({}, J()(e), t)
                        }
                    }, {
                        key: "createPhysicsBodiesFromScene",
                        value: function createPhysicsBodiesFromScene(e) {
                            var t = [];
                            return e.traverse((function(e) {
                                var n, i;
                                e.isMesh && (n = 0, (i = new _e.TriMesh(e, {
                                    mass: n
                                })).physical.collisionResponse = !0, t.push(i.physical), void 0 === e.octree ? (i.shape.createTree(), e.octree = i.shape.tree) : i.shape.tree = e.octree)
                            })), t
                        }
                    }, {
                        key: "releaseClone",
                        value: function releaseClone(e) {
                            for (var t = 0; t < e.children.length; t++) Utilities.releaseClone(e.children[t]);
                            e.isPooled && (e.isBone ? Je.bonePool.release(e) : e.isSkinnedMesh ? Je.skinnedMeshPool.release(e) : e.isMesh ? Je.meshPool.release(e) : e.isGroup ? Je.groupPool.release(e) : e.isObject3D && Je.objectPool.release(e))
                        }
                    }, {
                        key: "cloneScene",
                        value: function cloneScene(e, t) {
                            var cloneScene, n, i, r, a, o, s, l, c, u, h, d, p, f;
                            if (e) {
                                for (cloneScene = e.clone(!0), cloneScene.animations = e.animations, n = {}, e.traverse((function(e) {
                                        e.isSkinnedMesh && (n[e.name] = e)
                                    })), i = {}, r = {}, a = [], cloneScene.traverse((function(e) {
                                        e.isBone ? t || (i[e.name] = e) : e.isLight && a.push(e), e.isSkinnedMesh && (r[e.name] = e)
                                    })), o = 0; o < a.length; o++) a[o].parent && a[o].parent.remove(a[o]);
                                if (s = void 0, !t)
                                    for (l in n) {
                                        if (c = n[l].skeleton, u = r[l], h = void 0, null != s && s.bones.length === c.bones.length) h = s;
                                        else {
                                            for (d = [], p = 0; p < c.bones.length; ++p) f = i[c.bones[p].name], d.push(f);
                                            s = h = new Skeleton(d, c.boneInverses)
                                        }
                                        u && u.bind(h, u.matrixWorld)
                                    }
                                return cloneScene
                            }
                        }
                    }, {
                        key: "updateSkeletonMatrices",
                        value: function updateSkeletonMatrices(e) {
                            e.updateBoneTexture = !0
                        }
                    }, {
                        key: "cleanupAnimationMixerBindings",
                        value: function cleanupAnimationMixerBindings(e) {
                            for (var t, n = 0; n < e._bindings.length;)(t = e._bindings[n]).binding.node === e._root && (t.binding.node = qe), n++
                        }
                    }, {
                        key: "randomRange",
                        value: function randomRange(e, t) {
                            var n = t - e,
                                i = Qe.random() * n;
                            return e + i
                        }
                    }, {
                        key: "chooseRandom",
                        value: function chooseRandom(e) {
                            return e[Qe.random_int() % e.length]
                        }
                    }, {
                        key: "findEntityByUID",
                        value: function findEntityByUID(e, t) {
                            var n, i, r, a;
                            if (e)
                                for (i = 0, r = (n = e.components.get(Ce)).length; i < r; i++)
                                    if ((a = n[i]).uId == t) return a.getEntity(e)
                        }
                    }, {
                        key: "stableLookat",
                        value: function stableLookat(e, t, n) {
                            var i = Ve.copy(n || Object3D.DefaultUp),
                                r = Ue.copy(t),
                                a = De;
                            return a.crossVectors(i, r), a.normalize(), i.crossVectors(r, a), i.normalize(), e.makeBasis(a, i, r), 0 != e.determinant() ? e : void 0
                        }
                    }, {
                        key: "stableLookatToBasis",
                        value: function stableLookatToBasis(e, t, n, i, r) {
                            t.copy(r || Object3D.DefaultUp), n.copy(i), e.crossVectors(t, n), e.normalize(), t.crossVectors(n, e), t.normalize()
                        }
                    }, {
                        key: "playSoundAttached",
                        value: function playSoundAttached(e, t, n) {
                            return Array.isArray(t) && (t = Utilities.chooseRandom(t)), e.getSingletonComponent(Be).addSound(t, n)
                        }
                    }, {
                        key: "mapRange",
                        value: function mapRange(e, t, n, i, r) {
                            return (r - e) * (i - n) / (t - e) + n
                        }
                    }, {
                        key: "mapRangeClamped",
                        value: function mapRangeClamped(e, t, n, i, r) {
                            return ((r = Math.max(Math.min(r, t), e)) - e) * (i - n) / (t - e) + n
                        }
                    }, {
                        key: "accumulateAdditive",
                        value: function accumulateAdditive(e, t, n) {
                            var i, r = e.buffer,
                                a = e.valueSize,
                                o = t * a + a;
                            if (4 == a) Ge.set(r[o + 0], r[o + 1], r[o + 2], r[o + 3]), ke.set(r[0], r[1], r[2], r[3]), ke.slerp(je, 1 - n), Ge.multiply(ke), r[o + 0] = Ge.x, r[o + 1] = Ge.y, r[o + 2] = Ge.z, r[o + 3] = Ge.w;
                            else
                                for (i = 0; i !== a; ++i) r[o + i] += r[i] * n
                        }
                    }, {
                        key: "actionUpdateWithAdditive",
                        value: function actionUpdateWithAdditive(e, t, n, i, r, a) {
                            var o, s, l, c, u, h, d, p;
                            if (e.enabled) {
                                if (null !== (o = e._startTime)) {
                                    if ((s = (t - o) * i) < 0 || 0 === i) return;
                                    e._startTime = null, n = i * s
                                }
                                if (n *= e._updateTimeScale(t), l = e._updateTime(n), (c = e._updateWeight(t) * a) > 0)
                                    for (u = e._interpolants, h = e._propertyBindings, d = 0, p = u.length; d !== p; ++d) u[d].evaluate(l), Utilities.accumulateAdditive(h[d], r, c)
                            } else e._updateWeight(t)
                        }
                    }, {
                        key: "updateWithAdditive",
                        value: function updateWithAdditive(e, t, n) {
                            var i, r, a, o, s, l, c, u, h;
                            for (t *= e.timeScale, i = e._actions, r = e._nActiveActions, a = e.time += t, o = Math.sign(t), s = e._accuIndex ^= 1, l = 0; l !== r; ++l)(c = i[l])._clip.additive || c._update(a, t, o, s);
                            for (l = 0; l !== r; ++l)(c = i[l])._clip.additive && Utilities.actionUpdateWithAdditive(c, a, t, o, s, n);
                            for (u = e._bindings, h = e._nActiveBindings, l = 0; l !== h; ++l) u[l].apply(s);
                            return e
                        }
                    }, {
                        key: "initThreePools",
                        value: function initThreePools() {
                            ! function _initThreePools() {
                                Je.objectPool = new be(Object3D, initObject3D), Je.objectPool.name = "Three.Object3D", Je.bonePool = new be(Bone), Je.bonePool.name = "Three.Bone", Je.meshPool = new be(Mesh, initMesh, void 0, null, null), Je.meshPool.name = "Three.Mesh", Je.skinnedMeshPool = new be(SkinnedMesh, initSkinnedMesh, void 0, null, null), Je.skinnedMeshPool.name = "Three.SkinnedMesh", Je.groupPool = new be(Group, initGroup), Je.groupPool.name = "Three.Group"
                            }()
                        }
                    }]), Utilities
                }(), Ke = new Matrix4, $e = function(e) {
                    function OffsetPerspectiveCamera(e, n, i, r, a) {
                        var o;
                        return classCallCheck_classCallCheck(this, OffsetPerspectiveCamera), (o = t.call(this, e, n, i, r)).offsetAmount = a, o
                    }
                    _inherits(OffsetPerspectiveCamera, e);
                    var t = OffsetPerspectiveCamera_createSuper(OffsetPerspectiveCamera);
                    return createClass_createClass(OffsetPerspectiveCamera, [{
                        key: "updateProjectionMatrix",
                        value: function updateProjectionMatrix() {
                            var e, t, n, i = this.near,
                                r = i * Math.tan(Math.PI / 180 * .5 * this.fov) / this.zoom,
                                a = 2 * r,
                                o = this.aspect * a,
                                s = -.5 * o,
                                l = this.view;
                            null !== this.view && this.view.enabled && (e = l.fullWidth, t = l.fullHeight, s += l.offsetX * o / e, r -= l.offsetY * a / t, o *= l.width / e, a *= l.height / t), 0 !== (n = this.filmOffset) && (s += i * n / this.getFilmWidth()), this.projectionMatrix.makePerspective(s, s + o, r, r - a, i, this.far), Ke.makeTranslation(0, this.offsetAmount, 0), this.projectionMatrix.premultiply(Ke), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
                        }
                    }]), OffsetPerspectiveCamera
                }(PerspectiveCamera), et = _objectSpread(_objectSpread({}, t), {}, {
                    BloomPass: U,
                    OffsetPerspectiveCamera: $e
                }), Ze.initThreePools(), Ss.bokehDepth = k.uniforms, tt = [], nt = [], rt = [], at = [], ot = new Vector3, st = new Vector3, lt = new Vector3, ct = Se.tickTimeStep, ht = (ut = __webpack_require__.g.performance ? __webpack_require__.g.performance.now.bind(__webpack_require__.g.performance) : Date.now)(), dt = ht, pt = 0, ft = 0, mt = [], gt = [], yt = function(e) {
                    function FloatInterp() {
                        var e, n;
                        for (classCallCheck_classCallCheck(this, FloatInterp), e = t.call(this), n = 0; n < e.poolSize; n++) e.pool[n] = 0;
                        return e
                    }
                    _inherits(FloatInterp, e);
                    var t = index_renderer_createSuper(FloatInterp);
                    return createClass_createClass(FloatInterp, [{
                        key: "setValue",
                        value: function setValue(e, t) {
                            this.pool[this.curIndex] = t, this.addedValue(e)
                        }
                    }, {
                        key: "copy",
                        value: function copy(e, t) {
                            this.pool[e] = this.pool[t]
                        }
                    }]), FloatInterp
                }(vt = function() {
                    function Interp() {
                        classCallCheck_classCallCheck(this, Interp), this.pool = [], this.poolSize = 16, this.pool.length = this.poolSize, this.curIndex = 0, this.lastIndex = void 0, this.curFrame = 0
                    }
                    return createClass_createClass(Interp, [{
                        key: "getValue",
                        value: function getValue(e) {
                            var t = e - this.curFrame,
                                n = this.lastIndex + t;
                            return n < 0 && (n += this.poolSize), n &= this.poolSize - 1, this.pool[n]
                        }
                    }, {
                        key: "addedValue",
                        value: function addedValue(e) {
                            this.curFrame = e, void 0 === this.lastIndex && (this.curIndex++, this.curIndex = this.curIndex & this.poolSize - 1, this.copy(this.curIndex, this.curIndex - 1)), this.lastIndex = this.curIndex, this.curIndex++, this.curIndex = this.curIndex & this.poolSize - 1
                        }
                    }]), Interp
                }()), xt = function(e) {
                    function VectorInterp() {
                        var e, n;
                        for (classCallCheck_classCallCheck(this, VectorInterp), e = t.call(this), n = 0; n < e.poolSize; n++) e.pool[n] = new Vector3;
                        return e
                    }
                    _inherits(VectorInterp, e);
                    var t = index_renderer_createSuper(VectorInterp);
                    return createClass_createClass(VectorInterp, [{
                        key: "setValue",
                        value: function setValue(e, t, n, i) {
                            this.pool[this.curIndex].set(t, n, i), this.addedValue(e)
                        }
                    }, {
                        key: "copy",
                        value: function copy(e, t) {
                            this.pool[e].copy(this.pool[t])
                        }
                    }]), VectorInterp
                }(vt), _t = new Vector3, bt = new Vector3, Mt = new Vector3, St = new Vector3, At = new Vector3, wt = new Vector3, Tt = new Vector3, Lt = new Vector3, Ct = new Vector3, Pt = new Vector3, Et = new Quaternion, It = new Quaternion, Ft = new Quaternion, Ot = new Quaternion, Bt = new Quaternion, Rt = new Quaternion, Nt = new Euler, Dt = new Matrix4, Vt = new Matrix4, Ut = new Matrix4, zt = new Matrix4, Gt = new Matrix4, kt = new Matrix4, jt = new Color, Ht = {
                    getObject: function getObject(e) {
                        return nt[e]
                    },
                    getRenderer: function getRenderer(e) {
                        return tt[e]
                    },
                    clonedeep: _(),
                    THREE: t,
                    Utilities: Ze,
                    RenderEngine: Wt,
                    shortAngleDist: function shortAngleDist(e, t) {
                        var n = 360,
                            i = (t - e) % n;
                        return 2 * i % n - i
                    },
                    angleLerp: function angleLerp(e, t, n) {
                        return (e %= 720) < 0 && (e += 720), (t %= 720) < 0 && (t += 720), e + (((t - e) % 720 + 1080) % 720 - 360) * n % 720
                    },
                    lerp,
                    mapRange: function mapRange(e, t, n, i, r) {
                        return (r - e) * (i - n) / (t - e) + n
                    },
                    mapRangeClamped: function mapRangeClamped(e, t, n, i, r) {
                        return ((r = Math.max(Math.min(r, t), e)) - e) * (i - n) / (t - e) + n
                    },
                    tmpVector0: _t,
                    tmpVector1: bt,
                    tmpVector2: Mt,
                    tmpVector3: St,
                    tmpVector4: At,
                    tmpVector5: wt,
                    tmpVector6: Tt,
                    tmpVector7: Lt,
                    tmpVector8: Ct,
                    tmpVector9: Pt,
                    tmpQuaternion0: Et,
                    tmpQuaternion1: It,
                    tmpQuaternion2: Ft,
                    tmpQuaternion3: Ot,
                    tmpQuaternion4: Bt,
                    tmpQuaternion5: Rt,
                    tmpMatrix0: Dt,
                    tmpMatrix1: Vt,
                    tmpMatrix2: Ut,
                    tmpMatrix3: zt,
                    tmpMatrix4: Gt,
                    tmpMatrix5: kt,
                    tmpXAxis: ot,
                    tmpYAxis: st,
                    tmpZAxis: lt,
                    tmpEuler0: Nt,
                    stableLookat: function stableLookat(e, t, n) {
                        var i = st.copy(n || Object3D.DefaultUp),
                            r = lt.copy(t),
                            a = ot;
                        return a.crossVectors(i, r), a.normalize(), i.crossVectors(r, a), i.normalize(), e.makeBasis(a, i, r), 0 != e.determinant() ? e : void 0
                    },
                    stableLookatToBasis: function stableLookatToBasis(e, t, n, i, r) {
                        t.copy(r || Object3D.DefaultUp), n.copy(i), e.crossVectors(t, n), e.normalize(), t.crossVectors(n, e), t.normalize()
                    }
                }, (Yt = [])[Jc.RENDER_INTERP] = new(Xt = function() {
                    function EventRunner() {
                        classCallCheck_classCallCheck(this, EventRunner), this.eventFunctions = [], this.eventArgs = []
                    }
                    return createClass_createClass(EventRunner, [{
                        key: "add",
                        value: function add(e, t) {
                            this.eventFunctions.push(e), this.eventArgs.push(t)
                        }
                    }, {
                        key: "clear",
                        value: function clear() {
                            this.eventFunctions.length = 0, this.eventArgs.length = 0
                        }
                    }, {
                        key: "run",
                        value: function run() {
                            var e, t;
                            for (e = 0; e < this.eventFunctions.length; e++) try {
                                void 0 === (t = this.eventArgs[e]) ? nt[this.eventFunctions[e]].call(Ht) : "number" == typeof t ? nt[this.eventFunctions[e]].call(Ht, t) : nt[this.eventFunctions[e]].apply(Ht, t)
                            } catch (e) {
                                throw e
                            }
                        }
                    }]), EventRunner
                }()), Yt[Jc.RENDER_BLIT] = new Xt, Wt = {
                    prevFrame: void 0,
                    curFrame: void 0,
                    curFrameTimestamp: void 0,
                    lastRenderTimestamp: void 0,
                    workingFrame: 0,
                    getFPS: function getFPS() {
                        return ft
                    },
                    getRenderStats: function getRenderStats(e) {
                        return mt[e]
                    },
                    getMemoryStats: function getMemoryStats(e) {
                        return gt[e]
                    },
                    setStats: function setStats(e, t, n) {
                        ft = e, mt = t, gt = n
                    },
                    setTrackerData: function setTrackerData(e) {
                        it = e
                    },
                    createRenderer: function createRenderer(e, t, n) {
                        var i, r = document.getElementById(t);
                        if (!r) throw Error("Canvas ".concat(t, " doesn't exist!"));
                        n.canvas = r, i = new WebGLRenderer(n), tt[e] = i, i.autoClear = !1, i.setClearColor(0, 0), i.physicallyCorrectLights = !0, i.toneMapping = qn, i.outputEncoding = Xr, gt[e] = {
                            geometries: 0,
                            textures: 0
                        }, mt[e] = {
                            calls: 0,
                            triangles: 0
                        }, tt[e].info.autoReset = !1
                    },
                    deleteRenderer: function deleteRenderer(e) {
                        tt[e].dispose(), delete gt[e], delete mt[e], delete tt[e]
                    },
                    setRendererSize: function setRendererSize(e, t, n) {
                        tt[e].setSize(t, n, !1)
                    },
                    setRendererPixelRatio: function setRendererPixelRatio(e, t, n) {
                        n ? tt[e]._pixelRatio = t : tt[e].setPixelRatio(t)
                    },
                    setRendererShadows: function setRendererShadows(e, t, n) {
                        tt[e].shadowMap.enabled = t, tt[e].shadowMap.type = n
                    },
                    beginFrame: function beginFrame() {
                        for (var e = 0; e < Yt.length; e++) Yt[e] && Yt[e].clear();
                        this.workingFrame++
                    },
                    endFrame: function endFrame() {
                        this.prevFrame = this.curFrame, this.curFrame = this.workingFrame, this.curFrameTimestamp = performance.now()
                    },
                    createScene: function createScene(e) {
                        nt[e] = new Scene
                    },
                    deleteScene: function deleteScene(e) {
                        Ze.releaseClone(nt[e]), nt[e] = void 0
                    },
                    createSimpleObject: function createSimpleObject(e) {
                        nt[e] = new Object3D
                    },
                    createObject: function createObject(e, t, n) {
                        var i = et[t];
                        nt[e] = new i(n[0], n[1], n[2], n[3], n[4], n[5], n[6], n[7], n[8], n[9])
                    },
                    deleteObject: function deleteObject(e) {
                        var t = nt[e];
                        t.parent && t.parent.remove(t), t && t.dispose && (t instanceof Scene || t.dispose()), delete nt[e]
                    },
                    callObjectMethod: function callObjectMethod(e, t, n) {
                        nt[e][t].apply(nt[e], n)
                    },
                    setObjectProperty: function setObjectProperty(e, t, n) {
                        nt[e][t] = n
                    },
                    setObjectPropertyExpandObject: function setObjectPropertyExpandObject(e, t, n) {
                        nt[e][t] = nt[n]
                    },
                    addObject: function addObject(e, t) {
                        nt[e].add(nt[t])
                    },
                    removeObject: function removeObject(e) {
                        var t = nt[e];
                        t.parent && t.parent.remove(nt[e])
                    },
                    setObjectPosition: function setObjectPosition(e, t, n, i) {
                        nt[e].position.set(t, n, i)
                    },
                    setObjectQuaternion: function setObjectQuaternion(e, t, n, i, r) {
                        nt[e].rotation.set(t, n, i, r)
                    },
                    setObjectRotation: function setObjectRotation(e, t, n, i) {
                        nt[e].rotation.set(t, n, i)
                    },
                    setObjectScale: function setObjectScale(e, t, n, i) {
                        nt[e].scale.set(t, n, i)
                    },
                    setObjectName: function setObjectName(e, t) {
                        nt[e].name = t
                    },
                    setObjectVisible: function setObjectVisible(e, t) {
                        nt[e].visible = 0 != t
                    },
                    setObjectShadows: function setObjectShadows(e, t, n) {
                        nt[e].traverse((function(e) {
                            e.isMesh && (e.castShadow = t, e.receiveShadow = n)
                        }))
                    },
                    updateObjectMatrix: function updateObjectMatrix(e) {
                        nt[e].updateMatrix()
                    },
                    objectLookatPosition: function objectLookatPosition(e, t, n, i) {
                        nt[e].lookAt(_t.set(t, n, i))
                    },
                    objectLookatObject: function objectLookatObject(e, t) {
                        nt[e].lookAt(nt[t].position)
                    },
                    objectMatchWorldPosition: function objectMatchWorldPosition(e, t) {
                        var n = nt[t];
                        n.updateWorldMatrix(!0, !1), nt[e].position.setFromMatrixPosition(n.matrixWorld)
                    },
                    objectMatchWorldRotation: function objectMatchWorldRotation(e, t) {
                        var n = nt[t];
                        n.updateWorldMatrix(!0, !1), nt[e].quaternion.setFromRotationMatrix(n.matrixWorld)
                    },
                    objectAddPosition: function objectAddPosition(e, t, n, i) {
                        nt[e].position.add(_t.set(t, n, i))
                    },
                    objectRotateX: function objectRotateX(e, t) {
                        nt[e].rotateX(t)
                    },
                    objectRotateY: function objectRotateY(e, t) {
                        nt[e].rotateY(t)
                    },
                    objectRotateZ: function objectRotateZ(e, t) {
                        nt[e].rotateZ(t)
                    },
                    setCameraFov: function setCameraFov(e, t) {
                        nt[e].fov = t
                    },
                    updateCameraProjectionMatrix: function updateCameraProjectionMatrix(e) {
                        nt[e].updateMatrix(), nt[e].updateProjectionMatrix()
                    },
                    createAnimationMixer: function createAnimationMixer(e, t) {
                        nt[e] = new AnimationMixer(nt[t])
                    },
                    updateAnimationMixer: function updateAnimationMixer(e, t) {
                        nt[e].update(t)
                    },
                    rendererClear: function rendererClear(e) {
                        tt[e].clear()
                    },
                    rendererClearDepth: function rendererClearDepth(e) {
                        tt[e].clearDepth()
                    },
                    rendererSetColorMask: function rendererSetColorMask(e, t, n, i, r) {
                        tt[e].getContext().colorMask(0 != t, 0 != n, 0 != i, 0 != r)
                    },
                    rendererRender: function rendererRender(e, t, n) {
                        tt[e].render(nt[t], nt[n])
                    },
                    createObjectFromClone: function createObjectFromClone(e, t, n) {
                        n && n.length > 0 ? nt[e] = Ze.cloneScene(nt[t].getObjectByName(n)) : nt[e] = Ze.cloneScene(nt[t]), nt[e].parent && nt[e].parent.remove(nt[e])
                    },
                    createObjectFromFind: function createObjectFromFind(e, t, n) {
                        nt[e] = nt[t].getObjectByName(n)
                    },
                    createSkeleton: function createSkeleton(e, t) {
                        nt[t].traverse((function(n) {
                            n.isSkinnedMesh && (nt[e] = n.skeleton, n.skeleton.root = nt[t])
                        }))
                    },
                    bindSkeleton: function bindSkeleton(e, t) {
                        nt[e].bind(nt[t], nt[e].matrixWorld)
                    },
                    updateSkeleton: function updateSkeleton(e) {
                        Ze.updateSkeletonMatrices(nt[e])
                    },
                    getSkeletonBone: function getSkeletonBone(e, t, n) {
                        nt[e] = nt[t].getBoneByName(n)
                    },
                    loadGLTF: function loadGLTF(e, t, n) {
                        (function loadGLTFFromData(e) {
                            return new Promise((function(t, n) {
                                g.parse(e, "", (function(e) {
                                    var n, i, r, a = {
                                        object: e,
                                        animations: e.animations,
                                        scene: e.scene,
                                        scenes: e.scenes,
                                        cameras: e.cameras,
                                        asset: e.asset,
                                        physicsEntities: [],
                                        extra: {}
                                    };
                                    if (e.scene.animations = e.animations, e.scene.animations && e.scene.animations.length > 0)
                                        for (a.extra.animations = {}, n = 0; n < e.scene.animations.length; n++) i = e.scene.animations[n], a.extra.animations[i.name] = {
                                            duration: i.duration
                                        };
                                    for (y.length = 0, e.scene.traverse((function(e) {
                                            void 0 !== e.userData.mass ? e.visible = !1 : (e.castShadow = !0, e.receiveShadow = !0, "true" === e.userData.visible ? (e.castShadow = !1, e.receiveShadow = !0) : "false" === e.userData.visible && (e.visible = !1), e.userData.physics, e.userData.physics), e.isLight && y.push(e)
                                        })), r = 0; r < y.length; r++) y[r].parent.remove(y[r]);
                                    t(a)
                                }), (function(e) {
                                    n(e)
                                }))
                            }))
                        })(t).then((function(t) {
                            nt[e] = t.scene, n(t.extra)
                        }))
                    },
                    loadTex: function loadTex(e, t, n) {
                        var i = {};
                        ! function loadTexFromData(e, t, n) {
                            var i = URL.createObjectURL(new Blob([new Uint8Array(e)]));
                            f.load(i, (function(e) {
                                t.tex = e, t.tex.needsUpdate = !0, URL.revokeObjectURL(i), n(0)
                            }), void 0, (function() {
                                URL.revokeObjectURL(i), n(1)
                            }))
                        }(t, i, (function(t) {
                            t || (nt[e] = i.tex, nt[e].needsUpdate = !0), n(t)
                        }))
                    },
                    createShader: function createShader(e, t) {
                        nt[e] = t
                    },
                    createUniforms: function createUniforms(e, t, n) {
                        var i, r, a = {};
                        if (t)
                            for (i = 0; i < t.length; i++) r = t[i], a = Object.assign(a, "string" == typeof r ? Ss[r] : "number" == typeof r ? nt[r] : r);
                        nt[e] = a, void 0 !== n && (Ss[n] = nt[e])
                    },
                    cloneUniforms: function cloneUniforms(e, t, n) {
                        nt[e] = n ? Object.assign({}, nt[t]) : ys.clone(nt[t])
                    },
                    cloneMaterial: function cloneMaterial(e, t) {
                        nt[e] = nt[t].clone()
                    },
                    createMaterial: function createMaterial(e, t, n, i, r) {
                        r.uniforms = nt[i], r.vertexShader = nt[t], r.fragmentShader = nt[n], nt[e] = new ShaderMaterial(r)
                    },
                    setMaterialDefines: function setMaterialDefines(e, t) {
                        nt[e].defines = t, nt[e].needsUpdate = !0
                    },
                    setObjectMaterial: function setObjectMaterial(e, t) {
                        nt[e].traverse((function(e) {
                            e.isMesh && (e.material = nt[t])
                        }))
                    },
                    setObjectDepthMaterial: function setObjectDepthMaterial(e, t) {
                        nt[e].isMesh ? nt[e].customDepthMaterial = nt[t] : nt[e].traverse((function(e) {
                            e.isMesh && (e.customDepthMaterial = nt[t])
                        }))
                    },
                    setObjectCustomMaterial: function setObjectCustomMaterial(e, t, n) {
                        nt[e].isMesh ? nt[e][t] = nt[n] : nt[e].traverse((function(e) {
                            e.isMesh && (e[t] = nt[n])
                        }))
                    },
                    unshareUniform: function unshareUniform(e, t) {
                        nt[e][t] = void 0
                    },
                    setUniformTex: function setUniformTex(e, t, n) {
                        nt[e][t] ? (nt[e][t].value = nt[n], nt[e][t].needsUpdate = !0) : nt[e][t] = {
                            type: "t",
                            value: nt[n]
                        }
                    },
                    setUniformTexCube: function setUniformTexCube(e, t, n) {
                        nt[e][t] ? (nt[e][t].value = nt[n], nt[e][t].needsUpdate = !0) : nt[e][t] = {
                            value: nt[n]
                        }
                    },
                    setUniformFloat: function setUniformFloat(e, t, n) {
                        nt[e] && (nt[e][t] ? (nt[e][t].value = n, nt[e][t].needsUpdate = !0) : nt[e][t] = {
                            value: n
                        })
                    },
                    setUniformFloat2: function setUniformFloat2(e, t, n, i) {
                        nt[e][t] ? (nt[e][t].value.set(n, i), nt[e][t].needsUpdate = !0) : nt[e][t] = {
                            value: new Vector2(n, i)
                        }
                    },
                    setUniformFloat3: function setUniformFloat3(e, t, n, i, r) {
                        nt[e][t] ? (nt[e][t].value.set(n, i, r), nt[e][t].needsUpdate = !0) : nt[e][t] = {
                            value: new Vector3(n, i, r)
                        }
                    },
                    setUniformFloat4: function setUniformFloat4(e, t, n, i, r, a) {
                        nt[e][t] ? (nt[e][t].value.set(n, i, r, a), nt[e][t].needsUpdate = !0) : nt[e][t] = {
                            value: new Vector4(n, i, r, a)
                        }
                    },
                    setTexWrapping: function setTexWrapping(e, t, n) {
                        nt[e].wrapS = t, nt[e].wrapT = n, nt[e].needsUpdate = !0
                    },
                    createFunction: function createFunction(e, t, n, i) {
                        nt[e] = Function(n, i), Ht[t] = nt[e], at[e] = t
                    },
                    deleteFunction: function deleteFunction(e) {
                        delete nt[e];
                        var t = at[e];
                        delete at[e], delete Ht[t]
                    },
                    createFunctionNoThread: function createFunctionNoThread(e, t, n) {
                        nt[e] = n, Ht[t] = nt[e], n = n.bind(Ht)
                    },
                    runFunction: function runFunction(e, t) {
                        try {
                            void 0 === t ? nt[e].call(Ht) : "number" == typeof t ? nt[e].call(Ht, t) : nt[e].apply(Ht, t)
                        } catch (e) {
                            throw e
                        }
                    },
                    runFunctionWithParams: function runFunctionWithParams(e, t, n, i, r, a) {
                        try {
                            nt[e].call(Ht, t, n, i, r, a)
                        } catch (e) {
                            throw e
                        }
                    },
                    runFunctionAtEvent: function runFunctionAtEvent(e, t, n) {
                        Yt[t].add(e, n)
                    },
                    playAnimation: function playAnimation(e, t, n, i, r, a) {
                        var o, s = 0 != (1 & a),
                            l = 0 != (2 & a),
                            c = 0 != (4 & a),
                            u = nt[t],
                            h = nt[e],
                            d = AnimationClip.findByName(u, n);
                        if (void 0 === d) throw Error("No scene animation named " + n);
                        o = h.clipAction(d), Ze.cleanupAnimationMixerBindings(h), s && h.stopAllAction(), 0 != i && o.fadeIn(i), o.timeScale = r, o.setLoop(l ? Fr : Ir), o.clampWhenFinished = c, o.play()
                    },
                    createClip: function createClip(e, t, n, i) {
                        var r = nt[n],
                            a = AnimationClip.findByName(r, i),
                            o = nt[t];
                        nt[e] = o.clipAction(a)
                    },
                    setClipWeight: function setClipWeight(e, t) {
                        nt[e].setEffectiveWeight(t)
                    },
                    setClipTime: function setClipTime(e, t) {
                        nt[e].time = t
                    },
                    updateClipTime: function updateClipTime(e, t) {
                        nt[e]._updateTime(t - nt[e].time)
                    },
                    updateMixerClipTime: function updateMixerClipTime(e, t, n) {
                        var i, r, a, o = nt[e];
                        if (o && o.actions)
                            for (i = o._actions.length, r = 0, r = 0; r < i; r++)(a = o._actions[r])._clip.name == t && a._updateTime(n - a.time)
                    },
                    setClipPlayRate: function setClipPlayRate(e, t) {
                        nt[e].timeScale = t
                    },
                    playClip: function playClip(e) {
                        nt[e].play()
                    },
                    stopAllAnimation: function stopAllAnimation(e) {
                        nt[e].stopAllAction()
                    },
                    createMesh: function createMesh(e, t, n) {
                        nt[e] = new Mesh(nt[t], n ? nt[n] : void 0)
                    },
                    createDirectionalLight: function createDirectionalLight(e) {
                        var t = new DirectionalLight(16777215, .4);
                        nt[e] = t, t.castShadow = !0, t.shadow.camera.near = 1, t.shadow.camera.far = 500, t.shadow.camera.top = 20, t.shadow.camera.right = 20, t.shadow.camera.bottom = -20, t.shadow.camera.left = -20
                    },
                    createDirectionalLightTarget: function createDirectionalLightTarget(e, t) {
                        nt[e] = new Object3D, nt[t].target = nt[e]
                    },
                    setLightShadowSize: function setLightShadowSize(e, t, n) {
                        var i = nt[e];
                        i.shadow.mapSize.width = t, i.shadow.mapSize.height = n, i.shadow.map && i.shadow.map.setSize(t, n)
                    },
                    setSceneFog: function setSceneFog(e, t, n, i, r, a) {
                        var o = nt[e];
                        o.fog ? (o.fog.near = t, o.fog.far = n, o.fog.color.setRGB(i, r, a)) : o.fog = new Fog((new Color).setRGB(i, r, a), t, n)
                    },
                    createInstancedMesh: function createInstancedMesh(e, t, n, i, r) {
                        var a, o, s, l, c, u;
                        for (a = n ? nt[t].getObjectByName(n).geometry : nt[t].geometry, o = nt[i], s = new InstancedBufferAttribute(new Float32Array(3 * r), 3), a.setAttribute("instanceColor", s), (l = new InstancedMesh(a, o, r)).name = "InstancedMesh - " + n, l.frustumCulled = !1, l.instanceColor = s, l.instanceMatrix.setUsage(_a), nt[e] = l, nt[e].matrixAutoUpdate = !1, c = _t.set(0, 0, 0), Dt.identity().scale(c), u = 0; u < r; u++) l.setMatrixAt(u, Dt);
                        (o = l.material).uniforms && Object.values(o.uniforms).forEach((function(e) {
                            e.value && "object" == _typeof(e.value) && (e.value.onlyUpdateOnce ? (e.value = e.value.clone(), e.value.needsUpdate = !0) : e.value.needsUpdate = !0)
                        }))
                    },
                    setInstanceTransform: function setInstanceTransform(e, t, n) {
                        nt[e].setMatrixAt(t, n), nt[e].instanceMatrix.needsUpdate = !0
                    },
                    setInstanceColor: function setInstanceColor(e, t, n, i, r) {
                        nt[e].setColorAt(t, jt.setRGB(n, i, r)), nt[e].instanceColor.needsUpdate = !0
                    },
                    setInstanceCount: function setInstanceCount(e, t) {
                        nt[e].geometry.instanceCount = t
                    },
                    createFloatInterp: function createFloatInterp(e) {
                        nt[e] = new yt
                    },
                    setFloatInterp: function setFloatInterp(e, t) {
                        nt[e].setValue(this.workingFrame, t)
                    },
                    createVectorInterp: function createVectorInterp(e) {
                        nt[e] = new xt
                    },
                    setVectorInterp: function setVectorInterp(e, t, n, i) {
                        nt[e].setValue(this.workingFrame, t, n, i)
                    },
                    getFloatInterp: function getFloatInterp(e, t) {
                        return nt[e].getValue(t)
                    },
                    getVectorInterp: function getVectorInterp(e, t) {
                        return nt[e].getValue(t)
                    },
                    animationFrame: function animationFrame() {
                        var e, t, n, i, r, a, o = ut();
                        for (void 0 === this.lastRenderTimestamp && (this.lastRenderTimestamp = o), e = 0, t = o - this.lastRenderTimestamp, n = o - this.curFrameTimestamp, void 0 !== this.curFrame && void 0 !== this.curFrameTimestamp && (e = n / 1e3 / ct), this.lastRenderTimestamp = o, Ht.prevFrame = this.curFrame - 1, Ht.curFrame = this.curFrame, Ht.interp = e, Ht.timeDelta = t / 1e3, i = 0; i < tt.length; i++) tt[i] && tt[i].info.reset();
                        if (Yt[Jc.RENDER_INTERP].run(), Yt[Jc.RENDER_BLIT].run(), (r = ut()) - o, pt++, r > dt + 1e3) {
                            for (ft = 1e3 * pt / (r - dt), dt = r, pt = 0, a = 0; a < tt.length; a++) tt[a] && (mt[a] = tt[a].info.render, gt[a] = tt[a].info.memory);
                            "undefined" != typeof WorkerGlobalScope && self instanceof WorkerGlobalScope && postMessage({
                                type: "stats",
                                fps: ft,
                                renderStats: mt,
                                memoryStats: gt
                            })
                        }
                    },
                    createSpriteMaterial: function createSpriteMaterial(e, t) {
                        t.map = nt[t.map], nt[e] = new SpriteMaterial(t)
                    },
                    createSprite: function createSprite(e, t) {
                        var n = nt[t];
                        nt[e] = new Sprite(n.clone()), nt[e].material.map.needsUpdate = !0, nt[e].material.needsUpdate = !0
                    },
                    createSpriteDesc: function createSpriteDesc(e, t, n) {
                        var i = nt[t];
                        n.materialOrTexture = i, nt[e] = n
                    },
                    createSpriteSet: function createSpriteSet(e, t, n) {
                        var i = nt[t];
                        nt[e] = new L(i.materialOrTexture, i, n)
                    },
                    setSpriteOpacity: function setSpriteOpacity(e, t) {
                        nt[e].material.opacity = t
                    },
                    setSpriteRotation: function setSpriteRotation(e, t) {
                        nt[e].material.rotation = t
                    },
                    createTrackerObject: function createTrackerObject(e, t, n) {
                        rt[t] = nt[n], nt[e] = {
                            trackerObjectId: t,
                            bindObject: nt[n],
                            dispose: function dispose() {
                                delete rt[t]
                            }
                        }
                    },
                    updateTrackerObjects: function updateTrackerObjects() {
                        var e, t, n;
                        for (e = 0; e < rt.length; e++) rt[e] && (n = 7 * e, (t = rt[e]).updateWorldMatrix(!0, !1), t.matrixWorld.decompose(_t, Et, bt), it[n + 0] = _t.x, it[n + 1] = _t.y, it[n + 2] = _t.z, it[n + 3] = Et.x, it[n + 4] = Et.y, it[n + 5] = Et.z, it[n + 6] = Et.w)
                    },
                    createComposer: function createComposer(e, t) {
                        nt[e] = new R(tt[t])
                    },
                    composerCreateRenderPass: function composerCreateRenderPass(e, t, n, i, r, a) {
                        var o = new N(nt[t], nt[n], i ? nt[i] : void 0);
                        o.clear = r, o.clearDepth = a, nt[e] = o
                    },
                    composerCreateFXAAPass: function composerCreateFXAAPass(e) {
                        var t = new O(z);
                        t.setSize = function(e, t) {
                            this.material.uniforms.resolution.value.x = 1 / e, this.material.uniforms.resolution.value.y = 1 / t
                        }, nt[e] = t
                    },
                    composerCreateDOFPass: function composerCreateDOFPass(e, t, n, i) {
                        var r = new X(nt[t], nt[n], i);
                        nt[e] = r
                    },
                    composerAddPass: function composerAddPass(e, t) {
                        var n = nt[t];
                        nt[e].addPass(n)
                    },
                    composerRemovePass: function composerRemovePass(e, t) {
                        var n = nt[t];
                        nt[e].removePass(n)
                    },
                    composerSetSize: function composerSetSize(e, t, n, i) {
                        nt[e].setSize(t, n, i)
                    },
                    createMergedMesh: function createMergedMesh(e, t) {
                        nt[e] = w.createMergedMesh(nt[t])
                    },
                    generateEnvMap: function generateEnvMap(e, t) {
                        var n, i = function getEnvScene() {
                                var e, t, n, i, r, a = new Scene,
                                    o = new BoxBufferGeometry;
                                return o.deleteAttribute("uv"), (e = new Mesh(o, new MeshStandardMaterial({
                                    metalness: 0,
                                    side: un
                                }))).scale.setScalar(10), a.add(e), t = new PointLight(16777215, 50, 0, 2), a.add(t), (i = new Mesh(o, n = new MeshLambertMaterial({
                                    color: 0,
                                    emissive: 16777215,
                                    emissiveIntensity: 10
                                }))).position.set(-5, 2, 0), i.scale.set(.1, 1, 1), a.add(i), (r = new Mesh(o, n)).position.set(0, 5, 0), r.scale.set(1, .1, 1), a.add(r), (r = new Mesh(o, n)).position.set(2, 1, 5), r.scale.set(1.5, 2, .1), a.add(r), a
                            }(),
                            r = tt[t],
                            a = new PMREMGenerator(r);
                        a.compileCubemapShader(), n = a.fromScene(i, .04), nt[e] = n.texture, nt[e].onlyUpdateOnce = !0, a.dispose()
                    },
                    mergeMeshes: function mergeMeshes(e, t) {
                        var n, i, r, a, o, s, l, c, u, h, d, p, f = ut(),
                            m = Object.assign({}, t),
                            g = [],
                            y = [],
                            x = [];
                        for (m.slots = g, m.statics = y, m.draws = t.draws ? x : void 0, n = t.slots, i = 0; i < n.length; i++)
                            if (g[i] = Object.assign({}, t.slots[i]), n[i]) {
                                for (n[i].model && (g[i].model = nt[n[i].model].getObjectByName(n[i].modelName)), g[i].modelName = n[i].modelName, r = 0; r < t.images.length; r++) a = t.images[r], "number" == typeof n[i][a] ? g[i][a] = nt[n[i][a]] : g[i][a] = n[i][a];
                                g[i].uScale = n[i].uScale, g[i].vScale = n[i].vScale, g[i].uOfs = n[i].uOfs, g[i].vOfs = n[i].vOfs
                            }
                        for (o = t.statics, s = 0; s < o.length; s++)
                            if (y[s] = Object.assign({}, t.statics[s]), o[s]) {
                                for (o[s].model && (y[s].model = nt[o[s].model].getObjectByName(o[s].modelName)), y[s].modelName = o[s].modelName, l = 0; l < t.images.length; l++) c = t.images[l], "number" == typeof o[s][c] ? y[s][c] = nt[o[s][c]] : y[s][c] = o[s][c];
                                y[s].uScale = o[s].uScale, y[s].vScale = o[s].vScale, y[s].uOfs = o[s].uOfs, y[s].vOfs = o[s].vOfs
                            }
                        if (u = t.draws)
                            for (h = 0; h < u.length; h++)
                                if (x[h] = Object.assign({}, t.draws[h]), u[h]) {
                                    for (u[h].model && (x[h].model = nt[u[h].model].getObjectByName(u[h].modelName)), x[h].modelName = u[h].modelName, d = 0; d < t.images.length; d++) p = t.images[d], "number" == typeof u[h][p] ? x[h][p] = nt[u[h][p]] : x[h][p] = u[h][p];
                                    x[h].uScale = u[h].uScale, x[h].vScale = u[h].vScale, x[h].uOfs = u[h].uOfs, x[h].vOfs = u[h].vOfs
                                }
                        t.debugMat && (m.debugMat = nt[t.debugMat]), w.merge(nt[e], m), ut()
                    }
                }, "undefined" != typeof WorkerGlobalScope && self instanceof WorkerGlobalScope ? (qt = function handleCommand(e, t) {
                    switch (e) {
                        case Qc.CREATE_RENDERER:
                            Wt.createRenderer(Jt.readInt(), Jt.readInt(), Jt.readObject());
                            break;
                        case Qc.DELETE_RENDERER:
                            Wt.deleteRenderer(Jt.readInt());
                        case Qc.SET_RENDERER_SIZE:
                            Wt.setRendererSize(Jt.readInt(), Jt.readInt(), Jt.readInt());
                            break;
                        case Qc.SET_RENDERER_PIXEL_RATIO:
                            Wt.setRendererPixelRatio(Jt.readInt(), Jt.readFloat(), Jt.readInt());
                            break;
                        case Qc.SET_RENDERER_SHADOWS:
                            Wt.setRendererShadows(Jt.readInt(), 0 != Jt.readInt(), Jt.readInt());
                            break;
                        case Qc.CREATE_SCENE:
                            Wt.createScene(Jt.readInt());
                            break;
                        case Qc.DELETE_SCENE:
                            Wt.deleteScene(Jt.readInt());
                            break;
                        case Qc.CREATE_OBJECT:
                            Wt.createObject(Jt.readInt(), Jt.readString(), Jt.readObject());
                            break;
                        case Qc.CREATE_SIMPLE_OBJECT:
                            Wt.createSimpleObject(Jt.readInt());
                            break;
                        case Qc.DELETE_OBJECT:
                            Wt.deleteObject(Jt.readInt());
                            break;
                        case Qc.ADD_OBJECT:
                            Wt.addObject(Jt.readInt(), Jt.readInt());
                            break;
                        case Qc.REMOVE_OBJECT:
                            Wt.removeObject(Jt.readInt());
                            break;
                        case Qc.CALL_OBJECT_METHOD:
                            Wt.callObjectMethod(Jt.readInt(), Jt.readString(), Jt.readObject());
                            break;
                        case Qc.SET_OBJECT_PROPERTY:
                            Wt.setObjectProperty(Jt.readInt(), Jt.readString(), Jt.readObject());
                            break;
                        case Qc.SET_OBJECT_PROPERTY_EXPAND_OBJECT:
                            Wt.setObjectPropertyExpandObject(Jt.readInt(), Jt.readString(), Jt.readInt());
                            break;
                        case Qc.SET_OBJECT_POSITION:
                            Wt.setObjectPosition(Jt.readInt(), Jt.readFloat(), Jt.readFloat(), Jt.readFloat());
                            break;
                        case Qc.SET_OBJECT_QUATERNION:
                            Wt.setObjectQuaternion(Jt.readInt(), Jt.readFloat(), Jt.readFloat(), Jt.readFloat(), Jt.readFloat());
                            break;
                        case Qc.SET_OBJECT_ROTATION:
                            Wt.setObjectRotation(Jt.readInt(), Jt.readFloat(), Jt.readFloat(), Jt.readFloat());
                            break;
                        case Qc.SET_OBJECT_SCALE:
                            Wt.setObjectScale(Jt.readInt(), Jt.readFloat(), Jt.readFloat(), Jt.readFloat());
                            break;
                        case Qc.SET_OBJECT_NAME:
                            Wt.setObjectName(Jt.readInt(), Jt.readString());
                            break;
                        case Qc.SET_OBJECT_VISIBLE:
                            Wt.setObjectVisible(Jt.readInt(), Jt.readInt());
                            break;
                        case Qc.SET_OBJECT_SHADOWS:
                            Wt.setObjectShadows(Jt.readInt(), 0 != Jt.readInt(), 0 != Jt.readInt());
                            break;
                        case Qc.UPDATE_OBJECT_MATRIX:
                            Wt.updateObjectMatrix(Jt.readInt());
                            break;
                        case Qc.OBJECT_LOOKAT_OBJECT:
                            Wt.objectLookatObject(Jt.readInt(), Jt.readInt());
                            break;
                        case Qc.OBJECT_LOOKAT_POSITION:
                            Wt.objectLookatPosition(Jt.readInt(), Jt.readFloat(), Jt.readFloat(), Jt.readFloat());
                            break;
                        case Qc.SET_CAMERA_FOV:
                            Wt.setCameraFov(Jt.readInt(), Jt.readFloat());
                            break;
                        case Qc.OBJECT_MATCH_WORLD_POSITION:
                            Wt.objectMatchWorldPosition(Jt.readInt(), Jt.readInt());
                            break;
                        case Qc.OBJECT_MATCH_WORLD_ROTATION:
                            Wt.objectMatchWorldRotation(Jt.readInt(), Jt.readInt());
                            break;
                        case Qc.OBJECT_ADD_POSITION:
                            Wt.objectAddPosition(Jt.readInt(), Jt.readFloat(), Jt.readFloat(), Jt.readFloat());
                            break;
                        case Qc.OBJECT_ROTATE_X:
                            Wt.objectRotateX(Jt.readInt(), Jt.readFloat());
                            break;
                        case Qc.OBJECT_ROTATE_Y:
                            Wt.objectRotateY(Jt.readInt(), Jt.readFloat());
                            break;
                        case Qc.OBJECT_ROTATE_Z:
                            Wt.objectRotateZ(Jt.readInt(), Jt.readFloat());
                            break;
                        case Qc.UPDATE_CAMERA_PROJECTION_MATRIX:
                            Wt.updateCameraProjectionMatrix(Jt.readInt());
                            break;
                        case Qc.CREATE_OBJECT_FROM_CLONE:
                            Wt.createObjectFromClone(Jt.readInt(), Jt.readInt(), Jt.readString());
                            break;
                        case Qc.CREATE_OBJECT_FROM_FIND:
                            Wt.createObjectFromFind(Jt.readInt(), Jt.readInt(), Jt.readString());
                            break;
                        case Qc.CREATE_ANIMATION_MIXER:
                            Wt.createAnimationMixer(Jt.readInt(), Jt.readInt());
                            break;
                        case Qc.UPDATE_ANIMATION_MIXER:
                            Wt.updateAnimationMixer(Jt.readInt(), Jt.readFloat());
                            break;
                        case Qc.RENDERER_CLEAR:
                            Wt.rendererClear(Jt.readInt());
                            break;
                        case Qc.RENDERER_CLEARDEPTH:
                            Wt.rendererClearDepth(Jt.readInt());
                            break;
                        case Qc.RENDERER_SETCOLORMASK:
                            Wt.rendererSetColorMask(Jt.readInt(), Jt.readInt(), Jt.readInt(), Jt.readInt(), Jt.readInt());
                            break;
                        case Qc.RENDERER_RENDER:
                            Wt.rendererRender(Jt.readInt(), Jt.readInt(), Jt.readInt());
                            break;
                        case Qc.CREATE_SKELETON:
                            Wt.createSkeleton(Jt.readInt(), Jt.readInt());
                            break;
                        case Qc.UPDATE_SKELETON:
                            Wt.updateSkeleton(Jt.readInt());
                            break;
                        case Qc.BIND_SKELETON:
                            Wt.bindSkeleton(Jt.readInt(), Jt.readInt());
                            break;
                        case Qc.GET_SKELETON_BONE:
                            Wt.getSkeletonBone(Jt.readInt(), Jt.readInt(), Jt.readString());
                            break;
                        case Qc.INSERT_FENCE:
                            return Qt(Jt.readInt()), !0;
                        case Qc.SET_OBJECT_MATERIAL:
                            Wt.setObjectMaterial(Jt.readInt(), Jt.readInt());
                            break;
                        case Qc.SET_OBJECT_DEPTH_MATERIAL:
                            Wt.setObjectDepthMaterial(Jt.readInt(), Jt.readInt());
                            break;
                        case Qc.SET_OBJECT_CUSTOM_MATERIAL:
                            Wt.setObjectCustomMaterial(Jt.readInt(), Jt.readString(), Jt.readInt());
                            break;
                        case Qc.CREATE_SHADER:
                            Wt.createShader(Jt.readInt(), Jt.readString());
                            break;
                        case Qc.CREATE_MATERIAL:
                            Wt.createMaterial(Jt.readInt(), Jt.readInt(), Jt.readInt(), Jt.readInt(), Jt.readObject());
                            break;
                        case Qc.CLONE_MATERIAL:
                            Wt.cloneMaterial(Jt.readInt(), Jt.readInt());
                            break;
                        case Qc.CREATE_UNIFORMS:
                            Wt.createUniforms(Jt.readInt(), Jt.readObject(), Jt.readString());
                            break;
                        case Qc.CLONE_UNIFORMS:
                            Wt.cloneUniforms(Jt.readInt(), Jt.readInt(), !!Jt.readInt());
                            break;
                        case Qc.SET_MATERIAL_DEFINES:
                            Wt.setMaterialDefines(Jt.readInt(), Jt.readObject());
                            break;
                        case Qc.UNSHARE_UNIFORM:
                            Wt.unshareUniform(Jt.readInt(), Jt.readString());
                            break;
                        case Qc.SET_UNIFORM_TEX:
                            Wt.setUniformTex(Jt.readInt(), Jt.readString(), Jt.readInt());
                            break;
                        case Qc.SET_UNIFORM_TEX_CUBE:
                            Wt.setUniformTexCube(Jt.readInt(), Jt.readString(), Jt.readInt());
                            break;
                        case Qc.SET_UNIFORM_FLOAT:
                            Wt.setUniformFloat(Jt.readInt(), Jt.readString(), Jt.readFloat());
                            break;
                        case Qc.SET_UNIFORM_FLOAT2:
                            Wt.setUniformFloat2(Jt.readInt(), Jt.readString(), Jt.readFloat(), Jt.readFloat());
                            break;
                        case Qc.SET_UNIFORM_FLOAT3:
                            Wt.setUniformFloat3(Jt.readInt(), Jt.readString(), Jt.readFloat(), Jt.readFloat(), Jt.readFloat());
                            break;
                        case Qc.SET_UNIFORM_FLOAT4:
                            Wt.setUniformFloat4(Jt.readInt(), Jt.readString(), Jt.readFloat(), Jt.readFloat(), Jt.readFloat(), Jt.readFloat());
                            break;
                        case Qc.SET_TEX_WRAPPING:
                            Wt.setTexWrapping(Jt.readInt(), Jt.readInt(), Jt.readInt());
                            break;
                        case Qc.PLAY_ANIMATION:
                            Wt.playAnimation(Jt.readInt(), Jt.readInt(), Jt.readString(), Jt.readFloat(), Jt.readFloat(), Jt.readInt());
                            break;
                        case Qc.CREATE_CLIP:
                            Wt.createClip(Jt.readInt(), Jt.readInt(), Jt.readInt(), Jt.readString());
                            break;
                        case Qc.SET_CLIP_TIME:
                            Wt.setClipTime(Jt.readInt(), Jt.readFloat());
                            break;
                        case Qc.UPDATE_CLIP_TIME:
                            Wt.updateClipTime(Jt.readInt(), Jt.readFloat());
                            break;
                        case Qc.SET_CLIP_PLAYRATE:
                            Wt.setClipPlayRate(Jt.readInt(), Jt.readFloat());
                            break;
                        case Qc.SET_CLIP_WEIGHT:
                            Wt.setClipWeight(Jt.readInt(), Jt.readFloat());
                            break;
                        case Qc.PLAY_CLIP:
                            Wt.playClip(Jt.readInt());
                            break;
                        case Qc.STOP_ALL_ANIMATION:
                            Wt.stopAllAnimation(Jt.readInt());
                            break;
                        case Qc.CREATE_FUNCTION:
                            Wt.createFunction(Jt.readInt(), Jt.readString(), Jt.readString(), Jt.readString());
                            break;
                        case Qc.DELETE_FUNCTION:
                            Wt.deleteFunction(Jt.readInt());
                        case Qc.RUN_FUNCTION:
                            Wt.runFunction(Jt.readInt(), Jt.readObject());
                            break;
                        case Qc.RUN_FUNCTION_FAST_PARAM:
                            Wt.runFunction(Jt.readInt(), Jt.readInt());
                            break;
                        case Qc.RUN_FUNCTION_NO_PARAM:
                            Wt.runFunction(Jt.readInt());
                            break;
                        case Qc.RUN_FUNCTION_OPEN_PARAMS:
                            Wt.runFunctionWithParams(Jt.readInt(), Jt, t - 3);
                            break;
                        case Qc.RUN_FUNCTION_AT_EVENT:
                            Wt.runFunctionAtEvent(Jt.readInt(), Jt.readInt(), Jt.readObject());
                            break;
                        case Qc.RUN_FUNCTION_AT_EVENT_FAST_PARAM:
                            Wt.runFunctionAtEvent(Jt.readInt(), Jt.readInt(), Jt.readInt());
                            break;
                        case Qc.RUN_FUNCTION_AT_EVENT_NO_PARAM:
                            Wt.runFunctionAtEvent(Jt.readInt(), Jt.readInt());
                            break;
                        case Qc.CREATE_MESH:
                            Wt.createMesh(Jt.readInt(), Jt.readInt(), Jt.readInt());
                            break;
                        case Qc.CREATE_DIRECTIONAL_LIGHT:
                            Wt.createDirectionalLight(Jt.readInt());
                            break;
                        case Qc.CREATE_DIRECTIONAL_LIGHT_TARGET:
                            Wt.createDirectionalLightTarget(Jt.readInt(), Jt.readInt());
                            break;
                        case Qc.SET_LIGHT_SHADOW_SIZE:
                            Wt.setLightShadowSize(Jt.readInt(), Jt.readInt(), Jt.readInt());
                            break;
                        case Qc.SET_SCENE_FOG:
                            Wt.setSceneFog(Jt.readInt(), Jt.readFloat(), Jt.readFloat(), Jt.readFloat(), Jt.readFloat(), Jt.readFloat());
                            break;
                        case Qc.CREATE_INSTANCED_MESH:
                            Wt.createInstancedMesh(Jt.readInt(), Jt.readInt(), Jt.readString(), Jt.readInt(), Jt.readInt());
                            break;
                        case Qc.SET_INSTANCE_TRANSFORM:
                            Wt.setInstanceTransform(Jt.readInt(), Jt.readInt(), Jt.readMatrix(Dt));
                            break;
                        case Qc.SET_INSTANCE_COLOR:
                            Wt.setInstanceColor(Jt.readInt(), Jt.readInt(), Jt.readFloat(), Jt.readFloat(), Jt.readFloat());
                            break;
                        case Qc.SET_INSTANCE_COUNT:
                            Wt.setInstanceCount(Jt.readInt(), Jt.readInt());
                            break;
                        case Qc.BEGIN_FRAME:
                            Wt.beginFrame();
                            break;
                        case Qc.END_FRAME:
                            Wt.endFrame(), Jt.writeAuxControlInt(0, Wt.prevFrame), Wt.updateTrackerObjects();
                            break;
                        case Qc.CREATE_FLOAT_INTERP:
                            Wt.createFloatInterp(Jt.readInt());
                            break;
                        case Qc.SET_FLOAT_INTERP:
                            Wt.setFloatInterp(Jt.readInt(), Jt.readFloat());
                            break;
                        case Qc.CREATE_VECTOR_INTERP:
                            Wt.createVectorInterp(Jt.readInt());
                            break;
                        case Qc.SET_VECTOR_INTERP:
                            Wt.setVectorInterp(Jt.readInt(), Jt.readFloat(), Jt.readFloat(), Jt.readFloat());
                            break;
                        case Qc.CREATE_SPRITE_MATERIAL:
                            Wt.createSpriteMaterial(Jt.readInt(), Jt.readObject());
                            break;
                        case Qc.CREATE_SPRITE:
                            Wt.createSprite(Jt.readInt(), Jt.readInt());
                            break;
                        case Qc.SET_SPRITE_OPACITY:
                            Wt.setSpriteOpacity(Jt.readInt(), Jt.readFloat());
                            break;
                        case Qc.SET_SPRITE_ROTATION:
                            Wt.setSpriteRotation(Jt.readInt(), Jt.readFloat());
                            break;
                        case Qc.CREATE_TRACKER_OBJECT:
                            Wt.createTrackerObject(Jt.readInt(), Jt.readInt(), Jt.readInt());
                            break;
                        case Qc.CREATE_MERGED_MESH:
                            Wt.createMergedMesh(Jt.readInt(), Jt.readInt());
                            break;
                        case Qc.MERGE_MESHES:
                            Wt.mergeMeshes(Jt.readInt(), Jt.readObject());
                            break;
                        case Qc.CREATE_SPRITE_DESC:
                            Wt.createSpriteDesc(Jt.readInt(), Jt.readInt(), Jt.readObject());
                            break;
                        case Qc.CREATE_SPRITE_SET:
                            Wt.createSpriteSet(Jt.readInt(), Jt.readInt(), Jt.readInt());
                            break;
                        case Qc.UPDATE_MIXER_CLIP_TIME:
                            Wt.updateMixerClipTime(Jt.readInt(), Jt.readString(), Jt.readFloat());
                            break;
                        case Qc.CREATE_COMPOSER:
                            Wt.createComposer(Jt.readInt(), Jt.readInt());
                            break;
                        case Qc.COMPOSER_CREATE_RENDER_PASS:
                            Wt.composerCreateRenderPass(Jt.readInt(), Jt.readInt(), Jt.readInt(), Jt.readInt(), Jt.readInt(), Jt.readInt());
                            break;
                        case Qc.COMPOSER_CREATE_FXAA_PASS:
                            Wt.composerCreateFXAAPass(Jt.readInt());
                            break;
                        case Qc.COMPOSER_CREATE_DOF_PASS:
                            Wt.composerCreateDOFPass(Jt.readInt(), Jt.readInt(), Jt.readInt(), Jt.readObject());
                            break;
                        case Qc.COMPOSER_ADD_PASS:
                            Wt.composerAddPass(Jt.readInt(), Jt.readInt());
                            break;
                        case Qc.COMPOSER_REMOVE_PASS:
                            Wt.composerRemovePass(Jt.readInt(), Jt.readInt());
                            break;
                        case Qc.COMPOSER_SET_SIZE:
                            Wt.composerSetSize(Jt.readInt(), Jt.readInt(), Jt.readInt(), Jt.readFloat());
                            break;
                        case Qc.GENERATE_ENV_MAP:
                            Wt.generateEnvMap(Jt.readInt(), commabdBuffer.readInt());
                            break;
                        default:
                            throw Error("Unknown render engine command: " + e)
                    }
                }, Qt = function issueCallback(e) {
                    var t = Array.prototype.slice.call(arguments, 1);
                    postMessage({
                        type: "callback",
                        id: e,
                        args: t
                    })
                }, self.addEventListener("message", (function(e) {
                    if ("start" == e.data.type) {
                        Wt.setTrackerData(new Float32Array(e.data.trackerBuffer)), Jt = new h(e.data.dataBuffer, e.data.controlBuffer), requestAnimationFrame((function render(e) {
                            Jt.commandLoop(qt), Wt.animationFrame(), requestAnimationFrame(render)
                        })), postMessage({
                            type: "started"
                        })
                    } else if ("loadGLTF" == e.data.type) try {
                        Wt.loadGLTF(e.data.objectId, e.data.data, (function(t) {
                            Qt(e.data.callbackId, t)
                        }))
                    } catch (e) {} else if ("loadTex" == e.data.type) try {
                        Wt.loadTex(e.data.objectId, e.data.data, (function(t) {
                            Qt(e.data.callbackId, t)
                        }))
                    } catch (e) {}
                }))) : "undefined" != typeof window && (window.renderEngineMain = Wt)
        })(), e
    })()
}));